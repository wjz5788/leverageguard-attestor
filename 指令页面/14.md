zms，这份报告的框架可以，但有几处“看起来完成、实际未落地”的断点，会让上线判定产生错觉。我给你一版**勘误 + 强化版落地清单**——短平快、能直接改文档也能直接开工。

# 勘误与补充（按严重度）

**🔴 CRITICAL-0：支付流伪造风险未收录**

* 现状：`createOrder` 只要传入 `paymentTx` 就标记为已支付，未做链上/金库校验（你自己在 P0-01 也指出了）。
* 修正：把本问题加入“2.1 高风险问题”首位，并把“修复路线图 6.1-1”改为**“支付流改造优先于合约补齐”**：后端必须以**链上事件/金库流水为真实源**（Source of Truth），客户端上送的 `paymentTx` 只做提示，不参与状态流转。

**🔴 CRITICAL-1：JP-verify 接入鉴权与时序校验缺失**

* 现状：报告里没明确“必须具备 HMAC-SHA256 + timestamp/nonce 滑动窗口 + IP 白名单”的刚性要求。
* 修正：将其列为“2.1 高风险问题”。拒绝**无签名 / 过期签名 / 重放**请求，并把 `X-Timestamp` 与 `X-Nonce` 纳入证据记录。

**🔴 CRITICAL-2：EIP-712 与 Merkle 证据在报告中被标记 ✅，但合约目录为空**

* 现状：报告写“✅ EIP-712签名验证、✅ Merkle树证据生成”，与“contracts 为空”和你当前实现不符。
* 修正：将这两项改为**目标状态（Planned）**，移出“已完成”。把“证据链生成”改为**“离线 JSON 证据 + 仅 Root 上链（计划中）”**。

**🔴 CRITICAL-3：可逆密钥安全（API Key 加密）必须有“密钥轮转 + 版本化”**

* 现状：报告有“实现 AES-256-GCM”，但缺少**密钥管理与版本化（KEK/DEK）**。
* 修正：

  * 采用**包封加密**：`DEK(vN)` 随机生成，用 `MKEK`（环境/外置 KMS）包封；密文存 `ciphertext`, `dek_version`, `aad`（如 `userId|accountId`）。
  * 轮转：新增 `DEK(vN+1)` 后批量重加密；旧版保留可解 7–30 天。
  * 日志：**绝不**回显密钥/密文，审计日志仅记录 `accountId` 与 `dek_version`。

**🔴 HIGH：CORS 与网络面暴露**

* 现状：报告轻描淡写。
* 修正：明确“仅允许 `us-frontend` 的精确域名 + 预发域”，`Authorization` 头白名单化，OPTIONS 预检只放行需要的动词/头；JP-verify 8082 按**美国后端固定公网 IP**做 IP 白名单。

**🟡 MEDIUM：输入校验、限流、幂等与错误面具**

* 现状：笼统描述，缺**验收标准**。
* 修正：

  * **输入**：对每个 `POST`/`PUT` 定义 Zod/Pydantic schema；枚举值白名单、数值范围、正则。
  * **限流**：对 `/orders`、`/claims`、`/verify` 设置**用户+IP** 双键限流；
  * **幂等**：`Idempotency-Key` 头 + 24h 窗口；
  * **错误面具**：统一错误结构 `{code, message, requestId}`，默认 400/422/429/500，不回栈。

**🟢 LOW：日志与可观测性提升为“提交闸门”**

* Structured log（JSON）+ `requestId` 贯穿 JP↔US；事件流标准化（见下）。

---

# “policy” 与数据面定义（把概念说透）

你之前问“**policy 字段是什么意思**”。在 LiqPass 里，**policy = 一次覆盖合约**（参数化赔付工具的一份订单/保单）。建议统一“订单 = 购买 policy 的交易记录；policy = 覆盖条款本体”。

**Policy 关键字段（最小集合）**

* `policyId`（雪花/ULID）
* `userId`
* `exchange`（OKX/…）
* `principal`（覆盖本金上限，≤500 USDT）
* `leverage`（20–100x，或 `leverage_band`）
* `coverage_window`：`start_ts`、`end_ts`（例如 24h/8h 时段保）
* `trigger_type`：`forced_liq|ADL`
* `payout_rule`：`fixed|proportional` + `cap`（定额或阈值比例与上限）
* `fee_paid`（费用）
* `quote_id`（溯源）
* `evidence_root`（计划：上链的 Merkle Root；未上链时为空）
* `status`：`active|expired|claimed|paid|rejected`
* `orderIdHash`（覆盖的交易/仓位标识哈希，避免明文）
* `attestation_batch_id`（见下一节）

---

# “批量窗口”到底做什么（降 Gas 的正确打开方式）

目标：把**频繁的小上链**合并为**准实时批量上链**，同时保留**时序与可追溯性**。

**两类批量：**

1. **Attestation 批**（证据上链批）

   * 周期：`batch_window_sec = 300`（建议 5 分钟起步）；
   * 过程：JP-verify 汇总窗口内的 `verification_leaves` → 计算 `root` → US-backend 代表发 `Attested(root)`；
   * 追溯：每条 `policyId` 存 `leaf_hash` 与 `attestation_batch_id`。
   * 失败处理：**本地落盘 + 重试队列 + 指数退避**。

2. **Payout 批**（赔付批量）

   * 触发：窗口定时 或 队列长度阈值；
   * 过程：聚合同一 token 的赔付，合约 `batchPayout([recipient, amount, policyId])`；
   * SLO：普通用户 T+30min 资金可达；极端时退化为单笔即时。

> 取舍：**更低 Gas ↔ 更长确认延迟**。建议：证据 5 分钟批；赔付 30 分钟批；关键活动期临时降到 1–5 分钟。

---

# 事件与日志标准（上链前也能审计）

统一事件名与字段，让日志就是“可读的链下审计账”。

* `QuoteIssued{quoteId, userId, params, fee, expireAt}`
* `OrderCreated{orderId, userId, quoteId}`
* `PaymentObserved{orderId, chainTx/hash|treasuryTxnId, amount, token}` ← **仅来自链/金库**
* `PolicyActivated{policyId, orderId}`
* `VerificationRecorded{policyId, leafHash, exchange, orderRef, ts}`
* `AttestationCommitted{batchId, root, leaves, ts}`
* `ClaimRequested{policyId, claimant}`
* `PayoutQueued{policyId, amount}`
* `PayoutExecuted{policyId, txHash|batchId, amount}`
* `SecurityEvent{type, actor, ip, detail}`（密钥尝试、重放拒绝、限流命中等）

---

# 上线闸门（Go/No-Go）——**必须全部为绿**

1. 支付流：客户端伪造 `paymentTx` 不会改变任何订单状态（验证用黑盒脚本）。
2. JP-verify：仅接受**签名 + 时间窗 + IP 白名单**请求；重放被拒且有审核日志。
3. CORS：仅允许明确域名；模糊域或 `*` 一律拒。
4. 密钥存储：API Key 以 AES-GCM 存储，`dek_version` 有效，支持一键轮转；日志零泄露。
5. 输入校验：对每个可写接口有 schema 与单测，越界/非法枚举被拒。
6. 限流/幂等：`/orders`、`/claims`、`/verify` 命中策略可见；重复请求不产生重复资源。
7. 证据留痕：任意 `policyId` 可从日志与 DB 追溯到 `leafHash` 与（有则）`root`。
8. 灰度演练：模拟 1,000 笔 `verify` 在 10 分钟窗口，丢单率 `=0`，重试≤3 次。
9. 混沌注入：JP-verify 停机 5 分钟，队列不丢；恢复后批量补齐。
10. 安全基线：依赖清单过 SCA 扫描，无高危；环境变量最小化；调试端点关闭。
11. 观测：US/JP 双端都有 `healthz`、`/metrics`；告警触发值（错误率、队列堆积、批失败）。
12. 文档：用户数据与密钥处理、数据保留期、撤销路径（删除 API Key）均可公开说明。

---

# 两周修复作战图（可并行 2–3 人）

**D1–D3：熔断级修复**

* 改造支付流（以链/金库事件驱动）
* JP-verify 鉴权三件套（HMAC + 时间窗 + IP 白名单）
* CORS 精确白名单
* 建立统一错误面具 & 结构化日志

**D4–D7：数据与批量**

* `policy`/`orders`/`verifications`/`attestation_batches`/`payout_batches` 表结构落地（含索引与外键）
* 证据批量与重试队列（持久化）
* 限流 + 幂等 + 审计事件全链路

**D8–D10：密钥与合规模块**

* KEK/DEK 包封、轮转、`dek_version` 灰度演练
* 密钥“撤销/删除”路径与数据保留策略文档化

**D11–D14：合约与回归**

* 最小可用合约：`Attest(root)` & `batchPayout`（仅签名校验与事件）
* e2e 回归 + 压测 + 演练 + Go/No-Go 会议

---

# “AI 再审计”强提示词（直接拷贝即用）

> 目标：对 **/LiqPass-clean** 进行**安全优先**的全量再审计与回归核对；输出**机器可读清单** + **人类可读摘要**。

```
你是资深安全审计工程师。对本仓库做“安全优先”的再审计与回归核对：

【强制检查清单】
1) 支付流：搜索后端是否存在以客户端上送的 paymentTx 改写订单状态的路径；确认是否以链上事件/金库流水为唯一状态源；列出所有相关函数与文件位置。
2) CORS：列出所有 CORS 配置，判断是否存在通配符或过宽白名单。
3) 鉴权：JP-verify 是否强制 HMAC-SHA256 + 时间戳窗口 + nonce + IP 白名单；给出缺失点与修复位点。
4) 输入校验：逐接口列出 schema 覆盖度、枚举白名单、数值边界；缺失项清单。
5) 限流/幂等：/orders、/claims、/verify 是否实现用户+IP 双键限流；是否支持 Idempotency-Key。
6) 日志/审计：是否有统一错误面具；事件是否包含 requestId；是否避免泄露密钥/栈。
7) 密钥存储：是否为 AES-GCM；是否存在 dek_version 与轮转脚本；是否有明文落盘/日志。
8) 证据链：是否仅 root 上链（若未实现，标记为目标状态）；是否有 batch 与重试队列。
9) 依赖安全：列出高危依赖；是否存在 dev 依赖在生产镜像。
10) 配置泄露：查找 .env、密钥、调试端点、swagger 对外暴露。

【回归核对】
- 把每条检查输出为 JSON 项：{id, severity, file, line?, finding, impact, fix, owner?}
- 额外生成一份“Go/No-Go 12 条”逐条打勾结果。
- 输出两个部分：A) 机器可读 JSON；B) 人类可读摘要（≤300 行）。
```

---

# 报告文本需要的“修订点”一览

* 把“2.1 高风险”第一条改为：**“客户端 paymentTx 伪造导致已支付标记”**（给出文件与行号）。
* 把 JP-verify 的鉴权三件套上升为 **CRITICAL**。
* 把 “EIP-712 ✅ / Merkle ✅” 改为 **Planned**，并在“6.1 紧急修复”里新增“证据批量+重试队列（链下）”，把“上链”放到 D11–D14。
* 在“5. 合规性”中加入“**密钥撤销/删除路径** 与 **数据保留期**”。
* 在“7.2 上线前必须完成”新增两条：**支付流改造**、**JP-verify 鉴权与白名单** 必须为 ✅。

---

**结论**
这版修订能把“看上去都好了”的虚假绿灯关掉，换成**可验证的硬指标**。下一步，直接按“D1–D3 熔断级修复”开干；我这边可以马上产出**“P0 修复 PR 清单（文件级粒度）”**与**“表结构/索引清单（无代码、可抄录）”**，对齐你的“一个页面一个页面理”的节奏。
