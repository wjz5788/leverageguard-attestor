稳。直接开干，给你 4 个可粘贴到 GitHub 的 Issue 模板（覆盖 D1–D3 的 P0 熔点）。每个都带验收标准与自测命令，贴进去分配给对应 Owner 就能开跑。

---

### 1) P0｜OKX 鉴权与错误码体系（拒绝伪造）

````markdown
**Title:** P0｜OKX V5 鉴权签名 + 时间戳校验 + 明确错误码

**背景**
目前 JP-verify 未正确计算 `OK-ACCESS-SIGN`，缺失/伪造密钥也可能走通，存在重大风险。

**目标**
- 计算并校验 OKX V5 签名（HMAC-SHA256 + Base64），校验 `timestamp`/`recvWindow`
- 缺失密钥 → 400；密钥错误/签名不匹配 → 401；上游超时/限流 → 429/503（可重试）
- 仅在交易所返回 2xx 且数据完备时生成 normalized

**验收标准**
- 去掉签名发起请求 → 返回 401/400（带清晰错误码与错误体）
- 使用假密钥 → 401；使用真密钥 → 200
- normalized 字段不再为硬编码常量，随 raw 变化
- 日志中不出现明文密钥

**自测（示例）**
```bash
# 缺密钥（应 400）
curl -sS -m 15 -H 'Content-Type: application/json' -d '{"exchange":"okx","ordId":"X","instId":"BTC-USDT-SWAP"}' http://<JP>:8082/api/verify | jq .

# 假密钥（应 401）
curl -sS -m 15 -H 'Content-Type: application/json' -d @/tmp/fake.json http://<JP>:8082/api/verify | jq .

# 真密钥（应 200 且 normalized 非硬编码）
curl -sS -m 15 -H 'Content-Type: application/json' -d @/tmp/real.json http://<JP>:8082/api/verify | jq .
````

**拆解任务**

* [ ] 实装签名与时间戳窗口校验
* [ ] 统一错误码与错误体（400/401/429/5xx）
* [ ] 移除 normalized 的演示常量
* [ ] 日志脱敏（禁止打印 apiKey/secret/passphrase）

**Owner:** JP Verify
**ETA:** D1

````

---

### 2) P0｜证据链改为 keccak256 + 固定序列化顺序（可复算）
```markdown
**Title:** P0｜证据链 keccak256 + 序列化顺序固定 + 测试向量

**背景**
代码与声明不一致（sha256 vs keccak256），JSON 序列化未固定顺序，root 不可复现。

**目标**
- 统一使用 keccak256；定义 evidence JSON schema（字段顺序/浮点精度/空值处理）
- 在 evidence 写入 `schemaVersion`、`hashAlgo`，并产出 ≥3 组测试向量
- 提供离线复算脚本输出 root 与 bundleHash

**验收标准**
- 用两台机器运行复算脚本，对同一 evidence 文件得到完全一致的 `root`/`bundleHash`
- 任意打乱序列化顺序 → 复算失败（能给出差异定位）

**自测（示例）**
```bash
# 复算一致
python self-test/scripts/04_hash_replay.py reports/evidence/<date>/<id>.json

# 篡改顺序（脚本提供 --shuffle 选项）→ 应报错并指示差异键路径
python self-test/scripts/04_hash_replay.py --shuffle reports/evidence/<date>/<id>.json
````

**拆解任务**

* [ ] 定义 evidence schema（顺序、精度、空值策略）
* [ ] 实装 keccak256 计算与 leaves→root 规则
* [ ] 产出 3 组测试向量（强平/部分成交/ADL）
* [ ] 完成复算脚本与差异报告

**Owner:** Crypto/Backend
**ETA:** D2

````

---

### 3) P0｜最小读写闭环：SQLite 替换内存实现
```markdown
**Title:** P0｜us-backend 切 SQLite（或 Better-SQLite3），打通 /verify → /result → /history

**背景**
内存 DB 不支持正常 SELECT/参数绑定，导致结果/历史接口实质不可用。

**目标**
- 引入 SQLite（或 Better-SQLite3）持久化
- 完成表：accounts、credentials、verifications（字段见路线图）
- 打通写入/查询/分页；JSON 列设默认值或 TEXT+schema 校验

**验收标准**
- 触发 `/verify` 返回 `sessionId`
- `/result/:sessionId` 可查到该次 normalized + evidence_root
- `/history/:accountId` 可分页返回，JSON 字段无解析错误

**自测（示例）**
```bash
# 触发验证，拿到 sessionId
sid=$(curl -sS -H 'Content-Type: application/json' -d @/tmp/real.json http://<US>/api/v1/verification/verify | jq -r .data.sessionId)

# 查结果
curl -sS http://<US>/api/v1/verification/result/$sid | jq .

# 查历史
curl -sS "http://<US>/api/v1/verification/history?accountId=<id>&page=1&pageSize=20" | jq .
````

**拆解任务**

* [ ] 接入 SQLite/Better-SQLite3 与迁移脚本
* [ ] 完成 insert/select/update 的 DAO 层 + 单元测试
* [ ] `/verify` 写入、`/result` 命中、`/history` 分页返回

**Owner:** Backend
**ETA:** D3

````

---

### 4) P0｜CORS 收紧 + 证据/日志脱敏（最小暴露面）
```markdown
**Title:** P0｜CORS 白名单 + CSRF 基线 + 证据/日志脱敏

**背景**
CORS 全开且允许凭证，证据落盘含敏感信息，风险极高。

**目标**
- CORS 限制到受控域名；禁用 allow-credentials 或加 CSRF（双重提交/nonce）
- JP 只接受 US 后端来源（IP 白名单/网关）
- 证据与日志对敏感字段脱敏或加密存储；清理历史明文

**验收标准**
- 第三方页面跨域调用被拒
- grep 明文密钥无命中
- JP 端口仅 US IP 可访问

**自测（示例）**
```bash
# 第三方站点跨域应失败（浏览器端验证）
# 服务器侧密钥排查（应无命中）
grep -R "apiKey\\|secret\\|passphrase" -n reports/ logs/ || true

# JP 侧仅 US IP 允许（示意）
nc -zvw3 <JP> 8082   # 从 US 成功，从其他主机应失败/被拒
````

**拆解任务**

* [ ] CORS 白名单与 CSRF 中间件
* [ ] JP 到 US 的网络白名单/防火墙规则
* [ ] 证据/日志脱敏策略与历史清理脚本

**Owner:** Platform/Security
**ETA:** D3

```

---

### 今日执行序列（3 小时能落地）
1. 新建以上 4 个 Issue，指派 Owner，设置里程碑「P0 熔点」。  
2. 在 JP/US 服务器同时**收紧 CORS+防火墙**；JP 仅白名单 US IP。  
3. 把《LiqPass 验证闭环自测包》加入仓库 `self-test/` 并先跑**失败用例**（缺密钥→400、假密钥→401），确认“该拒绝的都拒绝”。  

等你贴出任一 Issue 的执行进展/错误日志，我就按线索继续补齐脚本与断言，直到 P0 全绿。
```
