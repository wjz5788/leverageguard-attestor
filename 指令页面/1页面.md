 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/app.ts b/liqpass-backend/src/app.ts
index 95dc64e6225a8fefab78993780b969dc7a918567..4e2998d1c7be0a43e7972a3a75910e984ba42e80 100644
--- a/liqpass-backend/src/app.ts
+++ b/liqpass-backend/src/app.ts
@@ -1,64 +1,67 @@
 // 主应用文件
 import express from 'express';
 import cors from 'cors';
 import helmet from 'helmet';
 import morgan from 'morgan';
 import memoryDbManager from './database/memoryDb.js';
-import verificationRoutes from './routes/verification.js';
-import healthRoutes from './routes/health.js';
+import registerRoutes from './routes/index.js';
+import AuthService from './services/authService.js';
 
 // 创建Express应用
 const app = express();
 
 // 中间件配置
 app.use(helmet()); // 安全头
 app.use(cors()); // CORS支持
 app.use(express.json({ limit: '10mb' })); // JSON解析
 app.use(express.urlencoded({ extended: true })); // URL编码解析
 
 // 日志中间件
 if (process.env.NODE_ENV !== 'test') {
   app.use(morgan('combined'));
 }
 
-// 初始化内存数据库
+// 初始化依赖
 const dbManager = memoryDbManager;
+const authService = new AuthService();
 
 // 路由配置
-app.use('/api/v1/verification', verificationRoutes(dbManager));
-app.use('/api/v1/health', healthRoutes());
+registerRoutes(app, { dbManager, authService });
 
-// 注入数据库管理器到应用实例
+// 注入依赖到应用实例
 app.set('dbManager', dbManager);
+app.set('authService', authService);
 
 // 根路由
 app.get('/', (req, res) => {
   res.json({
     message: 'LiqPass API Server',
     version: '1.0.0',
     endpoints: {
       verification: '/api/v1/verification',
-      health: '/api/v1/health'
+      health: '/api/v1/health',
+      auth: '/api/v1/auth',
+      account: '/api/v1/account'
     }
   });
 });
 
 // 404处理
 app.use('*', (req, res) => {
   res.status(404).json({
     error: 'Route not found',
     path: req.originalUrl
   });
 });
 
 // 全局错误处理
 app.use((error: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
   console.error('Global error handler:', error);
-  
+
   res.status(error.status || 500).json({
     error: process.env.NODE_ENV === 'production' ? 'Internal server error' : error.message,
     ...(process.env.NODE_ENV !== 'production' && { stack: error.stack })
   });
 });
 
-export default app;
\ No newline at end of file
+export default app;
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/middleware/authMiddleware.ts b/liqpass-backend/src/middleware/authMiddleware.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a25ef02f531f179fff97da9fd41d530f7fcb1f86
--- /dev/null
+++ b/liqpass-backend/src/middleware/authMiddleware.ts
@@ -0,0 +1,55 @@
+import { NextFunction, Request, Response } from 'express';
+import AuthService, { AuthenticatedUser } from '../services/authService.js';
+
+export interface AuthenticatedRequest extends Request {
+  auth?: AuthenticatedUser;
+}
+
+export type RequireAuthMiddleware = (req: AuthenticatedRequest, res: Response, next: NextFunction) => Promise<void> | void;
+
+export function extractToken(req: Request): string | null {
+  const { authorization } = req.headers;
+
+  if (authorization) {
+    const headerValue = Array.isArray(authorization) ? authorization[0] : authorization;
+    if (headerValue.toLowerCase().startsWith('bearer ')) {
+      return headerValue.slice(7).trim();
+    }
+  }
+
+  const sessionHeader = req.headers['x-session-token'];
+  if (typeof sessionHeader === 'string') {
+    return sessionHeader;
+  }
+
+  return null;
+}
+
+export function createAuthMiddleware(authService: AuthService): RequireAuthMiddleware {
+  return async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
+    const token = extractToken(req);
+
+    if (!token) {
+      return res.status(401).json({
+        error: 'Unauthorized',
+        message: 'A valid bearer token is required.'
+      });
+    }
+
+    const session = await authService.validateSession(token);
+
+    if (!session) {
+      return res.status(401).json({
+        error: 'Unauthorized',
+        message: 'Session is invalid or has expired.'
+      });
+    }
+
+    req.auth = {
+      ...session,
+      token
+    };
+
+    return next();
+  };
+}
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/routes/account.ts b/liqpass-backend/src/routes/account.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1595fb610e84a2922a1c8c5b1007487438809cb5
--- /dev/null
+++ b/liqpass-backend/src/routes/account.ts
@@ -0,0 +1,69 @@
+import express from 'express';
+import { z } from 'zod';
+import AuthService from '../services/authService.js';
+import { AuthenticatedRequest, RequireAuthMiddleware } from '../middleware/authMiddleware.js';
+
+const updateProfileSchema = z
+  .object({
+    displayName: z.string().min(1).max(120).optional(),
+    avatarUrl: z.string().url().nullable().optional(),
+    language: z.string().min(2).max(10).optional(),
+    timezone: z.string().min(2).max(40).optional(),
+    metadata: z.record(z.any()).optional()
+  })
+  .refine(data => Object.keys(data).length > 0, {
+    message: 'At least one profile field must be provided.'
+  });
+
+export default function accountRoutes(authService: AuthService, requireAuth: RequireAuthMiddleware) {
+  const router = express.Router();
+
+  router.get('/profile', requireAuth, async (req: AuthenticatedRequest, res) => {
+    const userId = req.auth?.userId;
+
+    if (!userId) {
+      return res.status(401).json({
+        error: 'UNAUTHORIZED',
+        message: 'Active session is required.'
+      });
+    }
+
+    const profile = await authService.getProfile(userId);
+
+    if (!profile) {
+      return res.status(404).json({
+        error: 'PROFILE_NOT_FOUND',
+        message: 'Profile could not be located for the active session.'
+      });
+    }
+
+    return res.json({ profile });
+  });
+
+  router.patch('/profile', requireAuth, async (req: AuthenticatedRequest, res) => {
+    const userId = req.auth?.userId;
+
+    if (!userId) {
+      return res.status(401).json({
+        error: 'UNAUTHORIZED',
+        message: 'Active session is required.'
+      });
+    }
+
+    const parseResult = updateProfileSchema.safeParse(req.body);
+
+    if (!parseResult.success) {
+      return res.status(400).json({
+        error: 'INVALID_UPDATE',
+        message: 'Profile update payload is invalid.',
+        issues: parseResult.error.issues
+      });
+    }
+
+    const updated = await authService.updateProfile(userId, parseResult.data);
+
+    return res.json({ profile: updated });
+  });
+
+  return router;
+}
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/routes/auth.ts b/liqpass-backend/src/routes/auth.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d4c868d2e464b0cee46f0505bdd5965f5d94fd89
--- /dev/null
+++ b/liqpass-backend/src/routes/auth.ts
@@ -0,0 +1,85 @@
+import express from 'express';
+import { z } from 'zod';
+import AuthService, { AuthError, LoginPayload, LoginResult } from '../services/authService.js';
+import { AuthenticatedRequest, RequireAuthMiddleware } from '../middleware/authMiddleware.js';
+
+const emailLoginSchema = z.object({
+  type: z.literal('email'),
+  email: z.string().email(),
+  password: z.string().min(6)
+});
+
+const walletLoginSchema = z.object({
+  type: z.literal('wallet'),
+  walletAddress: z.string().min(1),
+  signature: z.string().min(1),
+  nonce: z.string().min(1)
+});
+
+const loginSchema = z.union([emailLoginSchema, walletLoginSchema]);
+
+function formatLoginResult(result: LoginResult) {
+  return {
+    token: result.token,
+    session: {
+      id: result.session.sessionId,
+      issuedAt: result.session.issuedAt,
+      expiresAt: result.session.expiresAt,
+      loginType: result.session.loginType
+    },
+    profile: result.profile
+  };
+}
+
+export default function authRoutes(authService: AuthService, requireAuth: RequireAuthMiddleware) {
+  const router = express.Router();
+
+  router.post('/login', async (req, res) => {
+    const parseResult = loginSchema.safeParse(req.body);
+
+    if (!parseResult.success) {
+      return res.status(400).json({
+        error: 'INVALID_REQUEST',
+        message: 'Login payload is invalid.',
+        issues: parseResult.error.issues
+      });
+    }
+
+    try {
+      const payload = parseResult.data as LoginPayload;
+      const result = await authService.verifyLogin(payload);
+
+      return res.status(200).json(formatLoginResult(result));
+    } catch (error) {
+      if (error instanceof AuthError) {
+        return res.status(401).json({
+          error: error.code,
+          message: error.message
+        });
+      }
+
+      console.error('Login error:', error);
+      return res.status(500).json({
+        error: 'LOGIN_FAILED',
+        message: 'Unable to complete login at this time.'
+      });
+    }
+  });
+
+  router.post('/logout', requireAuth, async (req: AuthenticatedRequest, res) => {
+    const token = req.auth?.token;
+
+    if (!token) {
+      return res.status(400).json({
+        error: 'INVALID_SESSION',
+        message: 'No active session token found.'
+      });
+    }
+
+    await authService.logout(token);
+
+    return res.status(204).send();
+  });
+
+  return router;
+}
 
EOF
) (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/routes/index.ts b/liqpass-backend/src/routes/index.ts
new file mode 100644
index 0000000000000000000000000000000000000000..68006f67a5b66b3220d737e3238fa207588c09a8
--- /dev/null
+++ b/liqpass-backend/src/routes/index.ts
@@ -0,0 +1,23 @@
+import type express from 'express';
+import memoryDbManager from '../database/memoryDb.js';
+import AuthService from '../services/authService.js';
+import { createAuthMiddleware } from '../middleware/authMiddleware.js';
+import verificationRoutes from './verification.js';
+import healthRoutes from './health.js';
+import authRoutes from './auth.js';
+import accountRoutes from './account.js';
+
+export interface RouteDependencies {
+  dbManager: typeof memoryDbManager;
+  authService: AuthService;
+}
+
+export default function registerRoutes(app: express.Application, deps: RouteDependencies) {
+  const { dbManager, authService } = deps;
+  const requireAuth = createAuthMiddleware(authService);
+
+  app.use('/api/v1/health', healthRoutes());
+  app.use('/api/v1/verification', verificationRoutes(dbManager));
+  app.use('/api/v1/auth', authRoutes(authService, requireAuth));
+  app.use('/api/v1/account', accountRoutes(authService, requireAuth));
+}
 
EOF
)
 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/liqpass-backend/src/services/authService.ts b/liqpass-backend/src/services/authService.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d7e3acb3d5fc8511cd32389a17ac9347eb3183dc
--- /dev/null
+++ b/liqpass-backend/src/services/authService.ts
@@ -0,0 +1,243 @@
+import jwt, { JwtPayload } from 'jsonwebtoken';
+import { v4 as uuid } from 'uuid';
+
+export type LoginType = 'email' | 'wallet';
+
+export interface EmailLoginPayload {
+  type: 'email';
+  email: string;
+  password: string;
+}
+
+export interface WalletLoginPayload {
+  type: 'wallet';
+  walletAddress: string;
+  signature: string;
+  nonce: string;
+}
+
+export type LoginPayload = EmailLoginPayload | WalletLoginPayload;
+
+export interface UserProfile {
+  id: string;
+  email?: string;
+  walletAddress?: string;
+  displayName?: string;
+  avatarUrl?: string | null;
+  language?: string | null;
+  timezone?: string | null;
+  metadata?: Record<string, unknown>;
+  lastLoginAt?: string | null;
+}
+
+export interface AuthSession {
+  token: string;
+  sessionId: string;
+  userId: string;
+  issuedAt: string;
+  expiresAt: string;
+  loginType: LoginType;
+}
+
+export interface AuthenticatedUser extends AuthSession {
+  profile: UserProfile;
+}
+
+export interface LoginResult {
+  token: string;
+  session: AuthSession;
+  profile: UserProfile;
+}
+
+export interface AuthServiceOptions {
+  jwtSecret?: string;
+  sessionDurationMs?: number;
+}
+
+export class AuthError extends Error {
+  constructor(public code: string, message: string) {
+    super(message);
+    this.name = 'AuthError';
+  }
+}
+
+const DEFAULT_SESSION_DURATION_MS = 60 * 60 * 1000; // 1 hour
+
+export default class AuthService {
+  private readonly jwtSecret: string;
+  private readonly sessionDurationMs: number;
+  private sessions = new Map<string, AuthSession>();
+  private profiles = new Map<string, UserProfile>();
+
+  constructor(options: AuthServiceOptions = {}) {
+    this.jwtSecret = options.jwtSecret ?? process.env.JWT_SECRET ?? 'dev-secret';
+    this.sessionDurationMs = options.sessionDurationMs ?? DEFAULT_SESSION_DURATION_MS;
+  }
+
+  async verifyLogin(payload: LoginPayload): Promise<LoginResult> {
+    if (payload.type === 'email') {
+      this.assertEmailPayload(payload);
+    } else {
+      this.assertWalletPayload(payload);
+    }
+
+    const userId = this.resolveUserId(payload);
+    const profile = this.ensureProfile(userId, payload);
+    const session = this.createSession(userId, payload.type);
+
+    const nowIso = new Date().toISOString();
+    const persistedProfile: UserProfile = {
+      ...profile,
+      id: userId,
+      lastLoginAt: nowIso
+    };
+
+    this.sessions.set(session.token, session);
+    this.profiles.set(userId, persistedProfile);
+
+    return {
+      token: session.token,
+      session,
+      profile: persistedProfile
+    };
+  }
+
+  async logout(token: string): Promise<boolean> {
+    return this.sessions.delete(token);
+  }
+
+  async validateSession(token: string): Promise<AuthenticatedUser | null> {
+    try {
+      const decoded = jwt.verify(token, this.jwtSecret) as JwtPayload & { type?: LoginType };
+      const session = this.sessions.get(token);
+      if (!session || !decoded?.sub || session.userId !== decoded.sub) {
+        return null;
+      }
+
+      if (new Date(session.expiresAt).getTime() <= Date.now()) {
+        this.sessions.delete(token);
+        return null;
+      }
+
+      const profile = this.profiles.get(session.userId) ?? this.createDefaultProfile(session.userId, decoded.type);
+
+      return {
+        ...session,
+        profile
+      };
+    } catch (error) {
+      return null;
+    }
+  }
+
+  async getProfile(userId: string): Promise<UserProfile | null> {
+    return this.profiles.get(userId) ?? null;
+  }
+
+  async updateProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {
+    const existing = this.profiles.get(userId) ?? this.createDefaultProfile(userId);
+    const merged: UserProfile = {
+      ...existing,
+      ...updates,
+      id: userId
+    };
+
+    this.profiles.set(userId, merged);
+    return merged;
+  }
+
+  private assertEmailPayload(payload: EmailLoginPayload) {
+    if (!payload.email || !payload.password) {
+      throw new AuthError('INVALID_CREDENTIALS', 'Email and password are required.');
+    }
+
+    if (!payload.email.includes('@')) {
+      throw new AuthError('INVALID_EMAIL', 'A valid email address is required.');
+    }
+
+    if (payload.password.length < 6) {
+      throw new AuthError('INVALID_CREDENTIALS', 'Password must be at least 6 characters long.');
+    }
+  }
+
+  private assertWalletPayload(payload: WalletLoginPayload) {
+    if (!payload.walletAddress || !payload.signature || !payload.nonce) {
+      throw new AuthError('INVALID_CHALLENGE', 'Wallet address, signature, and nonce are required.');
+    }
+  }
+
+  private resolveUserId(payload: LoginPayload): string {
+    if (payload.type === 'email') {
+      return `email:${payload.email.toLowerCase()}`;
+    }
+
+    return `wallet:${payload.walletAddress.toLowerCase()}`;
+  }
+
+  private ensureProfile(userId: string, payload: LoginPayload): UserProfile {
+    const existing = this.profiles.get(userId);
+    if (existing) {
+      return existing;
+    }
+
+    const profile = this.createDefaultProfile(userId, payload.type);
+
+    if (payload.type === 'email') {
+      profile.email = payload.email.toLowerCase();
+      profile.displayName = profile.displayName ?? payload.email.split('@')[0];
+    } else {
+      profile.walletAddress = payload.walletAddress;
+      profile.displayName = profile.displayName ?? this.maskWallet(payload.walletAddress);
+    }
+
+    this.profiles.set(userId, profile);
+    return profile;
+  }
+
+  private createDefaultProfile(userId: string, loginType?: LoginType): UserProfile {
+    return {
+      id: userId,
+      displayName: loginType === 'wallet' ? this.maskWallet(userId.replace('wallet:', '')) : undefined,
+      avatarUrl: null,
+      language: 'en',
+      timezone: 'UTC',
+      metadata: {}
+    };
+  }
+
+  private maskWallet(address: string): string {
+    if (!address) {
+      return 'Wallet User';
+    }
+
+    const trimmed = address.trim();
+    if (trimmed.length <= 10) {
+      return trimmed;
+    }
+
+    return `${trimmed.slice(0, 6)}...${trimmed.slice(-4)}`;
+  }
+
+  private createSession(userId: string, loginType: LoginType): AuthSession {
+    const issuedAt = new Date();
+    const expiresAt = new Date(issuedAt.getTime() + this.sessionDurationMs);
+    const jwtPayload = {
+      sub: userId,
+      type: loginType,
+      jti: uuid()
+    };
+
+    const token = jwt.sign(jwtPayload, this.jwtSecret, {
+      expiresIn: Math.floor(this.sessionDurationMs / 1000)
+    });
+
+    return {
+      token,
+      sessionId: uuid(),
+      userId,
+      issuedAt: issuedAt.toISOString(),
+      expiresAt: expiresAt.toISOString(),
+      loginType
+    };
+  }
+}
 
EOF
)