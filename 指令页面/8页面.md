可以，一把梭，三件事一次性补齐：**触发器+种子数据**、**memoryDb.ts 与迁移对齐**、**DAO/Repository + 最小 CRUD 路由**。下面给出“可直接落盘”的方案与精炼代码片段。按顺序执行即可把最小读写闭环跑起来（本地内存与 SQLite 行为一致）。

---

# 1) 表结构（最小闭环必需）

面向“保存交易所 API 账户 → 发起一次验证请求 → 落库结果/Evidence → 查询结果”的最小闭环，只要这 4 张表：

* `api_accounts`：保存用户在 OKX/币安的只读凭据（建议加密存储，接口不回显密钥）。
* `verify_requests`：一次验证的输入参数与状态机（pending/success/failed）。
* `verify_results`：验证标准化结果（normalized/meta/perf），与原始回包（raw）。
* `evidence_blobs`：与本次验证关联的证据快照（JSON blob）与 Merkle 信息。

> 时间字段统一使用 **UTC ISO8601** 文本（`YYYY-MM-DDTHH:MM:SS.mmmZ`）。
> `created_at`/`updated_at`：`DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))`，再用触发器维护 `updated_at`。

### 1.1 迁移 `001_schema.sql`（示意）

```sql
-- api_accounts：每家交易所有多条，密钥加密后存储（此处先占位）
CREATE TABLE IF NOT EXISTS api_accounts (
  id              INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id         TEXT NOT NULL,
  exchange        TEXT NOT NULL CHECK (exchange IN ('okx','binance')),
  label           TEXT NOT NULL,                                -- 用户自定义别名
  api_key         TEXT NOT NULL,
  secret_enc      TEXT NOT NULL,                                -- 密钥密文（或KMS引用）
  passphrase_enc  TEXT,                                         -- OKX专有（密文）
  status          TEXT NOT NULL DEFAULT 'ready',                -- ready/disabled/verified/failed
  last_verified_at TEXT,                                        -- 上次验证时间
  created_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now')),
  updated_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now')),
  UNIQUE(user_id, exchange, label)
);

-- verify_requests：一次校验调用及其状态
CREATE TABLE IF NOT EXISTS verify_requests (
  id              INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id         TEXT NOT NULL,
  account_id      INTEGER NOT NULL REFERENCES api_accounts(id) ON DELETE CASCADE,
  exchange        TEXT NOT NULL CHECK (exchange IN ('okx','binance')),
  ord_id          TEXT NOT NULL,
  inst_id         TEXT NOT NULL,
  live            INTEGER NOT NULL DEFAULT 1,                   -- boolean: 0/1
  fresh           INTEGER NOT NULL DEFAULT 1,
  no_cache        INTEGER NOT NULL DEFAULT 0,
  status          TEXT NOT NULL DEFAULT 'pending',              -- pending/success/failed
  error_msg       TEXT,
  created_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now')),
  updated_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
);

-- verify_results：结构化结果 + 原始回包
CREATE TABLE IF NOT EXISTS verify_results (
  id              INTEGER PRIMARY KEY AUTOINCREMENT,
  request_id      INTEGER NOT NULL UNIQUE REFERENCES verify_requests(id) ON DELETE CASCADE,
  normalized_json TEXT NOT NULL,                                 -- 统一字段结构
  raw_json        TEXT NOT NULL,                                 -- 交易所原样数据
  meta_json       TEXT NOT NULL,                                 -- 调用元信息：耗时、命中缓存、对端IP等
  created_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now')),
  updated_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
);

-- evidence_blobs：与一次验证绑定的证据快照（离线可审计）
CREATE TABLE IF NOT EXISTS evidence_blobs (
  id              INTEGER PRIMARY KEY AUTOINCREMENT,
  request_id      INTEGER NOT NULL UNIQUE REFERENCES verify_requests(id) ON DELETE CASCADE,
  root            TEXT NOT NULL,                                 -- Merkle root（hex）
  parent_root     TEXT,                                          -- 父根（若做链式审计）
  leaves_count    INTEGER NOT NULL,
  evidence_json   TEXT NOT NULL,                                 -- 完整证据包（脱敏）
  created_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now')),
  updated_at      TEXT NOT NULL DEFAULT (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
);
```

### 1.2 迁移 `002_indexes.sql`（示意）

```sql
CREATE INDEX IF NOT EXISTS idx_api_accounts_user_exchange ON api_accounts(user_id, exchange);
CREATE INDEX IF NOT EXISTS idx_verify_requests_user_status ON verify_requests(user_id, status);
CREATE INDEX IF NOT EXISTS idx_verify_requests_ord ON verify_requests(exchange, ord_id, inst_id);
```

### 1.3 迁移 `003_triggers.sql`（统一维护 updated_at）

```sql
-- 通用触发器模板：每表一个 AFTER UPDATE
CREATE TRIGGER IF NOT EXISTS trg_api_accounts_updated
AFTER UPDATE ON api_accounts
FOR EACH ROW BEGIN
  UPDATE api_accounts
  SET updated_at = (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
  WHERE id = NEW.id;
END;

CREATE TRIGGER IF NOT EXISTS trg_verify_requests_updated
AFTER UPDATE ON verify_requests
FOR EACH ROW BEGIN
  UPDATE verify_requests
  SET updated_at = (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
  WHERE id = NEW.id;
END;

CREATE TRIGGER IF NOT EXISTS trg_verify_results_updated
AFTER UPDATE ON verify_results
FOR EACH ROW BEGIN
  UPDATE verify_results
  SET updated_at = (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
  WHERE id = NEW.id;
END;

CREATE TRIGGER IF NOT EXISTS trg_evidence_blobs_updated
AFTER UPDATE ON evidence_blobs
FOR EACH ROW BEGIN
  UPDATE evidence_blobs
  SET updated_at = (strftime('%Y-%m-%dT%H:%M:%fZ','now'))
  WHERE id = NEW.id;
END;
```

---

# 2) 种子数据（`seeds/seed_dev.sql`）

> 仅开发环境使用；密钥字段放**假数据**或“DEV_ENC(…)”占位，避免误用真实密钥。

```sql
-- 统一用户
INSERT INTO api_accounts (user_id, exchange, label, api_key, secret_enc, passphrase_enc, status, last_verified_at)
VALUES
('user_demo', 'okx',    'OKX-只读-1', 'OKX_KEY_xxx', 'DEV_ENC(OKX_SECRET)', 'DEV_ENC(OKX_PASSPHRASE)', 'ready', NULL),
('user_demo', 'binance','BIN-只读-1', 'BIN_KEY_xxx', 'DEV_ENC(BIN_SECRET)', NULL,                       'ready', NULL);

-- 模拟一次“待验证”请求
INSERT INTO verify_requests (user_id, account_id, exchange, ord_id, inst_id, live, fresh, no_cache, status)
VALUES ('user_demo', 1, 'okx', '2940071038556348417', 'BTC-USDT-SWAP', 1, 1, 0, 'pending');

-- 一条已完成请求 + 结果 + 证据（示例）
INSERT INTO verify_requests (user_id, account_id, exchange, ord_id, inst_id, status)
VALUES ('user_demo', 1, 'okx', 'SIM_DONE_001', 'BTC-USDT-SWAP', 'success');

INSERT INTO verify_results (request_id, normalized_json, raw_json, meta_json)
VALUES (
  (SELECT id FROM verify_requests WHERE ord_id='SIM_DONE_001'),
  json('{"orderId":"SIM_DONE_001","side":"buy","size":0.64,"price":35000,"filled":0.64,"status":"filled"}'),
  json('{"code":"0","data":[{"ordId":"SIM_DONE_001","accFillSz":"0.64","fillPx":"35000"}]}'),
  json('{"durationMs":182,"jpHost":"103.76.85.191:8082","cache":false}')
);

INSERT INTO evidence_blobs (request_id, root, parent_root, leaves_count, evidence_json)
VALUES (
  (SELECT id FROM verify_requests WHERE ord_id='SIM_DONE_001'),
  '0xabc123...deadbeef', NULL, 5,
  json('{"leaves":["0x..1","0x..2","0x..3","0x..4","0x..5"],"algo":"keccak256"}')
);
```

---

# 3) `memoryDb.ts` 扩展（统一加载 001/002/003）

把“内存模式”也用 **better-sqlite3** 的 `:memory:` 实例，执行同一套迁移，从而确保与文件 SQLite 一致。

```ts
// us-backend/src/db/memoryDb.ts
import Database from 'better-sqlite3';
import fs from 'node:fs';
import path from 'node:path';

type Mode = 'memory' | 'file';

export function initDb(mode: Mode, filePath = 'data/app.db') {
  const db = new Database(mode === 'memory' ? ':memory:' : filePath);
  db.pragma('journal_mode = WAL');      // 提升并发与稳定性（文件模式）
  db.pragma("foreign_keys = ON");

  runMigrations(db, path.resolve(process.cwd(), 'migrations'));
  // 可选：加载开发种子
  if (process.env.LOAD_SEEDS === '1') {
    const seed = path.resolve(process.cwd(), 'seeds', 'seed_dev.sql');
    if (fs.existsSync(seed)) db.exec(fs.readFileSync(seed, 'utf8'));
  }
  return db;
}

function runMigrations(db: Database.Database, dir: string) {
  if (!fs.existsSync(dir)) return;
  const files = fs.readdirSync(dir)
    .filter(f => /^\d{3}_.+\.sql$/.test(f))
    .sort(); // 001_->002_->003_

  for (const f of files) {
    const sql = fs.readFileSync(path.join(dir, f), 'utf8');
    db.exec(sql);
  }
}
```

> 这样 `memory` 与 `file` 都会执行 `001/002/003`。本地跑内存模式时：`LOAD_SEEDS=1` 直接灌入示例数据。

---

# 4) Repository/DAO（精简但可用）

以 `better-sqlite3` 同步 API 写法，保持后端路由处理简洁可控。

```ts
// us-backend/src/repo/AccountsRepo.ts
import type Database from 'better-sqlite3';

export class AccountsRepo {
  constructor(private db: Database.Database) {}

  create(p: {
    user_id: string; exchange: 'okx'|'binance'; label: string;
    api_key: string; secret_enc: string; passphrase_enc?: string|null;
  }) {
    const stmt = this.db.prepare(`
      INSERT INTO api_accounts (user_id,exchange,label,api_key,secret_enc,passphrase_enc)
      VALUES (@user_id,@exchange,@label,@api_key,@secret_enc,@passphrase_enc)
    `);
    const info = stmt.run({ ...p, passphrase_enc: p.passphrase_enc ?? null });
    return this.findById(Number(info.lastInsertRowid));
  }

  findById(id: number) {
    return this.db.prepare(`SELECT * FROM api_accounts WHERE id=?`).get(id);
  }

  listByUser(user_id: string) {
    return this.db.prepare(`SELECT id,user_id,exchange,label,status,last_verified_at,created_at,updated_at FROM api_accounts WHERE user_id=?`).all(user_id);
  }

  updateStatus(id: number, status: string, last_verified_at?: string) {
    return this.db.prepare(
      `UPDATE api_accounts SET status=@status, last_verified_at=@last_verified_at WHERE id=@id`
    ).run({ id, status, last_verified_at: last_verified_at ?? null });
  }

  delete(id: number) {
    return this.db.prepare(`DELETE FROM api_accounts WHERE id=?`).run(id);
  }
}
```

```ts
// us-backend/src/repo/VerifyRepo.ts
import type Database from 'better-sqlite3';

export class VerifyRepo {
  constructor(private db: Database.Database) {}

  createRequest(p: {
    user_id: string; account_id: number; exchange: 'okx'|'binance';
    ord_id: string; inst_id: string; live?: boolean; fresh?: boolean; no_cache?: boolean;
  }) {
    const stmt = this.db.prepare(`
      INSERT INTO verify_requests (user_id,account_id,exchange,ord_id,inst_id,live,fresh,no_cache,status)
      VALUES (@user_id,@account_id,@exchange,@ord_id,@inst_id,@live,@fresh,@no_cache,'pending')
    `);
    const info = stmt.run({
      live: p.live ?? 1, fresh: p.fresh ?? 1, no_cache: p.no_cache ?? 0, ...p
    });
    return this.getRequest(Number(info.lastInsertRowid));
  }

  setResult(request_id: number, status: 'success'|'failed', result?: {
    normalized_json: string; raw_json: string; meta_json: string;
  }, evidence?: { root: string; parent_root?: string|null; leaves_count: number; evidence_json: string; }, error_msg?: string) {
    const tx = this.db.transaction(() => {
      this.db.prepare(`UPDATE verify_requests SET status=@status, error_msg=@error_msg WHERE id=@id`)
        .run({ id: request_id, status, error_msg: error_msg ?? null });
      if (status === 'success' && result) {
        this.db.prepare(`
          INSERT OR REPLACE INTO verify_results (request_id,normalized_json,raw_json,meta_json)
          VALUES (@request_id,@normalized_json,@raw_json,@meta_json)
        `).run({ request_id, ...result });
        if (evidence) {
          this.db.prepare(`
            INSERT OR REPLACE INTO evidence_blobs (request_id,root,parent_root,leaves_count,evidence_json)
            VALUES (@request_id,@root,@parent_root,@leaves_count,@evidence_json)
          `).run({ request_id, parent_root: evidence.parent_root ?? null, ...evidence });
        }
      }
    });
    tx();
  }

  getRequest(id: number) {
    return this.db.prepare(`SELECT * FROM verify_requests WHERE id=?`).get(id);
  }

  getFull(id: number) {
    return this.db.prepare(`
      SELECT vrq.*, vrs.normalized_json, vrs.raw_json, vrs.meta_json, ev.root, ev.parent_root, ev.leaves_count, ev.evidence_json
      FROM verify_requests vrq
      LEFT JOIN verify_results vrs ON vrs.request_id = vrq.id
      LEFT JOIN evidence_blobs ev ON ev.request_id = vrq.id
      WHERE vrq.id=?
    `).get(id);
  }

  listByUser(user_id: string, limit = 50) {
    return this.db.prepare(`
      SELECT id, exchange, ord_id, inst_id, status, created_at, updated_at
      FROM verify_requests WHERE user_id=?
      ORDER BY id DESC LIMIT ?
    `).all(user_id, limit);
  }
}
```

---

# 5) 最小 CRUD 路由（Express）

> 这些路由只做“读写打通”；真正的对接 JP 验证接口（[http://JP:8082/api/verify）可在](http://JP:8082/api/verify）可在) `/verify-requests` 的 `POST` 里同步或异步触发并落库结果。

```ts
// us-backend/src/server.ts
import express from 'express';
import bodyParser from 'body-parser';
import Database from 'better-sqlite3';
import { initDb } from './db/memoryDb';
import { AccountsRepo } from './repo/AccountsRepo';
import { VerifyRepo } from './repo/VerifyRepo';
import fetch from 'node-fetch';

const app = express();
app.use(bodyParser.json());

const db = initDb(process.env.DB_MODE === 'file' ? 'file' : 'memory');
const accounts = new AccountsRepo(db);
const verify = new VerifyRepo(db);

// --- Accounts ---
app.post('/api/accounts', (req, res) => {
  // 注：真实落地请在此加密 secret/passphrase
  const { user_id, exchange, label, api_key, secret_enc, passphrase_enc } = req.body;
  const row = accounts.create({ user_id, exchange, label, api_key, secret_enc, passphrase_enc });
  res.json({ success: true, data: { ...row, api_key: '***', secret_enc: '***', passphrase_enc: row.passphrase_enc ? '***' : null }});
});

app.get('/api/accounts', (req, res) => {
  const { user_id } = req.query as any;
  res.json({ success: true, data: accounts.listByUser(user_id) });
});

// --- Verify Requests: 创建并调用 JP ---
app.post('/api/verify-requests', async (req, res) => {
  try {
    const { user_id, account_id, exchange, ord_id, inst_id, live = true, fresh = true, no_cache = false } = req.body;

    const r = verify.createRequest({ user_id, account_id, exchange, ord_id, inst_id, live, fresh, no_cache });

    // 直连 JP 验证（同步示例；也可丢到队列异步）
    const jpBase = process.env.JP_VERIFY_BASE || 'http://103.76.85.191:8082';
    const jpResp = await fetch(`${jpBase}/api/verify`, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        exchange, ordId: ord_id, instId: inst_id, live, fresh, noCache: no_cache,
        // 此处仅示例；真实应从 accounts 取出并解密
        apiKey: 'REDACTED', secretKey: 'REDACTED', passphrase: 'REDACTED'
      })
    });

    if (!jpResp.ok) {
      const msg = `JP ${jpResp.status}`;
      verify.setResult(r.id, 'failed', undefined, undefined, msg);
      return res.status(502).json({ success: false, error: msg, request_id: r.id });
    }

    const jpJson = await jpResp.json();

    // 期望 JP 返回：normalized/raw/evidence/perf/meta
    const normalized = JSON.stringify(jpJson.normalized ?? {});
    const raw        = JSON.stringify(jpJson.raw ?? jpJson);
    const meta       = JSON.stringify(jpJson.meta ?? { durationMs: jpJson.perf?.durationMs });

    const ev = jpJson.evidence ? {
      root: jpJson.evidence.root,
      parent_root: jpJson.evidence.parentRoot ?? null,
      leaves_count: jpJson.evidence.leaves?.length ?? 0,
      evidence_json: JSON.stringify(jpJson.evidence)
    } : undefined;

    verify.setResult(r.id, 'success', {
      normalized_json: normalized,
      raw_json: raw,
      meta_json: meta
    }, ev);

    res.json({ success: true, data: verify.getFull(r.id) });

  } catch (e:any) {
    verify.setResult((req as any)._reqId ?? 0, 'failed', undefined, undefined, e?.message ?? 'error');
    res.status(500).json({ success:false, error: e?.message ?? 'unknown' });
  }
});

app.get('/api/verify-requests', (req, res) => {
  const { user_id } = req.query as any;
  res.json({ success: true, data: verify.listByUser(user_id ?? 'user_demo') });
});

app.get('/api/verify-requests/:id', (req, res) => {
  const row = verify.getFull(Number(req.params.id));
  if (!row) return res.status(404).json({ success:false, error:'not found' });
  res.json({ success:true, data: row });
});

app.listen(process.env.PORT ?? 8080, () => {
  // eslint-disable-next-line no-console
  console.log(`us-backend up on :${process.env.PORT ?? 8080}`);
});
```

---

# 6) 打通方式（最短路径）

1. 建目录：`migrations/{001,002,003}.sql`、`seeds/seed_dev.sql`，落上文 SQL。
2. 设置环境：

   * 本地内存模式：`DB_MODE=memory LOAD_SEEDS=1`
   * 文件模式：`DB_MODE=file`（创建 `data/app.db`）
3. 启动后端：`pnpm dev` 或 `node dist/server.js`
4. 跑通闭环（示例）：

   * `POST /api/accounts` 保存一条 OKX 凭据（密钥用占位）
   * `POST /api/verify-requests` 触发一次 JP 验证（将 `JP_VERIFY_BASE` 指向你的 8082）
   * `GET /api/verify-requests/:id` 查完整结果（含 normalized/raw/evidence）

---

# 7) 设计要点与风险位

* **安全**：密钥必须加密存储（本地先占位，切换到 KMS/封装 AES 后只改 DAO，不动 API）。
* **一致性**：用同一套迁移跑 `:memory:` 与文件 SQLite，避免“内存模式缺字段/缺索引”。
* **时间戳**：默认值 + `AFTER UPDATE` 触发器，禁止业务层手填 `updated_at`。
* **证据**：`evidence_blobs` 存“脱敏 JSON + Root”，链上仅 Root；后续可加 `attestation_tx` 字段。
* **扩展**：将来需要多交易所/多账户，只扩 `api_accounts` 与 `verify_requests` 的索引即可。

---

以上即是你要的三件事的“即插即用版”。落盘后，你的页面只需调用 `/api/accounts` + `/api/verify-requests` + `/api/verify-requests/:id`，就能在本地稳定完成“写入→调 JP 验证→落库结果/证据→读取”的最小闭环。接下来可以把 `JP_VERIFY_BASE` 从 `127.0.0.1:8082` 切为你的日本 IP，无需改接口契约。
