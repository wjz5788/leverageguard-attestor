zms，结论先说：**现在是 NO-GO**。你列出的 P0 两条足以被黑到出血。下面给你一套**可直接执行的修复与验收清单**（不贴代码），按顺序做，做到哪一条就能把哪一类风险关掉。照做，48 小时内能把红线清零并恢复可控的“购买→链上→赔付”闭环。

# 一、上线红线：两条 P0 的落地修复与验收

## P0-01：订单创建不可再“信任 paymentTx”

**目标**：只有“已在链上确认的支付/金库入账”才能把订单置为 `paid`。
**设计改动**

* **状态机**：`pending → awaiting_payment → paid → claimable`
  任何请求体里的 `paymentTx` 一律忽略，**只接受后端“验证过的支付证明（PaymentProof）”**来触发 `paid`。
* **数据面**

  * 新表 `payment_proofs`：`id, chainId, txHash, token, amount, payer, recipient, logIndex, confirmedAt, status(confirmed|failed), meta(json)；(chainId, txHash) 唯一`
  * 订单表加 `payment_proof_id`（外键）与 `paidAt`
* **校验来源（择一或并行）**

  1. **合约事件监听**：监听 `Permit2/Transfer` 或你的收款合约 `Paid(orderId, amount, token, payer)` 事件；
  2. **金库 Webhook**：金库/托管钱包的入账回调（附签名）；
  3. **被动拉取**：补偿任务轮询 txHash 并比对 `to/token/amount`。
* **接口行为**

  * `POST /orders` 只创建 `pending` 订单并返回 `awaiting_payment` 与**支付指引**（收款地址、金额、有效期、链）。
  * **新接口** `POST /orders/:id/attach-proof`（内部调用）：由事件监听/回调**写入 PaymentProof**并原子地把订单置为 `paid`。
* **回滚/幂等**

  * 任何校验失败 → 订单回到 `awaiting_payment`，写审计原因。
  * 幂等键：`(orderId, payment_proof_id)`；重复附加直接 200，**禁止重复置 `paid`**。

**验收（必须全部通过）**

1. **正例**：在 Base Sepolia 上真实打款 → 事件被抓 → 订单由 `awaiting_payment` 自动变 `paid`，`payment_proof_id` 关联正确。
2. **反例**：`POST /orders` 携带任意 `paymentTx="abc"` → 仍为 `awaiting_payment`。
3. **对账**：`PaymentProof.amount/token/recipient` 与报价 `quote` 完全一致，不一致则拒绝并记录审计。
4. **重放**：同一 `txHash` 重放 Attach 只更新一次，不产生第二个 `paid` 事件。
5. **混沌/延迟**：事件监听挂起 10 分钟内由补偿任务捞回并完成置 `paid`。

---

## P0-02：JP 验证不可再“硬编码 liquidated=True”

**目标**：在**实现真实解析前**，**一律阻断**到 us-backend 的赔付判定；实现后以**可审计函数**输出。
**上线前立刻做**

* **熔断返回**：`/api/verify` 返回明确错误码 `verify_unavailable`（HTTP 503），**任何硬编码字段全部取消**。
* **来源白名单**：仅允许 US 后端固定出口 IP 调用（UFW / Nginx allowlist）。
* **请求签名**：要求 `x-sign:<HMAC_SHA256(body,t=timestamp,nonce)>`，容忍时差 ≤ 300s，`nonce` 落库 10 分钟窗口防重放。
* **速率限制**：同 IP / 同 account 滑动窗口限流（例如 60 rpm）。

**实现期（24h 内）**

* **真实解析**：把 OKX 响应 → 归一结构 `normalized`，其中 `position.liquidated` 由**规则函数**计算：
  `forced_liq_event OR ADL_event OR (posSz->0 且 closeReason in {FORCE,ADL})`，并附 `evidence.leaves`（关键字段对）。
* **可审计函数**：`compute_liquidation(normalized_raw)->{liquidated:boolean, reason, fields_used[]}`，每次调用**记录输入/输出哈希**。
* **证据落盘**：保留 `raw` 的**脱敏版**（订单号、uid 掩码），并写入 `evidence.root` 与**父 root**（上一条的 root），形成链。

**验收**

1. 非爆仓订单录像回放（fixture）→ 必须返回 `liquidated:false`。
2. 爆仓样例回放 → 返回 `true` 且 `reason`、`fields_used` 可解释。
3. 签名校验：篡改 `body` 或过期 `timestamp` → 401/498。
4. 重放同一 `nonce` → 409。
5. 证据链：连续三次验证，`parentRoot` 串联正确。

---

# 二、P1/P2 的安全与合规硬化（并行推进）

## P1-04：JWT & API Key 治理

* **强制配置**：启动时校验 `JWT_SECRET` 长度≥32，未配置直接拒绝启动。
* **持久化**：会话/ApiKey 入库（盐化+HMAC 摘要），**只展示一次明文**。
* **轮换**：引入 `kid` 与失效时间（TTL），提供**后台轮换**与**吊销**。
* **密钥托管**：JWT/ApiKey 秘钥放 KMS/Secret Manager；后端只读环境变量的**指针**。

**验收**：`dev-secret` 无法启动；重启服务会话不丢；旧 `kid` 被吊销后马上 401。

## P1-05：透明度页不再“静默 mock”

* **显式 Banner**：后端失败→进入 `DEMO` 模式时顶部红色 Banner 与导出禁用。
* **签名快照**：透明度数据采用“后端签名快照+Merkle root+时间戳”，前端**必须验证签名**，验证失败即维护页。

**验收**：断后端 → 出现 DEMO Banner；有签名→显示“已验证”，无签名→维护。

## P2-06：前端敏感信息

* 把 readKey 存储从 `localStorage → sessionStorage`，下载 Raw 需要二次确认且默认**脱敏导出**。
* 提供“短期 Token”从后端换取，**前端不再保存长期密钥**。

## P2-07：证据链治理

* 保存 `parentRoot` 与 append-only 日志；定期把 `root` **上链锚定**（日批）。
* 路径改可配置，权限最小化，周期性备份到 WORM 存储。

## P2-08：运维与自愈

* 用 **systemd**（或容器）+ `Restart=always`、`LimitNOFILE`、固定 `venv/requirements.txt`；
* UFW 白名单、fail2ban、健康检查 `/healthz`；集中日志与告警。

---

# 三、批量上链策略（你给的决策卡再精炼）

**默认**：`T = 60s` 窗口聚合，`N = 10` 条封顶；窗口到期或达阈值即写链。
**降级**：连续 2 个窗口失败 → 立即切换 **即时上链**；失败队列回放。
**批次数据**：`batch_id, createdAt, order_ids[], merkle_root, txHash, status, fail_reason, retried`。
**用户承诺**：回执与透明度页同步提示“≤60s 写链，拥堵改即时并补录”。
**监控**：窗口执行率、失败率、补偿延迟、每批 Gas、批次大小分布。

**验收**：

* 在压力下（20 单/分钟）批次平均大小接近 10；
* 刻意打断一次交易 → 自动切即时报、失败批回放成功；
* 透明度页能看到批次 `merkle_root` 与链上 tx。

---

# 四、执行计划（48h 热修复 → 14 天整治）

### T+0～8h（停止线）

* 关闭 jp-verify 外部入口或返回 `verify_unavailable`。
* us-backend 下线 “信任 paymentTx”，切换 `awaiting_payment` 流程。
* 上线全局 **Payout Kill-Switch**（环境开关），默认关闭。

### T+8～24h（清零 P0）

* 打通 **PaymentProof→置 paid** 全链路（哪怕先用 Sepolia 验证）。
* 实施 JP **签名 + 白名单 + 限流**，补上验收用 fixtures。
* 通过 P0 的 10 条正/反例回放用例。

### T+24～48h（稳态）

* JWT/ApiKey 治理最小闭环（持久化 + 强校验）。
* 透明度页 DEMO Banner、生效。
* systemd 与 UFW/Fail2ban 落地，告警连上。

### D3～D14（巩固）

* 证据链 parentRoot/上链锚定、批量上链策略、签名快照全量上线。
* 完成密钥托管、轮换、审计与备份策略。

---

# 五、发布闸门（Go/No-Go 清单）

**必须全部为“√”才放行：**

* [ ] P0-01 验收 5/5 通过；`paymentTx` 在任何入口都不影响状态。
* [ ] P0-02 验收 5/5 通过；非爆仓样例返回 `false`。
* [ ] Kill-Switch 可在 1 分钟内关停赔付路径。
* [ ] JWT/ApiKey 不用默认秘钥、会话重启不丢。
* [ ] 透明度页无签名即维护，DEMO Banner 正常。
* [ ] UFW 白名单、速率限制、日志与告警可见。
* [ ] 证据链写入 parentRoot 与 append-only 日志；快照可回溯。

---

# 六、环境变量与开关（建议命名）

* `PAYMENTS_ENFORCE_ONCHAIN=1`（强制 PaymentProof）
* `PAYOUT_KILL_SWITCH=1|0`（全局赔付熔断）
* `VERIFY_REQUIRE_SIGNATURE=1`、`VERIFY_HMAC_SECRET=…`、`VERIFY_ALLOWED_CIDRS=…`
* `TRANSPARENCY_REQUIRE_SIGNATURE=1`
* `FRONTEND_DEMOMODE_BANNER=1`
* `JWT_SECRET_KMS_KEY=…`、`APIKEY_ROTATION_DAYS=30`

---

# 七、你现在可以立刻做的 6 步

1. 后端删除对请求体 `paymentTx` 的任何信任路径，`POST /orders` 仅返回 `awaiting_payment`。
2. 启用 `PAYOUT_KILL_SWITCH=1`，确保误触不赔付。
3. JP 端把 `/api/verify` 改为 `503 verify_unavailable`，并上 **白名单 + HMAC**。
4. 写 10 条回放样例（5 爆仓/5 非爆仓）作 CI 的验收夹具。
5. 前端加 DEMO Banner 与导出禁用；readKey 改用 `sessionStorage`。
6. 上线 systemd、UFW 与告警：`/healthz` 报警、验证失败率报警、重放命中报警。

—

你已经把问题抓准了，剩下就是按这个顺序把“错误的捷径”堵死、把“正确的通道”收紧；一旦 P0 清零、验收过关，就能安全地把“批量上链 60s 窗口”打开，边跑边优化。下一步需要的话，我可以把**验收用例清单**和**数据库迁移脚本说明**拆成可直接执行的任务卡。
