import React, { useState } from "react";

// 理赔管理卡片列表，样式参考「订单管理」截图
// 这里只做前端展示与交互骨架，真实数据与接口你可以按项目接入。

type ClaimStatus = "PENDING" | "VERIFIED" | "PAID";

interface ClaimOrder {
  id: string; // 内部主键
  productName: string; // 例如："24h 爆仓保"
  principalUsd: number; // 保额
  leverage: string; // 杠杆，例如 "10x"
  premiumUsd: number; // 保费
  payoutMaxUsd: number; // 最高赔付
  purchaseTime: string; // 购买时间，展示用字符串
  orderRef: string; // 交易所订单号
  latestAccount: string; // 最近验单账号
  remainingSeconds: number; // 生效剩余秒数
  status: ClaimStatus; // 当前状态
}

const mockOrders: ClaimOrder[] = [
  {
    id: "1",
    productName: "24h 爆仓保",
    principalUsd: 200,
    leverage: "10x",
    premiumUsd: 3.2,
    payoutMaxUsd: 60,
    purchaseTime: "2025/11/14 20:17:34",
    orderRef: "87111111",
    latestAccount: "eacc_mock",
    remainingSeconds: 24 * 60 * 60 - 2, // demo
    status: "PENDING",
  },
  {
    id: "2",
    productName: "24h 爆仓保",
    principalUsd: 200,
    leverage: "10x",
    premiumUsd: 3.2,
    payoutMaxUsd: 60,
    purchaseTime: "2025/11/14 20:17:33",
    orderRef: "31799009",
    latestAccount: "eacc_mock",
    remainingSeconds: 24 * 60 * 60 - 120,
    status: "VERIFIED",
  },
];

function formatCountdown(seconds: number) {
  const h = Math.max(0, Math.floor(seconds / 3600));
  const m = Math.max(0, Math.floor((seconds % 3600) / 60));
  const s = Math.max(0, seconds % 60);
  const pad = (n: number) => n.toString().padStart(2, "0");
  return `${pad(h)}:${pad(m)}:${pad(s)}`;
}

const ClaimsManagePage: React.FC = () => {
  const [orders, setOrders] = useState<ClaimOrder[]>(mockOrders);

  // 点击「验证」按钮：调用后端验单接口，返回是否爆仓 + 证据ID
  const handleVerify = async (order: ClaimOrder) => {
    try {
      // TODO: 把这里的 URL 换成实际后端：例如 /api/v1/claims/verify
      const res = await fetch("/api/v1/claims/verify", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ orderRef: order.orderRef }),
      });

      if (!res.ok) {
        throw new Error(`验证失败: ${res.status}`);
      }

      const data = await res.json();
      // data 示例：{ liquidated: true, evidenceId: "evi_2025...", pnl: -7.15, symbol: "BTC-USDT-SWAP" }

      alert(
        `订单号 ${order.orderRef}\n爆仓结果：${
          data.liquidated ? "已爆仓" : "未爆仓"
        }\n证据ID：${data.evidenceId || "-"}`
      );

      if (data.liquidated) {
        setOrders((prev) =>
          prev.map((o) =>
            o.id === order.id
              ? {
                  ...o,
                  status: "VERIFIED",
                  latestAccount: data.account || o.latestAccount,
                }
              : o
          )
        );
      }
    } catch (err) {
      console.error(err);
      alert("验证失败，请稍后重试");
    }
  };

  // 点击「标记已赔付」：这里只改前端状态，你可以接到 /api/v1/claims/settle
  const handleMarkPaid = async (order: ClaimOrder) => {
    try {
      // TODO: 按需接真实接口
      // await fetch(`/api/v1/claims/${order.id}/settle`, { method: "POST" });

      setOrders((prev) =>
        prev.map((o) => (o.id === order.id ? { ...o, status: "PAID" } : o))
      );
    } catch (err) {
      console.error(err);
      alert("标记赔付失败，请稍后重试");
    }
  };

  return (
    <div className="claims-page">
      <div className="claims-header">
        <div className="claims-title-wrap">
          <div className="claims-status-dot" />
          <h1 className="claims-title">理赔管理</h1>
          <span className="claims-sub">共 {orders.length} 笔</span>
        </div>
        {/* 右上角可以放一个简单的筛选，后面再扩展 */}
        {/* <button className="claims-refresh">刷新</button> */}
      </div>

      <div className="claims-list">
        {orders.map((order) => (
          <div key={order.id} className="claim-card">
            {/* 第一行：产品 + 标签 + 状态 */}
            <div className="claim-row claim-row-main">
              <div className="claim-product">{order.productName}</div>

              <div className="claim-tags">
                <span className="pill pill-primary">
                  Principal ${order.principalUsd.toFixed(2)}
                </span>
                <span className="pill pill-sub">Leverage {order.leverage}</span>
                <span className="pill pill-sub">
                  Premium ${order.premiumUsd.toFixed(2)}
                </span>
                <span className="pill pill-sub">
                  Payout Max ${order.payoutMaxUsd.toFixed(2)}
                </span>
              </div>

              <div className="claim-status-wrap">
                {order.status === "PENDING" && (
                  <span className="status-pill status-active">
                    待验证 · T-{formatCountdown(order.remainingSeconds)}
                  </span>
                )}
                {order.status === "VERIFIED" && (
                  <span className="status-pill status-wait-pay">
                    待放款 · T-{formatCountdown(order.remainingSeconds)}
                  </span>
                )}
                {order.status === "PAID" && (
                  <span className="status-pill status-done">已赔付</span>
                )}
              </div>
            </div>

            {/* 第二行：时间 + 订单号 + 最近验单账号 */}
            <div className="claim-row claim-row-info">
              <span className="claim-info">购买时间 {order.purchaseTime}</span>
              <span className="claim-info">订单号 {order.orderRef}</span>
              <span className="claim-info">
                最近验单账号 {order.latestAccount || "-"}
              </span>
            </div>

            {/* 第三行：操作按钮 */}
            <div className="claim-row claim-row-actions">
              <button
                className="btn btn-outline"
                onClick={() => handleVerify(order)}
                disabled={order.status === "PAID"}
              >
                验证
              </button>

              <button
                className="btn btn-primary"
                onClick={() => handleMarkPaid(order)}
                disabled={order.status !== "VERIFIED"}
              >
                标记已赔付
              </button>

              <button className="btn btn-ghost">详情</button>
            </div>
          </div>
        ))}
      </div>

      {/* 简单页面级样式，按需抽到单独的 .css / tailwind 替换 */}
      <style>{`
        .claims-page {
          padding: 24px 32px;
          background: #fffaf1;
          min-height: 100vh;
        }
        .claims-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          margin-bottom: 16px;
        }
        .claims-title-wrap {
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .claims-status-dot {
          width: 16px;
          height: 16px;
          border-radius: 999px;
          background: #ffd54f;
        }
        .claims-title {
          margin: 0;
          font-size: 20px;
          font-weight: 600;
        }
        .claims-sub {
          font-size: 14px;
          color: #999;
        }
        .claims-list {
          display: flex;
          flex-direction: column;
          gap: 16px;
        }
        .claim-card {
          background: #ffffff;
          border-radius: 16px;
          padding: 16px 20px 12px;
          box-shadow: 0 1px 4px rgba(0, 0, 0, 0.04);
        }
        .claim-row {
          display: flex;
          align-items: center;
        }
        .claim-row-main {
          justify-content: space-between;
          gap: 16px;
        }
        .claim-product {
          font-size: 18px;
          font-weight: 600;
          white-space: nowrap;
        }
        .claim-tags {
          display: flex;
          flex-wrap: wrap;
          gap: 8px;
          flex: 1;
          padding-left: 16px;
        }
        .pill {
          display: inline-flex;
          align-items: center;
          border-radius: 999px;
          padding: 4px 10px;
          font-size: 13px;
          white-space: nowrap;
        }
        .pill-primary {
          background: #13315c;
          color: #fff;
        }
        .pill-sub {
          background: #f2f4f7;
          color: #4b5563;
        }
        .claim-status-wrap {
          white-space: nowrap;
        }
        .status-pill {
          border-radius: 999px;
          padding: 4px 12px;
          font-size: 13px;
          font-weight: 500;
        }
        .status-active {
          background: #e5f9e7;
          color: #15803d;
        }
        .status-wait-pay {
          background: #e0f2fe;
          color: #0369a1;
        }
        .status-done {
          background: #e5e7eb;
          color: #4b5563;
        }
        .claim-row-info {
          margin-top: 8px;
          font-size: 13px;
          color: #6b7280;
          justify-content: flex-start;
          gap: 24px;
        }
        .claim-row-actions {
          margin-top: 12px;
          justify-content: flex-start;
          gap: 12px;
        }
        .btn {
          border-radius: 999px;
          padding: 6px 14px;
          font-size: 14px;
          cursor: pointer;
          border: none;
        }
        .btn-primary {
          background: #13315c;
          color: #fff;
        }
        .btn-outline {
          background: #ffffff;
          border: 1px solid #d1d5db;
          color: #374151;
        }
        .btn-ghost {
          background: transparent;
          color: #6b7280;
        }
        .btn:disabled {
          opacity: 0.4;
          cursor: not-allowed;
        }
      `}</style>
    </div>
  );
};

export default ClaimsManagePage;


把原有赔付管理，页面重新命名，用这个代码重新写，先不加如何后端的逻辑，

先实现，用户下单购买，订单同时出现在，订单管理，赔付 管理这里，等会在添加后端逻辑哦，
可以，在这个基础上加后端逻辑是没问题的，不过要稍微“预留接口位”，以后接后端的时候就不会大改。

我直接把「可平滑接后端」版本的 `ClaimsManage.tsx` 给你，你可以直接替换文件，用这个当前端镜像版的实现。

---

## 思路先说清楚（保证后面好接后端）

1. **数据源现在只有一个：`lp_local_orders`**

   * 现在从 localStorage 读订单 → 映射成“赔付卡片”。
   * 未来加后端，只需要：

     * 挂载时多调一次 `GET /api/v1/claims/by-orders`（或类似接口），用后端状态覆盖/合并本地状态。

2. **状态字段要设计成“未来后端同款”：**

   * 前端先用枚举：`PENDING_VERIFY`（待验证）/ `WAITING_PAYOUT`（待放款）/ `PAID`（已赔付）。
   * 后端以后也用同样的状态名字（或者至少有个映射），这样不用重写一遍 UI。

3. **按钮逻辑先只改本地 state，预留 fetch 位：**

   * 点击「验证」：现在只改状态 + 造一个假 `evidenceId`。
   * 未来替换成：`POST /api/v1/claims/prepare` → 用返回的 `evidenceId` / `status` 更新卡片。
   * 点击「标记已赔付」：未来替换成 `POST /api/v1/claims/payout`。

---

## 推荐的 `ClaimsManage.tsx` 实现（直接贴到文件里）

```tsx
// apps/us-frontend/src/pages/ClaimsManage.tsx
import React, { useEffect, useState } from 'react';

const STORAGE_KEY = 'lp_local_orders';

type LocalOrder = {
  id?: string;
  orderRef?: string; // 交易所订单号，比如 2940...
  symbol?: string;
  side?: 'long' | 'short' | string;
  leverage?: number;
  premiumUsdc?: number;
  createdAt?: string;
};

type ClaimStatus = 'PENDING_VERIFY' | 'WAITING_PAYOUT' | 'PAID';

type ClaimItem = {
  localOrderId: string;
  orderRef: string;
  symbol: string;
  side?: string;
  leverage?: number;
  premiumUsdc?: number;
  createdAt?: string;
  status: ClaimStatus;
  evidenceId?: string;
  updatedAt: string;
};

const ClaimsManage: React.FC = () => {
  const [claims, setClaims] = useState<ClaimItem[]>([]);
  const [loading, setLoading] = useState(false);

  // 初始化：从 lp_local_orders 映射出理赔卡片
  useEffect(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;

    try {
      const orders: LocalOrder[] = JSON.parse(raw) ?? [];

      const mapped: ClaimItem[] = orders
        .map((o) => {
          const orderRef = o.orderRef || o.id || '';

          if (!orderRef) return null;

          return {
            localOrderId: o.id || orderRef,
            orderRef,
            symbol: o.symbol || '-',
            side: o.side,
            leverage: o.leverage,
            premiumUsdc: o.premiumUsdc,
            createdAt: o.createdAt,
            status: 'PENDING_VERIFY',
            updatedAt: new Date().toISOString(),
          } as ClaimItem;
        })
        .filter((x): x is ClaimItem => Boolean(x));

      setClaims(mapped);
    } catch (e) {
      console.error('[ClaimsManage] 解析 lp_local_orders 失败', e);
    }
  }, []);

  const updateClaim = (orderRef: string, patch: Partial<ClaimItem>) => {
    setClaims((prev) =>
      prev.map((c) =>
        c.orderRef === orderRef ? { ...c, ...patch } : c,
      ),
    );
  };

  // 点击「验证（生成证据链）」
  const handleValidateClick = async (claim: ClaimItem) => {
    setLoading(true);
    try {
      // TODO: 接后端时改成真正的 API 调用：
      // const res = await fetch('/api/v1/claims/prepare', { ... });
      // const data = await res.json();
      // updateClaim(claim.orderRef, {
      //   status: 'WAITING_PAYOUT',
      //   evidenceId: data.evidenceId,
      //   updatedAt: data.updatedAt,
      // });

      // 当前仅本地状态切换 + 造一个假的 evidenceId，方便你肉眼看流程
      updateClaim(claim.orderRef, {
        status: 'WAITING_PAYOUT',
        evidenceId: `evi_${Date.now().toString(36)}`,
        updatedAt: new Date().toISOString(),
      });
    } catch (err) {
      console.error(err);
      alert('验证失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  // 点击「标记已赔付（人工放款完成）」
  const handleMarkPaidClick = async (claim: ClaimItem) => {
    setLoading(true);
    try {
      // TODO: 接后端时改成 /api/v1/claims/payout 或类似接口：
      // const res = await fetch(`/api/v1/claims/${claimId}/payout`, { ... });
      // const data = await res.json();
      // updateClaim(claim.orderRef, { status: 'PAID', updatedAt: data.updatedAt });

      updateClaim(claim.orderRef, {
        status: 'PAID',
        updatedAt: new Date().toISOString(),
      });
    } catch (err) {
      console.error(err);
      alert('标记赔付失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  const renderStatusTag = (status: ClaimStatus) => {
    switch (status) {
      case 'PENDING_VERIFY':
        return (
          <span className="inline-flex rounded-full bg-yellow-50 px-2 py-0.5 text-xs font-medium text-yellow-700">
            待验证
          </span>
        );
      case 'WAITING_PAYOUT':
        return (
          <span className="inline-flex rounded-full bg-blue-50 px-2 py-0.5 text-xs font-medium text-blue-700">
            待放款
          </span>
        );
      case 'PAID':
        return (
          <span className="inline-flex rounded-full bg-green-50 px-2 py-0.5 text-xs font-medium text-green-700">
            已赔付
          </span>
        );
      default:
        return null;
    }
  };

  return (
    <div className="px-6 py-4">
      <div className="mb-4 flex items-center justify-between">
        <div>
          <h1 className="text-xl font-semibold">赔付管理</h1>
          <p className="text-sm text-gray-500">
            本页直接镜像本地订单（lp_local_orders），后续接入后端理赔接口时，只需要替换按钮内的调用逻辑。
          </p>
        </div>
      </div>

      {claims.length === 0 ? (
        <div className="rounded-lg border border-dashed border-gray-300 p-8 text-center text-sm text-gray-500">
          暂无订单。请先在「订单管理」完成一次投保，再回到这里查看理赔卡片。
        </div>
      ) : (
        <div className="space-y-4">
          {claims.map((claim) => (
            <div
              key={claim.orderRef}
              className="rounded-xl border border-gray-200 bg-white p-4 shadow-sm"
            >
              <div className="mb-2 flex items-center justify-between">
                <div className="text-sm font-medium text-gray-900">
                  订单号{' '}
                  <span className="font-mono text-xs text-gray-700">
                    {claim.orderRef}
                  </span>
                </div>
                {renderStatusTag(claim.status)}
              </div>

              <div className="mb-3 grid grid-cols-2 gap-2 text-xs text-gray-600 sm:grid-cols-4">
                <div>
                  <div className="text-gray-400">交易所 · 币对</div>
                  <div>{claim.symbol || '-'}</div>
                </div>
                <div>
                  <div className="text-gray-400">方向 / 杠杆</div>
                  <div>
                    {claim.side || '-'}
                    {claim.leverage ? ` · ${claim.leverage}x` : ''}
                  </div>
                </div>
                <div>
                  <div className="text-gray-400">保费</div>
                  <div>
                    {claim.premiumUsdc != null
                      ? `${claim.premiumUsdc} USDC`
                      : '-'}
                  </div>
                </div>
                <div>
                  <div className="text-gray-400">下单时间</div>
                  <div>
                    {claim.createdAt
                      ? new Date(claim.createdAt).toLocaleString()
                      : '-'}
                  </div>
                </div>

                {claim.evidenceId && (
                  <div className="col-span-full">
                    <div className="text-gray-400">证据链 ID</div>
                    <div className="font-mono text-[11px] text-gray-700">
                      {claim.evidenceId}
                    </div>
                  </div>
                )}
              </div>

              <div className="flex flex-wrap gap-2">
                <button
                  type="button"
                  disabled={loading || claim.status !== 'PENDING_VERIFY'}
                  onClick={() => handleValidateClick(claim)}
                  className="inline-flex items-center rounded-lg border border-gray-300 px-3 py-1.5 text-xs font-medium text-gray-700 disabled:cursor-not-allowed disabled:opacity-60"
                >
                  验证（生成证据链）
                </button>
                <button
                  type="button"
                  disabled={loading || claim.status !== 'WAITING_PAYOUT'}
                  onClick={() => handleMarkPaidClick(claim)}
                  className="inline-flex items-center rounded-lg bg-gray-900 px-3 py-1.5 text-xs font-medium text-white disabled:cursor-not-allowed disabled:opacity-60"
                >
                  标记已赔付（人工放款完成）
                </button>

                <div className="ml-auto text-[11px] text-gray-400">
                  最近更新：
                  {new Date(claim.updatedAt).toLocaleString()}
                </div>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default ClaimsManage;
```
这个需求是将现有的理赔管理页面 `ClaimsManage.tsx` 用提供的组件重写，并通过前端逻辑使订单同时出现在“订单管理”和“赔付管理”页面。具体流程如下：

### 步骤 1: 重写 `ClaimsManage.tsx` 页面

我们会用新的组件代码重写 `ClaimsManage.tsx`，将本地存储中的订单映射为理赔卡片，并展示在页面上。我们会通过读取 `lp_local_orders` 来获取订单，并且初始化时通过本地存储的数据渲染理赔卡。

以下是 `ClaimsManagePage` 代码模板：

```tsx
// apps/us-frontend/src/pages/ClaimsManage.tsx
import React, { useState, useEffect } from 'react';

const ClaimsManagePage: React.FC = () => {
  // 存储本地订单
  const [orders, setOrders] = useState<any[]>([]);

  // 从 localStorage 获取本地订单数据
  useEffect(() => {
    const localOrders = localStorage.getItem('lp_local_orders');
    if (localOrders) {
      setOrders(JSON.parse(localOrders)); // 将订单数据解析并更新到 state
    }
  }, []);

  // 验证和标记赔付
  const handleValidate = (orderId: string) => {
    // 模拟验证操作，后续可以接入后端
    alert(`验证订单: ${orderId}`);
    // 这里可以设置状态为“待放款”或者其他状态
  };

  const handlePayout = (orderId: string) => {
    // 模拟赔付操作，后续接入后端
    alert(`赔付订单: ${orderId}`);
    // 这里可以设置状态为“已赔付”
  };

  return (
    <div className="claims-manage">
      <h2>理赔管理</h2>
      <div className="order-list">
        {orders.length === 0 ? (
          <p>没有待处理的订单。</p>
        ) : (
          orders.map((order, index) => (
            <div key={index} className="order-card">
              <h3>订单号: {order.orderId}</h3>
              <p>状态: 待验证</p> {/* 这里后期可根据实际情况动态改变 */}
              <button onClick={() => handleValidate(order.orderId)}>验证</button>
              <button onClick={() => handlePayout(order.orderId)}>标记赔付</button>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

export default ClaimsManagePage;
```

### 步骤 2: 保留路由

确保在 `App.tsx` 中保留路由不变，指向 `ClaimsManagePage`。

```tsx
// apps/us-frontend/src/App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import ClaimsManagePage from './pages/ClaimsManage'; // 导入新的 ClaimsManagePage 组件

const App: React.FC = () => {
  return (
    <Router>
      <Routes>
        <Route path="/claims" element={<ClaimsManagePage />} /> {/* 保持路由不变 */}
      </Routes>
    </Router>
  );
};

export default App;
```

### 步骤 3: 订单显示和验证按钮

在 `ClaimsManagePage` 中，我们通过从 `localStorage` 获取 `lp_local_orders`，并在页面上渲染成理赔卡片。每个订单将有“验证”和“标记赔付”按钮，触发后模拟更新状态（后续可以接入后端）。

### 步骤 4: 兼容性和验证

* 保证 `/claims` 页面仍然能够正确显示从 `lp_local_orders` 中提取的订单。
* 验证：在 `OrdersPage` 页面中下单后，打开 `/claims` 页面，确认订单出现在理赔管理页面上。

### 验证步骤：

1. 启动前端应用。
2. 完成一次购买，订单将被写入 `localStorage`。
3. 打开 `/claims` 页面，确保订单出现在理赔管理列表中。
4. 点击“验证”按钮，模拟验证操作。
5. 点击“标记赔付”按钮，模拟赔付操作。

### 最终交付

* 替换 `ClaimsManage.tsx` 文件，确保新的页面逻辑已经完成。
* 不修改现有的路由配置，保持 `/claims` 路由指向 `ClaimsManagePage`。
* 完成页面和数据镜像逻辑，无需后端接口调用，确保本地存储的订单正确渲染。

---

## 以后接后端的改法（不用大动手术）

未来你要接后端，大概只需要改三块：

1. **组件挂载时：**

   * 先从 `lp_local_orders` 映射出 `claims`（现在已经做了）。
   * 再调一次后端，比如 `GET /api/v1/claims/by-orders?orderRefs=...`，拿到真实状态和 evidenceId：

     * 用 `updateClaim(orderRef, { status, evidenceId, updatedAt })` 覆盖掉本地状态。

2. **`handleValidateClick` 里：**

   * 把 TODO 换成 `fetch('/api/v1/claims/prepare', ...)`。
   * 根据后端返回更新 `status='WAITING_PAYOUT'` 和 `evidenceId`。

3. **`handleMarkPaidClick` 里：**

   * 换成 `fetch('/api/v1/claims/payout', ...)`，后端确认后改状态为 `PAID`。

结构不变、路由不动、`lp_local_orders` 依然是“订单管理 / 赔付管理”共同的数据底座，只是从“纯前端 demo”升级成“前端 + 后端共管状态”。

所以，你现在这条线上的逻辑是可以的，而且已经天然为“接后端”留好了通道。后面我们只是在这套外壳里，把“假 alert / 假 evidenceId”换成真实 API 调用就行了。
