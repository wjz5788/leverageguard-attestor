## 当前目标

1. 支付闭环可用：前端连接钱包 → USDC approve → 合约 buyPolicy 成功上链。
2. 未登录也能报价：产品页匿名生成并展示价格。
3. 订单回写最小化：交易哈希入账，订单页可见支付结果。

## 关键差距

* 链上 `quoteHash` 未由合约 owner 注册或已过期，导致支付校验失败。

* 钱包连接/切链流程不稳，重复点击与用户拒绝后缺少重试与提示。

* 缺少后端 `submit-tx` 与 `orders/my`，支付后无法落账。

* 前后端环境变量可能不一致（合约地址/USDC/chainId）。

## 阶段一：打通链上支付

1. 注册静态报价哈希：用合约 owner 在 Base 主网调用 `registerQuoteHash(bytes32,uint256)`，`expiryTime` 设未来时间，与前端 `VITE_CHECKOUT_QUOTE_HASH` 保持一致。
2. 统一环境：

   * 前端 `.env`：`VITE_CHECKOUT_QUOTE_HASH`、`VITE_CHECKOUT_USDC_ADDRESS=0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913`、`VITE_CHECKOUT_CONTRACT_ADDRESS=<合约地址>`。

   * 后端 `.env.production`：`USDC_ADDRESS`、`CHECKOUT_CONTRACT_ADDRESS`、`PAYMENT_CHAIN_ID=8453`。
3. 校验金额精度：统一以 USDC 6 位整数（如 1 USDC → `1_000_000`）。
4. Gas 保障：用户地址与 owner 均有足够 Base ETH。

## 阶段二：钱包连接稳定性

1. 连接状态机：`idle → connecting → connected`；按钮 `loading` 防并发。
2. 切链流程：先 `wallet_switchEthereumChain`，报错 `4902` 自动 `wallet_addEthereumChain`（Base 主网参数完整）。
3. 错误与重试：识别 `userRejectedRequest`/Provider Busy/RPC 超时；提供一次快速重试与明确提示，超时 30–60 秒提示。
4. 成功提示与日志：连接/切链/批准/支付各步骤分级提示与错误上报。

## 阶段三：匿名报价（未登录）

1. 后端：保留 `POST /api/v1/orders/preview` 为匿名端点，返回价格与展示必要信息。
2. 前端：拦截器白名单包含 `/api/v1/orders/preview`，产品页在未登录状态直接调用并展示价格。
3. CORS：确保前端来源可访问该端点。

## 阶段四：订单闭环与回写

1. 后端新增：

   * `POST /api/v1/orders/:orderId/submit-tx`：写入 `txHash`、`paidAt`、状态（如 `PAID` 或 `PENDING_CONFIRM`），持久化 JSON 账本。

   * `GET /api/v1/orders/my`：按用户地址返回订单列表。
2. 前端：在 `buyPolicy` 获得交易对象后提取 `hash` 调用 `submit-tx`；成功后跳转订单页或提示成功。
3. 数据字段：订单含 `orderId`、`address`、`amountUSDC6d`、`txHash`、`status`、`paidAt`、`expiresAt`。

## 验证与验收

* 正常流：连接并切到 Base → `approve` 上链可查 → `buyPolicy` 返回 `txHash` → `submit-tx` 成功 → 订单页显示已支付。

* 匿名报价：未登录点击产品页“生成价格”成功返回并展示。

* 失败演练：用户拒绝、切链失败、额度不足、RPC 慢/超时；UI 提示与重试行为正确。

## 风险与前置

* `quoteHash` 未注册/过期 → 合约拒绝：必须先完成注册。

* 合约地址/USDC/`chainId` 任一不一致 → 支付失败：需统一配置。

* RPC 限流/钱包扩展异常 → 连接不稳：需重试与清晰提示。

## 时间线

* 当天：`quoteHash` 注册 + 环境统一 + 连接/切链加固 → 打通链上支付与匿名报价展示。

* 次日：后端 `submit-tx` 与 `orders/my`、前端回写与列表 → 完成最小闭环。

## 交付与记录

* 提交信息按模块拆分（前端连接与支付、后端订单端点、文档差异说明）。

* 更新现有 `doc_01/对.md` 的“建议/最小化实现”段落以标注变更与对齐，不新增新文档。

结论先说：整体思路没问题，顺序也对（先打通链路→再稳钱包→再补匿名报价→最后闭环回写）。\
但有几个“隐形坑”和“重复劳动点”，建议现在就改掉，不然上线时会卡住。

&#x20;

我按严重程度拆给你：

***

## P0 级：现在版本一定要补/改的点

### 1. 订单从哪儿来？（缺少「创建订单」这一步）

你在阶段四里用了：

* `POST /api/v1/orders/:orderId/submit-tx`
* `GET /api/v1/orders/my`
* 订单字段里有 `orderId`

但整个方案里**没有写清楚**这一条：

> 用户点击「支付」之前，后端在哪里创建这个 `orderId`？

如果你打算“复用现在的 `createOrder` 逻辑”，那得在方案里明确一句，否则 doc 和实现对不上。

**建议你加一句（P0 必加）：**

* 阶段一 / 前端支付流程中补一条：
  > 「用户点击支付时，若尚无订单，则先 `POST /api/v1/orders` 创建订单（返回 `orderId`），再调用链上 `buyPolicy`，最后把 `txHash` 回写到 `submit-tx`。」

或者如果你真要极简，可以写成：

* 单产品 MVP：支付前由前端直接调用 `POST /api/v1/orders/simple-checkout`，后端：
  1. 在 SQLite 里创建一条订单（生成 `orderId`）
  2. 把 `orderId` 返回给前端用于后续 `submit-tx`

总之现在文档里是“凭空出现的 orderId”，这个会让之后的你自己也迷糊。

***

### 2. `submit-tx` 的安全边界要讲清楚

你现在写的是：

> `POST /api/v1/orders/:orderId/submit-tx`：写入 `txHash`、`paidAt`、状态…

如果只按字面实现，风险是：

* 任何登录用户只要知道一个 `orderId`，就能提交**任意链上 txHash** 来“宣称自己已支付”。

你之前的要求是“最小闭环、但不能直接自爆风控”，所以这块至少要有**一个最小校验口径**。

建议你在方案里加一句清晰的约束（实现可以分阶段）：

* **MVP 校验（今天就能做）：**
  1. 后端通过 RPC 查询 `txHash`：
     * `to` 必须等于 `CHECKOUT_CONTRACT_ADDRESS`
     * `from` 必须等于该订单的 `address`（用户钱包）
  2. 交易 logs 里至少出现一次 `PremiumPaid` / 对应事件（你现在的 CheckoutUSDC 已经在发 `PremiumPaid` 了）
  3. `amount` 与 `order.amountUSDC6d` 在允许误差范围内一致（或直接相等）
* 文档里可以写成一句：
  > `submit-tx` 至少校验 `txHash` 对应链上交易的 `from`、`to` 和金额与订单匹配，否则拒绝更新订单状态。

这样你的人肉审核/后续 attestor 也有一个最低限度的“不会被乱填 txHash 混淆账本”的基础。

***

## P1 级：设计/对齐层面的建议（不改也能上线，但改了以后少返工）

### 3. `quoteHash` 和合约实际实现要对得上

你在方案里写：

> 用合约 owner 在 Base 主网调用 `registerQuoteHash(bytes32,uint256)`，`expiryTime` 设未来时间，与前端 `VITE_CHECKOUT_QUOTE_HASH` 保持一致。

这里有一个“现实一致性”问题：

* 你当前在跑的是 **CheckoutUSDC 简化合约**，那份代码里是否真的有：
  * `registerQuoteHash`
  * `buyPolicy(bytes32 quoteHash, …)` 并且检查预注册的 `quoteHash`

如果现在合约只是一个 `buyPolicy(uint256 amount)` + `PremiumPaid`，那这段“quoteHash 注册逻辑”就会成为文档噪音，后端和前端都不会用到。

**建议：**

* **如果当前合约确实有 quoteHash 逻辑：**\
  那你这段没问题，只要保证：
  * `VITE_CHECKOUT_QUOTE_HASH` 与链上 `registerQuoteHash` 的值完全一致（注意 0x 前缀 + 大小写不敏感）
  * `expiryTime` 设置得足够长（比如一周 / 一月），并记在文档里。
* **如果当前主网上跑的是“极简 CheckoutUSDC（无 quoteHash）”：**\
  那就把这段「注册 quoteHash」从 MOP 方案里删掉，避免后续你自己被自己文档误导。\
  可以改为一句：
  > 当前 MOP 不做链上 quoteHash 校验，只依赖 USDC 金额 + PremiumPaid 事件，后续版本再引入 quoteHash 注册。

这一步是为了**让文档真实反映现在的合约**，不制造虚构功能。

***

### 4. SQLite vs “JSON 账本” 不要混用

你这里写：

> `submit-tx`：… 持久化 JSON 账本。

但你之前已经把 us-backend 的主账本迁到 SQLite，就算现在想“掐一刀最小实现”，也不建议**再搞一套 JSON 文件账本**，理由：

* 你之后一定会接链上监听器（contract\_events），必须和 orders 表做 join；
* JSON 账本会立刻引入：
  * 并发写入问题
  * 备份/迁移麻烦
  * 和 SQLite 状态不一致的问题

**建议你改成：**

* `submit-tx` → 直接更新 SQLite 的 `orders` 表（新增字段 `tx_hash`, `status`, `paid_at` 等）
* 把「JSON 账本」这几个字从方案里删掉，统一口径为：“写入 SQLite 订单表”。

这样以后你要加链上 listener，只要多一条表 `contract_events` 就能对上，不会多一个“异世界 JSON 账本”。

***

### 5. 匿名报价的 URL 命名要与现有接口对齐

你写的是：

> `POST /api/v1/orders/preview` 为匿名端点…

但你当前代码里，其实已经有：

* `/api/v1/pricing/quote-hash`（之前是给动态 quote + sig 用的）

为了避免前端/后端“命名炸裂”，建议你选一条：

* **方案 A（更干净）：**\
  保留 `/api/v1/pricing/preview` 或 `/api/v1/pricing/quote` 做“纯报价、不建订单”的匿名接口；\
  `orders/*` 都是“已经和某个用户/订单绑定的操作”。
* **方案 B（沿用你现在文案）：**\
  那就把现在代码里的 `pricing` 路径逐步收敛到 `orders/preview`，并确保前端只调用一种。

核心是：**匿名报价 ≠ 订单**，路径上区分一下，后面你就不会莫名其妙多出一堆 half-baked 的订单记录。

***

### 6. `orders/my` 必须从登录态取地址，而不是 query 参数

文档里写：

> `GET /api/v1/orders/my`：按用户地址返回订单列表。

这里最好明确一下“地址从哪来”：

* 正确做法：从当前 wallet 登录会话中拿 `address`（SIWE / 自定义 token），**绝对不要**允许前端传 `address` 参数来筛选。
* 文档可以补一句：
  > `orders/my` 使用当前登录会话绑定的钱包地址过滤订单，不接受额外地址参数，避免越权查看他人订单。

这一步是典型“现在不注意，未来审计会骂人”的点。

***

## P2 级：小的对齐和易用性

这些不改也能上线，但顺手改一下，未来少骂两句“谁写的文档”。

1. **环境变量命名 SSOT：**
   * 前端：`VITE_CHECKOUT_CONTRACT_ADDRESS` / `VITE_CHECKOUT_USDC_ADDRESS`
   * 后端：`CHECKOUT_CONTRACT_ADDRESS` / `USDC_ADDRESS` / `PAYMENT_CHAIN_ID=8453`
   * 文档里加一句：
     > 「上述四个地址/链 ID 必须保持一致，本仓库的 SSOT 在 `.github/env.md` / 或某个固定文档。」
2. **金额字段命名统一：**
   * 统一用 `*_usdc_6d`（例如 `premium_usdc_6d`, `amount_usdc_6d`）
   * 文档里把 `amountUSDC6d` 改成蛇形或者统一风格，避免一会儿 camelCase、一会儿 snake\_case。
3. **时间线合理：**
   * 你写的：
     * 当天：`quoteHash` + env + 钱包稳定 + 匿名报价
     * 次日：`submit-tx` + `orders/my`
   * 鉴于上面的 P0/P1 建议，其实“quoteHash 如果当前合约不支持，就先删掉”，能让当天任务更聚焦：\
     **“只把支付和 USDC 6 位金额打通 + 钱包 UX 稳定 + 匿名报价”**。

***

## 总体评价

* 大方向 ✅：先通链，再稳体验，再补最小回写闭环，这个顺序是对的。
* 真正需要你动笔改的，其实只有 3.5 个点：
  1. 补一条“订单创建”的说明（`createOrder` 在哪里发生）；
  2. 给 `submit-tx` 加最低限度的链上校验口径；
  3. 决定「现在的合约到底有没有 quoteHash」，有就加强说明，没有就从 MOP 方案里删掉；
  4. 把 “JSON 账本” 四个字换成 “SQLite 订单表”。

改完这几处，你这份可以直接作为 `doc_01/对.md` 里的“最新 MOP 实现方案”，以后再加链上监听器和自动赔付，也是在这个骨架上长肉，而不是推倒重来。
