好，咱们按「钱包登录 → 拿 token → authFetch 自动带上 Authorization」这条线，直接给你**可以粘代码**的版本。

我分三步：

1. 新增 `auth.ts`：负责钱包登录 + SIWE + 存 token
2. 改 `authFetch.ts`：从 `auth.ts` 里读 token，加到请求头
3. 把你的「连接钱包」按钮改成「钱包登录」按钮，调用 `loginWithWallet`

---

## 1️⃣ 新增：`apps/us-frontend/src/lib/auth.ts`

这个文件专门管「钱包登录 / 退出 / 取 token」，复用你现有的 `connectAndEnsureBase`。

```ts
// apps/us-frontend/src/lib/auth.ts
import { useEffect, useState } from 'react';
import { connectAndEnsureBase } from './payPolicy';

const AUTH_TOKEN_KEY = 'lp_auth_token';
const AUTH_ADDRESS_KEY = 'lp_auth_address';

export function getAuthToken(): string | null {
  if (typeof window === 'undefined') return null;
  return window.localStorage.getItem(AUTH_TOKEN_KEY);
}

export function getAuthAddress(): string | null {
  if (typeof window === 'undefined') return null;
  return window.localStorage.getItem(AUTH_ADDRESS_KEY);
}

export function clearAuth() {
  if (typeof window === 'undefined') return;
  window.localStorage.removeItem(AUTH_TOKEN_KEY);
  window.localStorage.removeItem(AUTH_ADDRESS_KEY);
}

type SiweStartResponse = {
  message: string;   // 要签名的 SIWE 文本
  nonce: string;
  chainId?: number;
};

type SiweVerifyResponse = {
  token?: string;
  accessToken?: string;
  address?: string;
};

async function startSiwe(address: string, chainId: number): Promise<SiweStartResponse> {
  const resp = await fetch('/api/v1/auth/siwe/start', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ address, chainId }),
    credentials: 'include',
  });

  if (!resp.ok) {
    const text = await resp.text().catch(() => '');
    throw new Error(`SIWE start failed: ${resp.status} ${text}`);
  }

  const data = (await resp.json()) as SiweStartResponse;
  if (!data.message || !data.nonce) {
    throw new Error('SIWE start response missing message/nonce');
  }
  return data;
}

async function verifySiwe(
  address: string,
  chainId: number,
  message: string,
  nonce: string,
  signature: string,
): Promise<SiweVerifyResponse> {
  const resp = await fetch('/api/v1/auth/siwe/verify', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      address,
      chainId,
      message,
      nonce,
      signature,
    }),
    credentials: 'include',
  });

  if (!resp.ok) {
    const text = await resp.text().catch(() => '');
    throw new Error(`SIWE verify failed: ${resp.status} ${text}`);
  }

  const data = (await resp.json()) as SiweVerifyResponse;
  return data;
}

/**
 * 主流程：连接钱包 → SIWE start → 签名 → SIWE verify → 保存 token
 */
export async function loginWithWallet(): Promise<{ address: string; token: string }> {
  // 1. 先确保钱包已连接并在 Base 链上
  const { signer, address } = await connectAndEnsureBase();
  const chainId = await signer.getChainId();

  // 2. 向后端要 SIWE message + nonce
  const { message, nonce } = await startSiwe(address, chainId);

  // 3. 用钱包签名
  const signature = await signer.signMessage(message);

  // 4. 把签名发到后端验证，拿 token
  const verifyResp = await verifySiwe(address, chainId, message, nonce, signature);
  const token = verifyResp.token ?? verifyResp.accessToken;

  if (!token) {
    throw new Error('SIWE verify success but no token in response');
  }

  // 5. 存在 localStorage，给 authFetch 用
  if (typeof window !== 'undefined') {
    window.localStorage.setItem(AUTH_TOKEN_KEY, token);
    window.localStorage.setItem(AUTH_ADDRESS_KEY, address);
  }

  return { address, token };
}

export function logoutWallet() {
  clearAuth();
}

/**
 * 小辅助 hook：方便组件里显示“是否已登录 / 地址”
 */
export function useAuth() {
  const [address, setAddress] = useState<string | null>(() => getAuthAddress());
  const [token, setToken] = useState<string | null>(() => getAuthToken());

  useEffect(() => {
    const handler = () => {
      setAddress(getAuthAddress());
      setToken(getAuthToken());
    };

    if (typeof window !== 'undefined') {
      window.addEventListener('storage', handler);
    }
    return () => {
      if (typeof window !== 'undefined') {
        window.removeEventListener('storage', handler);
      }
    };
  }, []);

  return {
    address,
    token,
    isLoggedIn: !!token,
  };
}
```

> ⚠️ 如果你后端 `/api/v1/auth/siwe/start` / `/verify` 返回字段名不一样（比如不是 `message` / `nonce` / `token`），就把上面对应部分改成你的真实字段即可。

---

## 2️⃣ 修改：`apps/us-frontend/src/lib/authFetch.ts`

让它从 `auth.ts` 里拿 token，自动加 `Authorization: Bearer xxx`，**不要再在前端直接 throw 401**。

```ts
// apps/us-frontend/src/lib/authFetch.ts
import { getAuthToken } from './auth';

export async function authFetch(
  input: RequestInfo | URL,
  init: RequestInit = {},
): Promise<Response> {
  const id = `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
  const urlStr = typeof input === 'string' ? input : input.toString();
  console.log('[authFetch]', id, '→', urlStr);

  const token = getAuthToken();
  const headers = new Headers(init.headers || {});

  if (token) {
    headers.set('Authorization', `Bearer ${token}`);
  } else {
    console.warn('[authFetch]', id, '当前无 auth token，将以匿名方式请求:', urlStr);
  }

  const resp = await window.fetch(input, {
    ...init,
    headers,
    credentials: 'include',
  });

  if (resp.status === 401) {
    console.warn('[authFetch]', id, '后端返回 401:', urlStr);
  }

  return resp;
}

/**
 * 常用：直接拿 json
 */
export async function authFetchJson<T>(
  input: RequestInfo | URL,
  init: RequestInit = {},
): Promise<T> {
  const resp = await authFetch(input, init);
  if (!resp.ok) {
    const text = await resp.text().catch(() => '');
    throw new Error(`authFetchJson failed: ${resp.status} ${text}`);
  }
  return (await resp.json()) as T;
}
```

这样：

* 只要你先用 `loginWithWallet()` 登过一次，`authFetch` 就会自动带上 `Authorization`。
* 就算没登录，也不会被前端拦截，是真正打到后端，由后端决定要不要 401。

---

## 3️⃣ 把「连接钱包」按钮改成「钱包登录」按钮

找你现在页面里用来连钱包的那个按钮（比如 Header、右上角、`ConnectWalletButton` 之类），原来大概是这样的：

```tsx
// 示例：apps/us-frontend/src/components/Header.tsx 伪代码
import { connectAndEnsureBase } from '../lib/payPolicy';

function Header() {
  const [address, setAddress] = useState<string | null>(null);

  const handleConnect = async () => {
    try {
      const { address } = await connectAndEnsureBase();
      setAddress(address);
    } catch (err) {
      console.error('connect wallet failed', err);
    }
  };

  return (
    <button onClick={handleConnect}>
      {address ? `${address.slice(0, 6)}...${address.slice(-4)}` : '连接钱包'}
    </button>
  );
}
```

把它改成**真正登录后端**的逻辑：

```tsx
// apps/us-frontend/src/components/Header.tsx（示例）
import { useState } from 'react';
import { loginWithWallet, logoutWallet, useAuth } from '../lib/auth';

function shortAddress(addr: string) {
  return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
}

export function Header() {
  const { address, isLoggedIn } = useAuth();
  const [loading, setLoading] = useState(false);

  const handleLoginClick = async () => {
    try {
      setLoading(true);
      const { address } = await loginWithWallet();
      console.log('wallet login ok', address);
    } catch (err) {
      console.error('wallet login failed', err);
      alert('钱包登录失败，请稍后重试');
    } finally {
      setLoading(false);
    }
  };

  const handleLogoutClick = () => {
    logoutWallet();
  };

  return (
    <header className="header">
      {/* 左侧 logo 略 */}

      <div className="wallet-login">
        {isLoggedIn && address ? (
          <>
            <span>已登录：{shortAddress(address)}</span>
            <button onClick={handleLogoutClick} disabled={loading}>
              退出
            </button>
          </>
        ) : (
          <button onClick={handleLoginClick} disabled={loading}>
            {loading ? '登录中…' : '用钱包登录'}
          </button>
        )}
      </div>
    </header>
  );
}
```

之后：

* 用户点「用钱包登录」：

  * 会连钱包 + 切到 Base；
  * 跑 SIWE start / verify；
  * 后端发 token，前端存到 localStorage；
* 再去点「发起理赔」：

  * `/api/v1/claims/prepare` 用的 `authFetch` 会自动带 `Authorization`；
  * 不会再出现你刚刚那种「未认证请求被阻断」这种前端自杀式 401 了。

---

## 4️⃣ 你这边可以怎么验证

1. 前端启动，打开 devtools 的 Application → Local Storage，看有没有 `lp_auth_token` / `lp_auth_address`。
2. 点击「用钱包登录」：

   * 钱包弹窗签名一次；
   * 登录成功后，Local Storage 里出现两个 key。
3. 控制台点你 `OrdersPage` 里的「发起理赔」：

   * 不再看到 `未认证请求被阻断`；
   * `/api/v1/claims/prepare` 请求头里有 `Authorization: Bearer xxx`（在 Network 里看）。

如果 Network 里请求发出去了，但后端仍然返回 401，那就是**后端验证 token 部分**再单独看；前端这条钱包登录 → token → authFetch 这条链就算打通了。
