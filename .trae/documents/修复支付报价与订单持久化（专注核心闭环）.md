## 当前问题根因
- 报价失败的直接原因：后端 /pricing/quote-hash 在 Base 主网执行 registerQuoteHash 时账户无 ETH（错误 "no-eth"），导致前端支付链路前置校验失败。
- 接口访问不一致：前端全局认证拦截与后端路由对认证的要求不一致（/pricing 应开放、/orders/preview 与 /orders 目前需要认证），在未设置 JWT/API Key 时会被阻断。
- 运行产物混用：dist 目录存在临时改动（文件账本等），src 尚未编译通过，导致“可运行但难以维护”的状态。
- 环境键噪音：旧键仍存在提示（尽管新键已齐备），易误导排查。

## 专注核心的修复策略
- 核心目标：打通“报价 → USDC 额度 → buyPolicy → 订单创建 → 持久化列表”闭环，前端点击“立即投保”不再报错。
- 优先级：
  1. 保障链上必要条件：为 ISSUER_PRIVATE_KEY 充值少量 Base ETH（建议 ≥ 0.005 ETH），保证 quote-hash 注册可用。
  2. 统一接口认证策略：
     - 定价路由 /api/v1/pricing/* 开放匿名访问（无需 JWT/API Key）。
     - 订单路由 /api/v1/orders/preview 与 /api/v1/orders：短期在开发环境允许 API Key 认证（前端 localStorage 写入 ADMIN_API_KEY），避免“未认证阻断”。
  3. 保持文件账本持久化：在 src 中完成 fileLedger 并接入 OrderService（创建时 append、查询时优先 load），确保服务重启后仍可读取历史订单。
  4. 前端仅保留必要调整：确保 .env 正确（VITE_API_BASE_URL 指向后端；Base 与合约地址一致），不做额外 UI 变动。

## 实施步骤（仅列出 src 变更）
- 数据层：新增 src/database/fileLedger.ts
  - 从 DB_FILE 推导出 orders.json；实现 loadOrders/saveOrders/appendOrder；JSON 损坏自动备份并重建。
- 服务层：src/services/orderService.ts
  - 创建订单时调用 appendOrder(order)（异步）；新增 listOrdersPersisted() 优先从 ledger 读取。
- 路由：src/routes/orders.ts
  - 开启 GET /api/v1/orders，返回 listOrdersPersisted()；预留 TODO：按钱包过滤与分页。
- 启动：src/server.ts
  - 生产环境加载 .env.production；保留 EnvValidator 校验逻辑；不依赖 dist 临时代码。

## 认证与访问策略（开发阶段）
- 在前端 dev 环境写入 API Key（模拟认证）：
  - `localStorage.setItem('api_key', '你的 ADMIN_API_KEY')`
- 定价接口匿名：保持 /pricing/* 不校验认证，避免报价流程受阻。

## 验证清单
- 后端：
  - `pnpm build --filter us-backend`
  - `NODE_ENV=production pnpm start --filter us-backend`
- 接口：
  - 订单预览：`POST /api/v1/orders/preview { skuId, principal, leverage, wallet }`
  - 报价签名：`POST /api/v1/pricing/quote { principal, leverage, durationHours, skuId, wallet }`
  - 报价哈希注册（需 ISSUER_PRIVATE_KEY 有 gas）：`POST /api/v1/pricing/quote-hash { wallet, amountUSDC }`
  - 创建订单：`POST /api/v1/orders { skuId, principal, leverage, wallet, premiumUSDC6d, idempotencyKey, paymentMethod }`
  - 列表查询：`GET /api/v1/orders`（重启后仍可读到历史订单）

## 可选优化（次优先）
- 彻底清理旧键提示：保留兼容映射，但仅在新键缺失时提示旧键存在，减少噪音。
- 将 /orders/preview 与 /orders 在开发环境放宽为匿名（或通过额外的 dev-only 开关），减少前端调试摩擦。
- 统一前端支付路径：前端只走“预览 → 报价签名 → 额度/支付 → 创建订单”一条路径，避免双路径导致的状态不一致。

## 你需要做的事
- 为 `ISSUER_PRIVATE_KEY` 地址充值少量 Base ETH（解决 quote-hash 的 "no-eth"）。
- 在前端 dev 环境设置 API Key（避免订单接口被拦截）。
- 告知真实的 `CHECKOUT_CONTRACT_ADDRESS`（如果与占位不同），确保前后端一致。

确认后我将按上述 src 改造与认证策略，把“报价失败”和“订单不可见”两个问题一次性收束，并用接口请求脚本验证整条闭环。