好，我懂了，你现在要的是**产品流重排**，不是继续在 nonce 那里死磕：

* **订单管理页**：保持现在样子，不动 UI，不改列表逻辑。
  只是「发起赔付」按钮不再直接走登录+prepare，而是**跳转到赔付管理页**。
* **赔付管理页**：长得跟订单管理差不多，一张张卡片：

  * 卡片里有订单信息；
  * 下面有：

    * 「验证」按钮 → 调用后端验证，生成/更新证据链，落库；
    * 状态展示（待验证 / 已验证待赔付 / 已赔付）；
    * 「标记为已赔付」按钮 → 你人工放款后点一下，状态变更。

而且：**产品买一次** → 后端自动在：

* `orders` 表里建一条订单；
* `claims` 表里建一条「待验证」的赔付记录；

这样两个页面都有这笔单。

下面我分三块给你：数据库模型、后端接口设计、前端修改（重点是前端代码）。

---

## 1. 数据层：加一个 `claims` 表，绑定订单

保持原来的 `orders` 不动，加一个最小可用的 `claims` 表（伪 SQL）：

```sql
CREATE TABLE claims (
  id                TEXT PRIMARY KEY,         -- UUID
  order_id          TEXT NOT NULL,           -- 关联 orders.id
  order_ref         TEXT NOT NULL,           -- 交易所订单号，方便人工核对
  status            TEXT NOT NULL,           -- pending | verified | paid
  evidence_id       TEXT,                    -- evi_xxx
  evidence_json     TEXT,                    -- 第一版可直接存 JSON 字符串
  verified_at       TEXT,                    -- 验证完成时间
  paid_at           TEXT,                    -- 实际打款时间（人工打完再标记）
  payout_tx_hash    TEXT,                    -- 如果以后走链上赔付，可以填交易哈希
  created_at        TEXT NOT NULL DEFAULT (datetime('now')),
  updated_at        TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**关键约定：**

* **下单成功 / 订单标记为已支付时**，在后端同步插入一条记录：

  ```ts
  // 在 markPaid / submit-tx 那里加入：
  await db.run(
    `INSERT INTO claims (id, order_id, order_ref, status, created_at, updated_at)
     VALUES (?, ?, ?, 'pending', datetime('now'), datetime('now'))`,
    [claimId, order.id, order.orderRef],
  );
  ```

  这样你就不用前端去“创建赔付单”，**产品一买，赔付管理里就有卡片**。

---

## 2. 后端接口：给赔付管理专用的 admin API（不走钱包登录）

把“后台理赔”这一块**单独拉一个 admin 路由**，用 `ADMIN_API_KEY` 做保护，完全绕开你现在卡住的钱包登录。示意：

```ts
// apps/us-backend/src/routes/adminClaims.ts
import { Router } from 'express';
import { z } from 'zod';
import { requireAdminApiKey } from '../middleware/requireAdminApiKey';
import { db } from '../db';

const router = Router();
router.use(requireAdminApiKey);

/**
 * GET /api/v1/admin/claims
 * 列出所有赔付记录（已 join 一些订单信息，方便前端展示）
 */
router.get('/claims', async (req, res) => {
  const rows = await db.all(`
    SELECT
      c.id              as claimId,
      c.status          as status,
      c.evidence_id     as evidenceId,
      c.verified_at     as verifiedAt,
      c.paid_at         as paidAt,
      o.id              as orderId,
      o.order_ref       as orderRef,
      o.symbol          as symbol,
      o.premium_usdc_6d as premium_usdc_6d,
      o.created_at      as orderCreatedAt
    FROM claims c
    JOIN orders o ON o.id = c.order_id
    ORDER BY c.created_at DESC
  `);

  res.json({ claims: rows });
});

/**
 * POST /api/v1/admin/claims/:claimId/verify
 * 调 jp-verify 生成证据链，更新 claims 表
 */
router.post('/claims/:claimId/verify', async (req, res) => {
  const { claimId } = req.params;

  // 1. 找到 claim + 对应订单
  const claim = await db.get(
    `SELECT c.*, o.order_ref, o.symbol
     FROM claims c JOIN orders o ON o.id = c.order_id
     WHERE c.id = ?`,
    [claimId],
  );
  if (!claim) {
    return res.status(404).json({ error: 'NOT_FOUND', message: 'claim not found' });
  }

  // 2. 调用 jp-verify，对应你现在的 verify 逻辑
  //    把 raw JSON / 归一化 JSON 存起来，生成 evidenceId
  const evidenceId = `evi_${Date.now()}_${claim.order_ref}`;
  const evidenceJson = JSON.stringify({
    exchange: 'okx',
    symbol: claim.symbol,
    orderRef: claim.order_ref,
    // ...这里调用 verify 服务返回的字段
  });

  // 3. 更新 claims
  await db.run(
    `UPDATE claims
     SET status = 'verified',
         evidence_id = ?,
         evidence_json = ?,
         verified_at = datetime('now'),
         updated_at = datetime('now')
     WHERE id = ?`,
    [evidenceId, evidenceJson, claimId],
  );

  return res.json({
    claimId,
    status: 'verified',
    evidenceId,
    // 前端展示用的 summary 字段：
    exchange: 'okx',
    symbol: claim.symbol,
    orderRef: claim.order_ref,
    // ... 可再带上 liquidated, pnl, size 等
  });
});

/**
 * POST /api/v1/admin/claims/:claimId/mark-paid
 * 人工打款完之后，在页面点按钮，标记为已赔付
 */
const markPaidBody = z.object({
  payoutTxHash: z.string().optional(), // 可以先不填
});

router.post('/claims/:claimId/mark-paid', async (req, res) => {
  const { claimId } = req.params;
  const { payoutTxHash } = markPaidBody.parse(req.body);

  await db.run(
    `UPDATE claims
     SET status = 'paid',
         payout_tx_hash = ?,
         paid_at = datetime('now'),
         updated_at = datetime('now')
     WHERE id = ?`,
    [payoutTxHash ?? null, claimId],
  );

  const updated = await db.get(
    `SELECT c.id as claimId, c.status, c.paid_at as paidAt, c.payout_tx_hash as payoutTxHash
     FROM claims c WHERE c.id = ?`,
    [claimId],
  );

  res.json(updated);
});

export default router;
```

在 `routes/index.ts` 里挂上：

```ts
import adminClaimsRouter from './adminClaims';

app.use('/api/v1/admin', adminClaimsRouter);
```

`requireAdminApiKey` 就是你之前写的那个中间件：检查 `x-admin-api-key` 头是否等于 `.env` 里的 `ADMIN_API_KEY`。

---

## 3. 前端改造：

### 3.1 订单管理页：发起赔付 → 只做跳转

在 `OrdersPage.tsx` 里，把原来的 `onClaimClick` 调用登录+prepare 改成**简单跳转**：

```tsx
import { useNavigate } from 'react-router-dom';

const OrdersPage: React.FC = () => {
  const navigate = useNavigate();

  const onClaimClick = (order: Order) => {
    navigate(`/claims?orderId=${order.id}`);
  };

  // render 中：
  // <button onClick={() => onClaimClick(order)}>发起赔付</button>
};
```

> 现在这个按钮不再碰 `loginWithWallet`，所以不会再卡在 nonce；
> 逻辑变成：“我选择了要赔付的订单 → 带着 orderId 去赔付管理页”。

---

### 3.2 赔付管理页：卡片 + 验证按钮 + 标记已赔付

新写一个「赔付管理」页面（`ClaimsPage.tsx`），核心点：

* 一次性拉取所有 claims（后端已经 join 好订单信息）；
* 每条 claim 显示成卡片，结构跟订单管理类似；
* 卡片底部按状态展示不同按钮：

  * `pending`：显示「验证」按钮；
  * `verified`：显示「等待赔付 · 标记已赔付」按钮；
  * `paid`：显示「已赔付」+ 交易哈希。

示例实现（可以直接套进你项目，按路径稍微改下 import）：

```tsx
// apps/us-frontend/src/pages/ClaimsPage.tsx
import React, { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';

const API_BASE =
  import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';
const ADMIN_API_KEY = import.meta.env.VITE_ADMIN_API_KEY || '';

type ClaimCard = {
  claimId: string;
  status: 'pending' | 'verified' | 'paid';
  evidenceId?: string | null;
  verifiedAt?: string | null;
  paidAt?: string | null;
  payoutTxHash?: string | null;

  orderId: string;
  orderRef: string;
  symbol?: string | null;
  premium_usdc_6d?: number | null;
  orderCreatedAt?: string | null;
};

const ClaimsPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const highlightOrderId = searchParams.get('orderId') || undefined;

  const [claims, setClaims] = useState<ClaimCard[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [busyClaimId, setBusyClaimId] = useState<string | null>(null);

  // 拉取所有赔付记录
  const fetchClaims = async () => {
    try {
      setLoading(true);
      setError(null);

      const res = await fetch(`${API_BASE}/api/v1/admin/claims`, {
        headers: {
          'x-admin-api-key': ADMIN_API_KEY,
        },
      });

      const text = await res.text();
      if (!res.ok) {
        throw new Error(text || `HTTP ${res.status}`);
      }
      const data = JSON.parse(text);
      setClaims(data.claims ?? data);
    } catch (err: any) {
      console.error('[ClaimsPage] fetchClaims failed:', err);
      setError(err.message || '加载赔付记录失败');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchClaims();
  }, []);

  // 点击“验证”按钮
  const handleVerify = async (claimId: string) => {
    try {
      setBusyClaimId(claimId);
      setError(null);

      const res = await fetch(
        `${API_BASE}/api/v1/admin/claims/${claimId}/verify`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-admin-api-key': ADMIN_API_KEY,
          },
          body: JSON.stringify({}),
        },
      );

      const text = await res.text();
      if (!res.ok) {
        throw new Error(text || `HTTP ${res.status}`);
      }
      const updated = JSON.parse(text);

      // 更新本地列表
      setClaims((prev) =>
        prev.map((c) =>
          c.claimId === claimId
            ? { ...c, status: 'verified', evidenceId: updated.evidenceId, verifiedAt: updated.verifiedAt }
            : c,
        ),
      );
    } catch (err: any) {
      console.error('[ClaimsPage] verify failed:', err);
      setError(err.message || '验证失败');
    } finally {
      setBusyClaimId(null);
    }
  };

  // 点击“标记已赔付”
  const handleMarkPaid = async (claimId: string) => {
    const payoutTxHash = window.prompt(
      '填写赔付交易哈希（可留空，后面再补）：',
      '',
    );

    try {
      setBusyClaimId(claimId);
      setError(null);

      const res = await fetch(
        `${API_BASE}/api/v1/admin/claims/${claimId}/mark-paid`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-admin-api-key': ADMIN_API_KEY,
          },
          body: JSON.stringify({ payoutTxHash: payoutTxHash || undefined }),
        },
      );

      const text = await res.text();
      if (!res.ok) {
        throw new Error(text || `HTTP ${res.status}`);
      }
      const updated = JSON.parse(text);

      setClaims((prev) =>
        prev.map((c) =>
          c.claimId === claimId
            ? {
                ...c,
                status: 'paid',
                paidAt: updated.paidAt,
                payoutTxHash: updated.payoutTxHash,
              }
            : c,
        ),
      );
    } catch (err: any) {
      console.error('[ClaimsPage] markPaid failed:', err);
      setError(err.message || '标记赔付失败');
    } finally {
      setBusyClaimId(null);
    }
  };

  return (
    <div style={{ padding: 24 }}>
      <h2 style={{ marginBottom: 8 }}>赔付管理</h2>
      <div style={{ fontSize: 13, color: '#666', marginBottom: 16 }}>
        从订单管理点“发起赔付”跳转到这里后，对应订单会被高亮。每张卡片都可以验证、
        生成证据链，并在人工打款后标记为已赔付。
      </div>

      {error && <div style={{ color: 'red', marginBottom: 8 }}>{error}</div>}
      {loading && <div>正在加载赔付记录...</div>}

      <div style={{ display: 'grid', gap: 12 }}>
        {claims.map((c) => {
          const highlight = c.orderId === highlightOrderId;
          return (
            <div
              key={c.claimId}
              style={{
                borderRadius: 8,
                padding: 16,
                background: '#fff',
                boxShadow: highlight
                  ? '0 0 0 2px #ff6b3b33, 0 4px 10px rgba(0,0,0,0.08)'
                  : '0 1px 4px rgba(0,0,0,0.06)',
              }}
            >
              <div style={{ display: 'flex', justifyContent: 'space-between' }}>
                <div style={{ fontWeight: 600 }}>
                  订单：{c.orderRef}（内部ID: {c.orderId}）
                </div>
                <div style={{ fontSize: 12 }}>
                  状态：{' '}
                  {c.status === 'pending'
                    ? '待验证'
                    : c.status === 'verified'
                    ? '已验证·等待赔付'
                    : '已赔付'}
                </div>
              </div>

              <div
                style={{
                  fontSize: 13,
                  color: '#555',
                  marginTop: 4,
                  lineHeight: 1.6,
                }}
              >
                币对：{c.symbol || '-'} · 保费（USDC，6位）：
                {c.premium_usdc_6d ?? '-'}
                <br />
                下单时间：{c.orderCreatedAt || '-'}
                <br />
                证据：{c.evidenceId || '尚未生成'}
                <br />
                验证时间：{c.verifiedAt || '-'} · 赔付时间：
                {c.paidAt || '-'}
                <br />
                赔付交易哈希：{c.payoutTxHash || '-'}
              </div>

              <div style={{ marginTop: 10, display: 'flex', gap: 8 }}>
                {c.status === 'pending' && (
                  <button
                    disabled={busyClaimId === c.claimId}
                    onClick={() => handleVerify(c.claimId)}
                    style={{
                      padding: '6px 12px',
                      fontSize: 13,
                      borderRadius: 4,
                      border: 'none',
                      background:
                        busyClaimId === c.claimId ? '#ccc' : '#ff6b3b',
                      color: '#fff',
                      cursor:
                        busyClaimId === c.claimId ? 'not-allowed' : 'pointer',
                    }}
                  >
                    {busyClaimId === c.claimId ? '验证中...' : '验证并生成证据链'}
                  </button>
                )}

                {c.status === 'verified' && (
                  <>
                    <span
                      style={{ fontSize: 12, color: '#999', paddingTop: 6 }}
                    >
                      已验证，等待人工赔付…
                    </span>
                    <button
                      disabled={busyClaimId === c.claimId}
                      onClick={() => handleMarkPaid(c.claimId)}
                      style={{
                        padding: '6px 12px',
                        fontSize: 13,
                        borderRadius: 4,
                        border: 'none',
                        background:
                          busyClaimId === c.claimId ? '#ccc' : '#4caf50',
                        color: '#fff',
                        cursor:
                          busyClaimId === c.claimId
                            ? 'not-allowed'
                            : 'pointer',
                      }}
                    >
                      {busyClaimId === c.claimId ? '提交中...' : '标记已赔付'}
                    </button>
                  </>
                )}

                {c.status === 'paid' && (
                  <span
                    style={{ fontSize: 12, color: '#4caf50', paddingTop: 6 }}
                  >
                    ✅ 已赔付
                  </span>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default ClaimsPage;
```

---

### 4. 这一版解决了什么？

* **订单管理保持不动**：列表、字段、样式都不改，只把「发起赔付」变成跳转。
* **赔付管理是一个纯后台页**：

  * 不走钱包登录，不走 nonce；
  * 只用 `ADMIN_API_KEY` + admin API。
* **产品买一次 → 两边都有记录**：

  * `orders`：看整体下单情况；
  * `claims`：看赔付进度，从“待验证 → 已验证待赔付 → 已赔付”，每个环节都有按钮、证据链、时间戳。

等这套跑起来，你随便挑一笔订单：

1. 在订单管理点「发起赔付」；
2. 跳到赔付管理，看到对应卡片被高亮；
3. 点「验证并生成证据链」；
4. 验完后，你人工再确认 → 打钱 → 回来点「标记已赔付」；

整个风控和资金流都在你掌控里，而且再也不会被 `/auth/wallet/nonce` 这种登录小妖精卡住。
