# LiqPass é“¾è·¯å¯é æ€§å®¡æŸ¥æŠ¥å‘Š

## æ‰§è¡Œæ‘˜è¦

æœ¬æŠ¥å‘Šå¯¹ LiqPass é¡¹ç›®çš„é“¾ä¸Šäº‹ä»¶ç›‘å¬ä¸å¤„ç†é“¾è·¯è¿›è¡Œå¯é æ€§å®¡æŸ¥ï¼Œé‡ç‚¹å…³æ³¨ PremiumPaid äº‹ä»¶çš„å¹‚ç­‰å…¥åº“ã€æ–­ç‚¹ç»­æ‰«ã€çŠ¶æ€é©±åŠ¨å’Œå®¡è®¡è¿½è¸ªæœºåˆ¶ã€‚å®¡æŸ¥èŒƒå›´æ¶µç›–é“¾ç›‘å¬æœåŠ¡ã€æ•°æ®åº“çº¦æŸã€äº‹ä»¶å›æ”¾å’Œé‡ç»„å¤„ç†é€»è¾‘ã€‚

**å®¡æŸ¥æ—¶é—´**ï¼š2024å¹´12æœˆ  
**å®¡æŸ¥èŒƒå›´**ï¼š`/apps/us-backend/src/services/contractListenerService.ts` åŠç›¸å…³æ•°æ®åº“è¿ç§»æ–‡ä»¶

## 1. ç›‘å¬ä¸å†™åº“æµç¨‹å›¾

### 1.1 æ ¸å¿ƒæµç¨‹æè¿°

```mermaid
graph TB
    A[å¯åŠ¨ç›‘å¬å™¨] --> B[æ–­ç‚¹ç»­æ‰«æ£€æŸ¥]
    B --> C[è·å–æœ€åå¤„ç†åŒºå—]
    C --> D[å›æ”¾æœªç¡®è®¤äº‹ä»¶]
    D --> E[å¯åŠ¨å®æ—¶ç›‘å¬]
    E --> F[ç›‘å¬PremiumPaidäº‹ä»¶]
    F --> G[å¹‚ç­‰æ€§æ£€æŸ¥]
    G --> H[äº‹ä»¶éªŒè¯]
    H --> I[æ›´æ–°è®¢å•çŠ¶æ€]
    I --> J[è®°å½•å®¡è®¡æ—¥å¿—]
    J --> K[å‘é€é€šçŸ¥]
    
    L[é‡ç»„æ£€æµ‹å®šæ—¶å™¨] --> M[æ£€æŸ¥åŒºå—å›é€€]
    M --> N{é‡ç»„æ·±åº¦â‰¤12?}
    N -->|æ˜¯| O[æš‚åœç›‘å¬]
    N -->|å¦| P[å‘Šè­¦äººå·¥å¹²é¢„]
    O --> Q[å›æ»šå—å½±å“äº‹ä»¶]
    Q --> R[é‡ç½®æ–­ç‚¹]
    R --> S[é‡æ–°å¯åŠ¨ç›‘å¬]
    
    T[æœåŠ¡é‡å¯] --> U[æ–­ç‚¹ç»­æ‰«]
    U --> D
```

### 1.2 è„†å¼±ç‚¹åˆ†æ

| è„†å¼±ç‚¹ | é£é™©ç­‰çº§ | å½±å“ | å½“å‰é˜²æŠ¤æªæ–½ | æ”¹è¿›å»ºè®® |
|--------|----------|------|-------------|----------|
| **é“¾é‡ç»„å¤„ç†** | ğŸ”´ é«˜ | äº‹ä»¶é‡å¤æˆ–ä¸¢å¤± | 12åŒºå—æ·±åº¦æ£€æµ‹ï¼Œè‡ªåŠ¨å›æ»š | å¢åŠ æ·±åº¦é˜ˆå€¼é…ç½®ï¼Œæ”¯æŒæ‰‹åŠ¨å¹²é¢„æ¥å£ |
| **æ•°æ®åº“è¿æ¥ä¸­æ–­** | ğŸŸ¡ ä¸­ | äº‹ä»¶å¤„ç†å¤±è´¥ | é”™è¯¯é‡è¯•æœºåˆ¶ | å®ç°è¿æ¥æ± å¥åº·æ£€æŸ¥ï¼Œè‡ªåŠ¨é‡è¿ |
| **RPCèŠ‚ç‚¹ä¸ç¨³å®š** | ğŸŸ¡ ä¸­ | ç›‘å¬ä¸­æ–­ | å¤šRPCèŠ‚ç‚¹åˆ‡æ¢ | å®ç°RPCèŠ‚ç‚¹å¥åº·æ£€æŸ¥å’Œæ•…éšœè½¬ç§» |
| **äº‹ä»¶éªŒè¯å¤±è´¥** | ğŸŸ¡ ä¸­ | è®¢å•çŠ¶æ€ä¸ä¸€è‡´ | å­—æ®µå®Œæ•´æ€§æ£€æŸ¥ | å¢åŠ äº‹ä»¶ç­¾åéªŒè¯ï¼Œé˜²æ­¢æ¶æ„äº‹ä»¶ |
| **å†…å­˜æ³„æ¼** | ğŸŸ  ä½ | æœåŠ¡å´©æºƒ | äº‹ä»¶ç›‘å¬å™¨æ¸…ç† | å¢åŠ å†…å­˜ç›‘æ§å’Œè‡ªåŠ¨é‡å¯æœºåˆ¶ |

## 2. å¹‚ç­‰/å›æ”¾éªŒè¯æ­¥éª¤

### 2.1 å¹‚ç­‰æ€§éªŒè¯è„šæœ¬

```bash
#!/bin/bash
# å¹‚ç­‰æ€§éªŒè¯è„šæœ¬ - PremiumPaidäº‹ä»¶

# ç¯å¢ƒå˜é‡è®¾ç½®
export DB_PATH="/path/to/database.db"
export CONTRACT_ADDRESS="0x..."
export RPC_URL="https://..."

# 1. ç”Ÿæˆæµ‹è¯•äº‹ä»¶
echo "ğŸ”§ ç”Ÿæˆæµ‹è¯•äº‹ä»¶..."
TEST_TX_HASH="0x$(openssl rand -hex 32)"
TEST_LOG_INDEX=$((RANDOM % 100))

# 2. ç¬¬ä¸€æ¬¡å¤„ç†äº‹ä»¶
echo "ğŸ“ ç¬¬ä¸€æ¬¡å¤„ç†äº‹ä»¶..."
node -e "
const { ContractListenerService } = require('./contractListenerService');
const service = new ContractListenerService();
await service.handleEvent('$TEST_TX_HASH', $TEST_LOG_INDEX);
"

# 3. æ£€æŸ¥æ•°æ®åº“è®°å½•
echo "ğŸ” æ£€æŸ¥æ•°æ®åº“è®°å½•..."
sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM contract_events WHERE tx_hash='$TEST_TX_HASH' AND log_index=$TEST_LOG_INDEX;"

# 4. ç¬¬äºŒæ¬¡å¤„ç†ç›¸åŒäº‹ä»¶
echo "ğŸ“ ç¬¬äºŒæ¬¡å¤„ç†ç›¸åŒäº‹ä»¶..."
node -e "
const { ContractListenerService } = require('./contractListenerService');
const service = new ContractListenerService();
await service.handleEvent('$TEST_TX_HASH', $TEST_LOG_INDEX);
"

# 5. éªŒè¯å¹‚ç­‰æ€§
echo "âœ… éªŒè¯å¹‚ç­‰æ€§..."
COUNT=$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM contract_events WHERE tx_hash='$TEST_TX_HASH' AND log_index=$TEST_LOG_INDEX;")
if [ "$COUNT" -eq "1" ]; then
    echo "ğŸ‰ å¹‚ç­‰æ€§éªŒè¯é€šè¿‡ï¼šäº‹ä»¶ä»…å¤„ç†ä¸€æ¬¡"
else
    echo "âŒ å¹‚ç­‰æ€§éªŒè¯å¤±è´¥ï¼šäº‹ä»¶å¤„ç†äº† $COUNT æ¬¡"
fi
```

### 2.2 å›æ”¾éªŒè¯æ­¥éª¤

```bash
#!/bin/bash
# å›æ”¾éªŒè¯è„šæœ¬ - æ–­ç‚¹ç»­æ‰«

# 1. è®°å½•å½“å‰çŠ¶æ€
echo "ğŸ“Š è®°å½•å½“å‰ç›‘å¬çŠ¶æ€..."
CURRENT_BLOCK=$(curl -s -X POST -H "Content-Type: application/json" --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' "$RPC_URL" | jq -r '.result' | xargs printf "%d")
LAST_PROCESSED=$(sqlite3 "$DB_PATH" "SELECT block_number FROM event_cursors WHERE cursor_key='premium_paid' ORDER BY id DESC LIMIT 1;" || echo "0")

echo "å½“å‰åŒºå—: $CURRENT_BLOCK"
echo "æœ€åå¤„ç†åŒºå—: $LAST_PROCESSED"

# 2. åœæ­¢ç›‘å¬å™¨
echo "ğŸ›‘ åœæ­¢ç›‘å¬å™¨..."
node -e "
const { ContractListenerService } = require('./contractListenerService');
const service = new ContractListenerService();
await service.stopListening();
"

# 3. æ¨¡æ‹ŸæœåŠ¡é‡å¯
echo "ğŸ”„ æ¨¡æ‹ŸæœåŠ¡é‡å¯..."
sleep 5

# 4. é‡æ–°å¯åŠ¨ç›‘å¬å™¨
echo "ğŸš€ é‡æ–°å¯åŠ¨ç›‘å¬å™¨..."
node -e "
const { ContractListenerService } = require('./contractListenerService');
const service = new ContractListenerService();
await service.startListening();
"

# 5. éªŒè¯æ–­ç‚¹ç»­æ‰«
echo "ğŸ” éªŒè¯æ–­ç‚¹ç»­æ‰«..."
NEW_LAST_PROCESSED=$(sqlite3 "$DB_PATH" "SELECT block_number FROM event_cursors WHERE cursor_key='premium_paid' ORDER BY id DESC LIMIT 1;")

if [ "$NEW_LAST_PROCESSED" -gt "$LAST_PROCESSED" ]; then
    echo "âœ… æ–­ç‚¹ç»­æ‰«éªŒè¯é€šè¿‡ï¼šä»åŒºå— $LAST_PROCESSED ç»§ç»­å¤„ç†"
else
    echo "âš ï¸  æ–­ç‚¹ç»­æ‰«éªŒè¯ï¼šæ— æ–°äº‹ä»¶å¤„ç†"
fi
```

## 3. éœ€è¦è¿½åŠ çš„å”¯ä¸€é”®/ç´¢å¼•

### 3.1 æ•°æ®åº“çº¦æŸè¡¥å……

```sql
-- è¿½åŠ å¤åˆå”¯ä¸€ç´¢å¼•ï¼ˆå¢å¼ºå¹‚ç­‰æ€§ï¼‰
CREATE UNIQUE INDEX IF NOT EXISTS idx_contract_events_tx_log_chain 
ON contract_events(tx_hash, log_index, chain_id);

-- è¿½åŠ çŠ¶æ€+æ—¶é—´ç´¢å¼•ï¼ˆä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½ï¼‰
CREATE INDEX IF NOT EXISTS idx_contract_events_status_created 
ON contract_events(status, created_at);

-- è¿½åŠ åŒºå—èŒƒå›´ç´¢å¼•ï¼ˆä¼˜åŒ–å›æ”¾æŸ¥è¯¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_contract_events_block_range 
ON contract_events(block_number, log_index);

-- è¿½åŠ è®¢å•çŠ¶æ€ç´¢å¼•ï¼ˆä¼˜åŒ–çŠ¶æ€æŸ¥è¯¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_orders_status_updated 
ON orders(status, updated_at);

-- è¿½åŠ äº‹ä»¶æ¸¸æ ‡ç´¢å¼•ï¼ˆä¼˜åŒ–æ–­ç‚¹æŸ¥è¯¢ï¼‰
CREATE INDEX IF NOT EXISTS idx_event_cursors_key_processed 
ON event_cursors(cursor_key, processed_at);
```

### 3.2 æœ€å°ä»£ç æ¥è§¦ç‚¹

#### 3.2.1 æ–‡ä»¶ï¼š`contractListenerService.ts`

**å‡½æ•°ï¼š`isEventProcessed` (ç¬¬347-360è¡Œ)**
```typescript
// å½“å‰å®ç°ï¼šä»…æ£€æŸ¥tx_hash + log_index
private async isEventProcessed(txHash: string, logIndex: number): Promise<boolean> {
    return new Promise((resolve, reject) => {
        this.db.get(
            'SELECT id FROM contract_events WHERE tx_hash = ? AND log_index = ?',
            [txHash, logIndex],
            (err: Error | null, row: any) => {
                if (err) {
                    console.error('âŒ æŸ¥è¯¢äº‹ä»¶å¤„ç†çŠ¶æ€å¤±è´¥:', err);
                    reject(err);
                    return;
                }
                resolve(!!row);
            }
        );
    });
}

// å»ºè®®å¢å¼ºï¼šå¢åŠ chain_idæ£€æŸ¥
private async isEventProcessed(txHash: string, logIndex: number, chainId: string): Promise<boolean> {
    return new Promise((resolve, reject) => {
        this.db.get(
            'SELECT id FROM contract_events WHERE tx_hash = ? AND log_index = ? AND chain_id = ?',
            [txHash, logIndex, chainId],
            (err: Error | null, row: any) => {
                if (err) {
                    console.error('âŒ æŸ¥è¯¢äº‹ä»¶å¤„ç†çŠ¶æ€å¤±è´¥:', err);
                    reject(err);
                    return;
                }
                resolve(!!row);
            }
        );
    });
}
```

**å‡½æ•°ï¼š`recordEvent` (ç¬¬363-395è¡Œ)**
```typescript
// å½“å‰å®ç°ï¼šç¼ºå°‘chain_idå­—æ®µ
private async recordEvent(eventData: {
    txHash: string;
    logIndex: number;
    orderId: string;
    buyer: string;
    amount: string;
    quoteHash: string;
    blockNumber: number;
    timestamp: Date;
    token?: string | null;
    treasury?: string | null;
}): Promise<void> {
    // å»ºè®®å¢å¼ºï¼šæ·»åŠ chain_idå­—æ®µå­˜å‚¨
    return new Promise((resolve, reject) => {
        this.db.run(
            `INSERT INTO contract_events (
                tx_hash, log_index, order_id, buyer_address, amount, 
                quote_hash, block_number, event_timestamp, status, chain_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                eventData.txHash,
                eventData.logIndex,
                eventData.orderId,
                eventData.buyer,
                eventData.amount,
                eventData.quoteHash,
                eventData.blockNumber,
                Math.floor(eventData.timestamp.getTime() / 1000),
                'processed',
                this.chainId // æ–°å¢chain_id
            ],
            function(this: any, err: Error | null) {
                if (err) {
                    console.error('âŒ è®°å½•äº‹ä»¶åˆ°æ•°æ®åº“å¤±è´¥:', err);
                    reject(err);
                    return;
                }
                console.log('âœ… äº‹ä»¶è®°å½•æˆåŠŸï¼ŒID:', this.lastID);
                resolve();
            }
        );
    });
}
```

#### 3.2.2 æ–‡ä»¶ï¼š`001_create_contract_events.sql`

**è¡¨ç»“æ„å¢å¼ºï¼š**
```sql
-- ä¿®æ”¹è¡¨ç»“æ„ï¼Œæ·»åŠ chain_idå­—æ®µ
ALTER TABLE contract_events ADD COLUMN chain_id TEXT NOT NULL DEFAULT '1';

-- åˆ é™¤æ—§çš„å”¯ä¸€çº¦æŸ
DROP INDEX IF EXISTS idx_contract_events_tx_hash_log_index;

-- åˆ›å»ºæ–°çš„å¤åˆå”¯ä¸€çº¦æŸï¼ˆæ”¯æŒå¤šé“¾ï¼‰
CREATE UNIQUE INDEX IF NOT EXISTS idx_contract_events_tx_log_chain 
ON contract_events(tx_hash, log_index, chain_id);

-- æ·»åŠ chain_idç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_contract_events_chain_id 
ON contract_events(chain_id);
```

## 4. å®¡è®¡æ—¥å¿—å¢å¼º

### 4.1 ç›‘å¬æ—¥å¿—æ ¼å¼æ ‡å‡†

```typescript
// æ ‡å‡†å®¡è®¡æ—¥å¿—æ ¼å¼
interface AuditLog {
    timestamp: string;           // ISOæ—¶é—´æˆ³
    eventType: 'premium_paid' | 'reorganization' | 'replay';
    transactionHash?: string;    // äº¤æ˜“å“ˆå¸Œ
    logIndex?: number;          // æ—¥å¿—ç´¢å¼•
    blockNumber: number;         // åŒºå—é«˜åº¦
    chainId: string;            // é“¾ID
    retryCount: number;         // é‡è¯•æ¬¡æ•°
    operation: 'insert' | 'update' | 'delete';
    table: string;              // æ“ä½œè¡¨å
    recordId?: number;          // è®°å½•ID
    success: boolean;           // æ“ä½œç»“æœ
    errorMessage?: string;      // é”™è¯¯ä¿¡æ¯
    durationMs: number;         // æ“ä½œè€—æ—¶
}

// ç¤ºä¾‹æ—¥å¿—è¾“å‡º
{
    "timestamp": "2024-12-19T10:30:00.000Z",
    "eventType": "premium_paid",
    "transactionHash": "0x123...",
    "logIndex": 5,
    "blockNumber": 12345678,
    "chainId": "8453",
    "retryCount": 0,
    "operation": "insert",
    "table": "contract_events",
    "recordId": 42,
    "success": true,
    "durationMs": 15
}
```

### 4.2 å…³é”®å®¡è®¡ç‚¹

1. **äº‹ä»¶æ¥æ”¶**ï¼šè®°å½•ç›‘å¬åˆ°çš„åŸå§‹äº‹ä»¶æ•°æ®
2. **å¹‚ç­‰æ£€æŸ¥**ï¼šè®°å½•æ£€æŸ¥è¿‡ç¨‹å’Œç»“æœ
3. **äº‹ä»¶éªŒè¯**ï¼šè®°å½•å­—æ®µéªŒè¯ç»“æœ
4. **æ•°æ®åº“æ“ä½œ**ï¼šè®°å½•å†™åº“æ“ä½œå’Œç»“æœ
5. **çŠ¶æ€æ›´æ–°**ï¼šè®°å½•è®¢å•çŠ¶æ€å˜æ›´
6. **é‡ç»„å¤„ç†**ï¼šè®°å½•é‡ç»„æ£€æµ‹å’Œå¤„ç†è¿‡ç¨‹
7. **å›æ”¾æ“ä½œ**ï¼šè®°å½•æ–­ç‚¹ç»­æ‰«è¿‡ç¨‹

## 5. éªŒæ”¶æ ‡å‡†

### 5.1 å¹‚ç­‰æ€§éªŒæ”¶
- âœ… ç›¸åŒtx_hash + log_indexçš„äº‹ä»¶ä»…å¤„ç†ä¸€æ¬¡
- âœ… æ•°æ®åº“å”¯ä¸€çº¦æŸé˜»æ­¢é‡å¤æ’å…¥
- âœ… é‡å¯æœåŠ¡åä¸ä¼šé‡å¤å¤„ç†å·²ç¡®è®¤äº‹ä»¶

### 5.2 æ–­ç‚¹ç»­æ‰«éªŒæ”¶
- âœ… æœåŠ¡é‡å¯åä»æœ€åç¡®è®¤é«˜åº¦ç»§ç»­æ‰«æ
- âœ… é‡ç»„äº‹ä»¶æ­£ç¡®å¤„ç†å’Œå›æ»š
- âœ… å›æ”¾çª—å£å†…äº‹ä»¶ä¸ä¼šä¸¢å¤±

### 5.3 äº‹ä»¶å®Œæ•´æ€§éªŒæ”¶
- âœ… æ‰€æœ‰å¿…éœ€å­—æ®µé½å…¨ä¸”ç±»å‹æ­£ç¡®
- âœ… é“¾ä¸Šæ•°æ®ä¸æ•°æ®åº“å­˜å‚¨ä¸€è‡´
- âœ… è®¢å•çŠ¶æ€ä»…ç”±é“¾ä¸Šäº‹ä»¶é©±åŠ¨

### 5.4 å®¡è®¡è¿½è¸ªéªŒæ”¶
- âœ… ç›‘å¬æ—¥å¿—åŒ…å«å®Œæ•´æ“ä½œä¿¡æ¯
- âœ… é”™è¯¯åœºæ™¯æœ‰è¯¦ç»†é”™è¯¯æ—¥å¿—
- âœ… æ€§èƒ½æŒ‡æ ‡å¯ç›‘æ§å’Œå‘Šè­¦

## 6. æ”¹è¿›å»ºè®®

### 6.1 çŸ­æœŸæ”¹è¿›ï¼ˆP0ï¼‰
1. **æ·»åŠ chain_idå­—æ®µ**ï¼šæ”¯æŒå¤šé“¾éƒ¨ç½²
2. **å¢å¼ºå”¯ä¸€çº¦æŸ**ï¼štx_hash + log_index + chain_idå¤åˆå”¯ä¸€é”®
3. **å®Œå–„å®¡è®¡æ—¥å¿—**ï¼šæ ‡å‡†åŒ–æ—¥å¿—æ ¼å¼å’Œå…³é”®å®¡è®¡ç‚¹

### 6.2 ä¸­æœŸæ”¹è¿›ï¼ˆP1ï¼‰
1. **å®ç°RPCæ•…éšœè½¬ç§»**ï¼šå¤šèŠ‚ç‚¹å¥åº·æ£€æŸ¥å’Œè‡ªåŠ¨åˆ‡æ¢
2. **å¢åŠ ç›‘æ§å‘Šè­¦**ï¼šç›‘å¬å™¨çŠ¶æ€ã€å¤„ç†å»¶è¿Ÿã€é”™è¯¯ç‡ç›‘æ§
3. **ä¼˜åŒ–é‡ç»„å¤„ç†**ï¼šæ”¯æŒé…ç½®åŒ–é‡ç»„æ·±åº¦å’Œæ‰‹åŠ¨å¹²é¢„

### 6.3 é•¿æœŸæ”¹è¿›ï¼ˆP2ï¼‰
1. **å®ç°äº‹ä»¶æº¯æº**ï¼šå®Œæ•´çš„äº‹ä»¶å¤„ç†é“¾è·¯è¿½è¸ª
2. **æ”¯æŒæ°´å¹³æ‰©å±•**ï¼šå¤šå®ä¾‹ç›‘å¬å™¨åè°ƒæœºåˆ¶
3. **å¢å¼ºå®‰å…¨æ€§**ï¼šäº‹ä»¶ç­¾åéªŒè¯å’Œé˜²é‡æ”¾æ”»å‡»

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024-12-19  
**ç»´æŠ¤è€…**: LiqPasså¼€å‘å›¢é˜Ÿ