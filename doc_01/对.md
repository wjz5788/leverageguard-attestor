好，收口时间到了。
下面我帮你整理一份**可以直接给 AI（Codex、Cursor 那种）用的总提示词**，里面包括：

* 项目标准（v0 要求）
* 要 AI 帮你**核对项目是否符合这些标准**
* 单独点名：**钱包登录 / 链接不顺滑，要一起检查并修**

你只要把下面整段复制给 AI，然后按它的建议跑就行。

---

## 给 AI 的总提示词（可直接复制）

> 角色：你是一个严谨的全栈代码审查与重构助手，要帮我把一个「24 小时强平险」项目从半成品拉到可上线的 v0 版本。
>
> 前端：`apps/us-frontend`
> 后端：`apps/us-backend`
> 链：Base 主网，USDC 支付，已经有 CheckoutUSDC 合约。

---

### 一、项目 v0 标准（请先读完，用来审查代码）

当前只关心一个非常窄的场景，请你按这个标准来核对 / 修改代码：

1. **产品范围**

   * 只卖一个产品：`24h_force_liq`（24 小时强平险）。
   * 只认一种事件：在支付后的 24 小时窗口内，CEX 账户是否发生强平（不看回撤）。
   * 验证模式是**被动触发**：用户被强平后，回到前端的「订单管理」页面，在对应订单上点击「验证强平/申请理赔」。

2. **三条必须打通的链路**

   **(1) 收钱链路（钱包 → 合约 → 订单）**

   * 用户用 MetaMask：

     * 连接钱包；
     * 切换到 Base 主网；
     * 使用 Base USDC 调用 CheckoutUSDC 支付保费。
   * 后端在 `orders` 表记录：

     * `id`（orderId）
     * `wallet_address`
     * `cex_account`（CEX 账号标识，用于后续查询）
     * `product_type = 24h_force_liq`
     * `premium_usdc_6d`（六位小数整数）
     * `status`：`CREATED` / `PAID` / `PAID_OUT` / `EXPIRED`
     * `tx_hash`
     * `paid_at`
     * `expires_at = paid_at + 24h`
     * `payout_tx_hash`
     * `payout_status`

   **(2) 验证链路（订单 → CEX 强平 → 验证结果）**

   * 用户在 24h 期间被 CEX 强平。
   * 回到「订单管理页」，在该订单上点「验证强平/申请理赔」，前端调用：
     `POST /api/v1/orders/:orderId/request-verification`
   * 后端要做：

     * 确认订单属于当前登录钱包；
     * `status = PAID`，当前时间未超过 `expires_at`；
     * 从订单中拿到 `cex_account`；
     * 用 `paid_at ~ paid_at+24h` + `cex_account` 调用 OKX 或 Binance 的**只读 API**，获取强平记录；
     * 判断这个 24h 窗口内是否存在有效强平事件；
     * 将结果写入 `order_verifications` 表：

       * `order_id`
       * `cex`
       * `window_start`
       * `window_end`
       * `decision`：`ELIGIBLE` / `NOT_ELIGIBLE` / `MANUAL_REVIEW`
       * `reason_code`：`FORCE_LIQUIDATION_FOUND` / `NO_FORCE_LIQUIDATION` / `DATA_INCOMPLETE`
       * `raw_snapshot`：CEX 返回数据的 JSON 字符串
       * `created_at`
     * API 返回给前端一个精简 JSON：

       ```jsonc
       {
         "decision": "ELIGIBLE",
         "reasonCode": "FORCE_LIQUIDATION_FOUND",
         "forceLiquidations": [
           {
             "symbol": "BTC-USDT-SWAP",
             "time": "2025-11-13T01:23:45Z",
             "side": "long",
             "size": "100",
             "price": "68000.5"
           }
         ]
       }
       ```

   **(3) 发钱链路（人工 → 链上转账 → 系统记账）**

   * 管理员在后台看到订单详情 + 最新验证结果，决定是否赔付。
   * 手动在链上从金库钱包向用户钱包转 USDC。
   * 调用 `POST /api/v1/admin/orders/:orderId/mark-paid`：

     * 写入 `payout_tx_hash`；
     * 更新 `payout_status = PAID_OUT`。

3. **v0 要求的接口清单**

> 假设前端订单管理页 + 倒计时 + 按钮已经有了，你只需要保证这些接口存在且行为符合标准：

* `POST /api/v1/orders`
  创建订单，返回 `orderId`。写入 `orders` 表，`status = CREATED`。

* `POST /api/v1/orders/:orderId/submit-tx`
  支付成功后由前端调用：写入 `tx_hash`，标记 `status = PAID`，设置 `paid_at` 和 `expires_at = paid_at + 24h`。

* `GET /api/v1/orders/my`
  根据当前登录的钱包地址，返回用户自己的订单列表：

  * `orderId`
  * `status`
  * `paidAt`
  * `expiresAt`
  * 最近一次验证结果（可选）

* `POST /api/v1/orders/:orderId/request-verification`
  被强平后用户点按钮触发：调用 CEX 只读 API 检查 24h 窗口内是否有强平事件，写入 `order_verifications`，并返回简化结果。

* `POST /api/v1/admin/orders/:orderId/mark-paid`
  管理员在链上打钱之后调用，写入 `payout_tx_hash`，更新 `payout_status = PAID_OUT`。

---

### 建议：项目现状与文档差异及最小化落地方案

- 现状概览
  - 前端支付已走「路线 A」：`payPolicy` 直连钱包 → Base → USDC `approve` → 合约 `buyPolicy`，优先使用 `VITE_CHECKOUT_QUOTE_HASH`（apps/us-frontend/src/lib/payPolicy.ts:69-112）。
  - 后端已存在：`POST /api/v1/orders`、`POST /api/v1/orders/preview`、`GET /api/v1/orders`、`GET /api/v1/orders/:orderId`（apps/us-backend/src/routes/orders.ts:45-49、111-161、163-226）。
  - 持久化采用 JSON 文件账本，目录由 `DB_FILE` 推导（apps/us-backend/src/database/fileLedger.ts）。
  - 缺失接口：`POST /api/v1/orders/:orderId/submit-tx`、`GET /api/v1/orders/my`、`POST /api/v1/orders/:orderId/request-verification`、`POST /api/v1/admin/orders/:orderId/mark-paid`。

- 与文档（v0 标准）差异清单
  - 缺少支付后提交交易并设置窗口：未写入 `tx_hash`、`paid_at`、`expires_at`。
  - 缺少我的订单列表：当前只支持按 API Key 列出全部订单。
  - 缺少验证链路：未实现 `request-verification` 与 `order_verifications` 数据。
  - 缺少发钱链路：未实现管理员 `mark-paid` 与 `payout_tx_hash`、`payout_status` 字段。

- 最小化开发建议（可执行清单）
  - 后端（按文档接口清单补齐）
    - 新增 `POST /api/v1/orders/:orderId/submit-tx`：保存 `tx_hash`，更新 `status = PAID`，设置 `paid_at` 与 `expires_at = paid_at + 24h`（apps/us-backend/src/routes/orders.ts）。
    - 新增 `GET /api/v1/orders/my`：根据当前登录钱包地址返回列表（apps/us-backend/src/routes/orders.ts）。
    - 新增 `POST /api/v1/orders/:orderId/request-verification`：调用只读 CEX API（可先实现 OKX/或占位返回 `MANUAL_REVIEW`），入库 `order_verifications`（apps/us-backend/src/services/verifyService.ts + routes）。
    - 新增 `POST /api/v1/admin/orders/:orderId/mark-paid`：写入 `payout_tx_hash`，更新 `payout_status = PAID_OUT`（apps/us-backend/src/routes/orders.ts）。
    - 数据结构补齐：在 `orders` 增加 `txHash`、`paidAt`、`expiresAt`、`payoutTxHash` 字段；保持 JSON 账本实现（apps/us-backend/src/types/orders.ts、src/database/fileLedger.ts、src/services/orderService.ts）。
    - 鉴权与环境：端点沿用 `X-API-Key`（`ADMIN_API_KEY`）；前端通过 `localStorage.setItem('api_key', '<ADMIN_API_KEY>')` 注入。
  - 前端（统一一条龙体验）
    - `payPolicy` 成功后：依次调用 `POST /api/v1/orders`（如需生成/幂等创建）、`POST /api/v1/orders/:orderId/submit-tx` 写入 `txHash`，再导航到订单页（apps/us-frontend/src/lib/payPolicy.ts）。
    - 订单页改为调用 `GET /api/v1/orders/my`，随钱包账户切换刷新列表（apps/us-frontend/src/pages/AccountOrders.tsx 或等价入口）。
    - 钱包流程复用：`connectAndEnsureBase` + USDC `allowance/approve` 已在 `payPolicy.ts` 内，可抽出并在全局使用，减少重复点击（apps/us-frontend/src/contexts/WalletContext.tsx）。
  - 链上 quoteHash（一次性配置）
    - 由合约 owner 在 Base 主网调用 `registerQuoteHash(bytes32,uint256)` 预注册 `VITE_CHECKOUT_QUOTE_HASH`，设置未来过期时间；前端稳定使用该值。

---

### 二、你需要完成的任务（AI 执行步骤）

请按顺序做，不要跨太多步。

#### 任务 1：核对后端是否符合上述 v0 标准

1. 只看 `apps/us-backend`：

   * 列出已有的表结构（migrations）和与订单相关的服务/路由；
   * 对照上面 v0 标准，指出：

     * 哪些表字段已经满足；
     * 哪些字段缺失或命名不一致；
     * 哪些 API 已经存在但行为不符合标准；
     * 哪些 API 根本不存在。

2. 输出一份「差异清单」，用中文概括，每条说明：

   * 位置（文件路径 + 函数名或路由路径）；
   * 当前行为；
   * 距离 v0 标准的差别是什么；
   * 需要的最小修改是什么。

> 要求：先给我差异清单，再考虑写代码。不要先大改。

#### 任务 2：在后端补齐 / 修正 v0 所需接口和表

在差异清单明确之后，再进行代码修改。要求：

1. **数据层**

   * 为 `orders` 表和 `order_verifications` 表补齐 v0 所需的字段和索引；
   * 如果已经有类似表，可以迁移/扩展，不要引入新的重复表。

2. **服务与路由**

   * 完整实现并测试：

     * `POST /api/v1/orders`
     * `POST /api/v1/orders/:orderId/submit-tx`
     * `GET /api/v1/orders/my`
     * `POST /api/v1/orders/:orderId/request-verification`
     * `POST /api/v1/admin/orders/:orderId/mark-paid`
   * 保证它们的行为严格符合「v0 标准」部分的描述。

3. **CEX 验证逻辑**

   * 实现一个独立的 `verify` 模块（例如 `verifyService.ts`），只负责：

     * 给定：`cex`, `cexAccount`, `windowStart`, `windowEnd`；
     * 调用 OKX 或 Binance 的只读 API（可以先实现一种）；
     * 返回：`decision`、`reasonCode`、`forceLiquidations[]`、`rawSnapshot`。
   * 在 `request-verification` 路由里调用这个模块，并入库 `order_verifications`。

4. **错误处理**

   * CEX 接口异常或缺少 `cex_account` 时：

     * 返回 `decision = MANUAL_REVIEW`, `reasonCode = DATA_INCOMPLETE`；
     * HTTP 状态可以是 200，但前端能识别为“需要人工复核”。

---

### 三、钱包登录 / 连接不顺滑：请重点排查并改进

目前前端已经有订单页、倒计时、支付按钮，但**钱包登录/链接体验不顺**，请你重点优化这部分。

范围：`apps/us-frontend` 中与钱包相关的代码（例如 `lib/payPolicy.ts` 以及其他 connect/switch 相关逻辑）。

请你做以下事情：

1. **梳理现有钱包流程**

   * 找出所有与：

     * 连接钱包（`connect`）
     * 切换网络到 Base（`switch network`）
     * 检查 USDC allowance 并发起 `approve`
     * 调用 CheckoutUSDC 合约
   * 有关的函数和组件；
   * 看看是否有：

     * 重复逻辑；
     * 需要多次点击才能连上；
     * 错误提示不清晰的问题。

2. **设计一个统一的「顺滑」流程**

   目标：用户在前端只需要按“正常人能理解的顺序”操作，你内部帮他处理好所有细节。

   建议统一成一个核心 helper，比如（仅示意）：

   ```ts
   async function connectAndEnsureBaseAndUsdcAllowance(...) { ... }
   ```

   流程：

   1. 如果钱包未连接 → 触发连接；
   2. 如果链不是 Base → 触发切换到 Base，失败时给出清晰提示；
   3. 检查 USDC allowance 是否足够 → 不够就发出 `approve` 交易；
   4. 最终返回：当前地址、provider、signer 等。

3. **支付函数改造为「一条龙」体验**

   对 `payPolicy`（或等价支付函数）做以下改造：

   * 先调用统一的连接助手（上一步的 helper）；
   * 然后直接调用 CheckoutUSDC 合约的支付方法；
   * 成功后：

     * 拿到 `txHash`；
     * 调用后端：

       * 如果需要先创建订单：`POST /api/v1/orders`；
       * 再调用 `POST /api/v1/orders/:orderId/submit-tx`；
   * 支付失败时：不要留在“中间状态”，要有清晰的错误提示（如：用户拒绝了交易、switch network 失败等）。

4. **登录态与订单列表的关系**

   * 确保「订单管理页」依赖的是**同一套钱包登录状态**；
   * 当钱包切换账户时：

     * 订单列表自动重新拉取当前地址的订单（`GET /api/v1/orders/my`）；
   * 当用户未连接钱包时：

     * 订单管理页显示「请先连接钱包」。

5. **输出一份总结说明**

   修改完成后，请生成一份简要说明（写在 PR 描述或单独的 Markdown 里）：

   * 钱包连接/切链/支付的最终流程图（用文字说明也行）；
   * 用户需要点击的步骤、可能遇到的错误及对应提示；
   * 前后端交互顺序（从“点击支付”到“订单出现在管理页”的全过程）。

---

### 四、总体约束（很重要）

* 不要新增复杂功能（多产品、回撤、自动赔付、多租户等），只为 v0 服务。
* 不要随意重构整个项目结构，优先在现有框架内补齐 v0 所需功能。
* 不要改动前端已有的 UI 流程（特别是订单管理页、倒计时逻辑），只改钱包连接和支付底层逻辑。
* 不要引入 Email 登录，不要开放任何“假登录”路径，只保留基于钱包的登录/鉴权。

---

> 执行顺序建议：
> 1）先对照 v0 标准列出后端差异 → 2）补齐/修正后端接口和表 → 3）优化钱包连接+支付流程 → 4）最后输出一份总结说明。

---

你可以把上面这一整段内容，原封不动丢给 Codex / Cursor / 任何代码 AI，让它**严格按这个标准给你审项目 + 改后端 + 顺钱包登录/链接**。
这样它就不会再乱飞，而是紧紧围绕「24h 强平险 v0 上线」这一件事动手。
