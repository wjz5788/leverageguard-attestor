# LiqPass 数据库与数据契约审查报告

## 执行摘要

本报告对 LiqPass 项目的数据库层进行了全面审查，重点关注数据一致性、可审计性、幂等性和可扩展性。审查范围涵盖 24 个数据库迁移文件、核心业务表结构、状态机实现和金额字段处理逻辑。

**审查时间**：2024年12月
**审查范围**：`/apps/us-backend/src/database/migrations/` 目录下的所有迁移文件及相关服务实现

## 1. 表级清单与关键约束差异

### 1.1 核心业务表结构概览

| 表名 | 主键 | 唯一约束 | 外键 | 索引数量 | 审计字段 | 状态字段 |
|------|------|----------|------|----------|----------|----------|
| `contract_events` | `id` | `(tx_hash, log_index)` ✓ | ✗ | 5 | `created_at` ✓ | ✗ |
| `orders` | `id` | `order_id` ✓ | ✗ | 4 | `created_at/updated_at` ✓ | `status` ✓ |
| `purchase_orders` | `id` | `idempotency_key` ✓ | ✗ | 5 | `created_at/updated_at` ✓ | `status` ✓ |
| `order_payments` | `id` | `tx_hash` ✓ | `order_id` ✓ | 4 | `created_at/updated_at` ✓ | `status` ✓ |
| `claims` | `id` | ✗ | `order_id` ✓ | 5 | `created_at/updated_at` ✓ | `status` ✓ |
| `payment_proofs` | `id` | `tx_hash` ✓ | `order_id` ✓ | 5 | `created_at/updated_at` ✓ | `status` ✓ |
| `audit_events` | `id` | ✗ | `order_id` ✓ | 5 | `ts` ✓ | ✗ |
| `idempotency_store` | `idempotency_key` | `idempotency_key` ✓ | ✗ | 1 | `created_at` ✓ | ✗ |

### 1.2 关键约束差异与缺失

#### 1.2.1 缺失的外键约束
- **问题**：`contract_events` 表缺少到 `orders` 表的外键约束
- **影响**：事件与订单的关联关系无法通过数据库约束保证一致性
- **文件位置**：`001_create_contract_events.sql` 第1-44行

#### 1.2.2 状态字段命名不一致
- **问题**：不同表使用不同的状态字段名称和枚举值
- **具体差异**：
  - `orders` 表：`status` (`pending`/`paid`/`failed`)
  - `purchase_orders` 表：`status` (`pending`/`paid`/`failed`)
  - `claims` 表：`status` (`pending`/`submitted`/`under_review`/`approved`/`rejected`/`paid`/`onchain_failed`)
  - `payment_proofs` 表：`status` (`pending`/`awaiting_payment`/`paid`/`failed`)
- **文件位置**：各迁移文件的表定义部分

#### 1.2.3 审计字段不一致
- **问题**：时间戳字段命名不一致
- **具体差异**：
  - `contract_events`：`created_at`
  - `audit_events`：`ts`
  - 其他表：`created_at` + `updated_at`
- **文件位置**：各迁移文件的字段定义部分

## 2. 必须补的约束与索引建议

### 2.1 外键约束补充

```sql
-- 为 contract_events 表添加外键约束
ALTER TABLE contract_events 
ADD CONSTRAINT fk_contract_events_order_id 
FOREIGN KEY (order_id) REFERENCES orders(id) 
ON DELETE RESTRICT ON UPDATE CASCADE;

-- 为 claims 表添加外键约束（如果缺失）
ALTER TABLE claims 
ADD CONSTRAINT fk_claims_order_id 
FOREIGN KEY (order_id) REFERENCES orders(id) 
ON DELETE RESTRICT ON UPDATE CASCADE;
```

**性能收益**：确保数据引用完整性，避免孤儿记录，优化关联查询性能。

### 2.2 检查约束补充

```sql
-- 金额字段非负约束
ALTER TABLE order_payments 
ADD CONSTRAINT chk_order_payments_amount_non_negative 
CHECK (amount_usdc >= 0);

ALTER TABLE purchase_orders 
ADD CONSTRAINT chk_purchase_orders_amounts_non_negative 
CHECK (principal >= 0 AND premium_usdc >= 0 AND payout_usdc >= 0);

-- 状态机合法值约束
ALTER TABLE claims 
ADD CONSTRAINT chk_claims_status_valid 
CHECK (status IN ('pending', 'submitted', 'under_review', 'approved', 'rejected', 'paid', 'onchain_failed'));
```

**性能收益**：在数据库层面保证业务规则，减少应用层验证开销。

### 2.3 复合索引优化

```sql
-- 订单查询优化索引
CREATE INDEX idx_orders_wallet_status_created 
ON orders(wallet_address, status, created_at DESC);

-- 事件查询优化索引  
CREATE INDEX idx_contract_events_tx_log_chain 
ON contract_events(tx_hash, log_index, chain_id);

-- 索赔处理优化索引
CREATE INDEX idx_claims_status_submitted 
ON claims(status, submitted_at);
```

**查询场景**：
- 用户订单列表查询（钱包+状态+时间）
- 事件幂等性检查（交易哈希+日志索引）
- 管理员索赔处理（状态+提交时间）

## 3. 金额字段统一方案与迁移策略

### 3.1 当前金额字段现状

| 表名 | 金额字段 | 数据类型 | 精度 | 存储格式 |
|------|----------|----------|------|----------|
| `contract_events` | `amount` | `TEXT` | 可变 | 原始字符串 |
| `order_payments` | `amount_min_unit` | `TEXT` | 可变 | 最小单位字符串 |
| `order_payments` | `amount_usdc` | `DECIMAL(20,8)` | 8位小数 | USDC金额 |
| `purchase_orders` | `principal` | `DECIMAL(20,8)` | 8位小数 | 本金金额 |
| `purchase_orders` | `premium_usdc` | `DECIMAL(20,8)` | 8位小数 | 保费金额 |
| `purchase_orders` | `payout_usdc` | `DECIMAL(20,8)` | 8位小数 | 赔付金额 |

### 3.2 统一方案：USDC六位最小单位整数存储

**目标格式**：所有金额字段统一为 `BIGINT` 类型，存储 USDC 最小单位（1 = 0.000001 USDC）

#### 3.2.1 迁移DDL语句

```sql
-- 步骤1：添加新的整数金额字段
ALTER TABLE contract_events ADD COLUMN amount_6d BIGINT;
ALTER TABLE order_payments ADD COLUMN amount_min_unit_6d BIGINT;
ALTER TABLE purchase_orders ADD COLUMN principal_6d BIGINT;
ALTER TABLE purchase_orders ADD COLUMN premium_usdc_6d BIGINT;
ALTER TABLE purchase_orders ADD COLUMN payout_usdc_6d BIGINT;

-- 步骤2：数据迁移（零停机）
UPDATE contract_events SET amount_6d = CAST(amount AS BIGINT) WHERE amount IS NOT NULL;
UPDATE order_payments SET amount_min_unit_6d = CAST(amount_min_unit AS BIGINT) WHERE amount_min_unit IS NOT NULL;
UPDATE purchase_orders SET 
  principal_6d = principal * 1000000,
  premium_usdc_6d = premium_usdc * 1000000,
  payout_usdc_6d = payout_usdc * 1000000;

-- 步骤3：应用层双写（过渡期）
-- 新代码同时写入新旧字段，读取优先使用新字段

-- 步骤4：移除旧字段（确认无问题后）
-- ALTER TABLE contract_events DROP COLUMN amount;
-- ALTER TABLE order_payments DROP COLUMN amount_min_unit;
-- ALTER TABLE purchase_orders DROP COLUMN principal, premium_usdc, payout_usdc;
```

#### 3.2.2 代码层适配

在 <mcsymbol name="OrderService" filename="orderService.ts" path="/Users/zhaomosheng/Desktop/LiqPass-clean/apps/us-backend/src/services/orderService.ts" startline="40" type="class">OrderService</mcsymbol> 中已实现六位精度转换：

```typescript
// 金额转换逻辑（orderService.ts 第250-260行）
const premiumUSDC6d = Math.round(p * feeRatio * 1_000_000);
const payoutUSDC6d = Math.round(p * payoutRatio * 1_000_000);
```

### 3.3 迁移策略：零停机滚动升级

1. **阶段一**：添加新字段，应用层双写
2. **阶段二**：数据迁移，验证一致性
3. **阶段三**：应用层切换到新字段
4. **阶段四**：移除旧字段（可选）

## 4. 状态机合法转移白名单

### 4.1 订单状态转移规则

**合法转移路径**：
- `pending` → `paid`（链上支付确认）
- `pending` → `failed`（支付超时或失败）
- `paid` → `active`（保险生效）
- `active` → `expired`（保险到期）
- `active` → `claimed`（发生索赔）

**代码位置**：<mcsymbol name="markPaidByWalletAndAmount" filename="orderService.ts" path="/Users/zhaomosheng/Desktop/LiqPass-clean/apps/us-backend/src/services/orderService.ts" startline="290" type="function">markPaidByWalletAndAmount</mcsymbol> 方法（第290-308行）

### 4.2 索赔状态转移规则

**合法转移路径**：
- `pending` → `submitted`（用户提交）
- `submitted` → `under_review`（管理员受理）
- `under_review` → `approved`（审核通过）
- `under_review` → `rejected`（审核拒绝）
- `approved` → `paid`（赔付完成）
- 任何状态 → `cancelled`（用户取消）

**代码位置**：<mcsymbol name="ClaimsService" filename="claimsService.ts" path="/Users/zhaomosheng/Desktop/LiqPass-clean/apps/us-backend/src/services/claimsService.ts" startline="14" type="class">ClaimsService</mcsymbol> 的 `updateClaim` 方法

### 4.3 潜在风险点

#### 4.3.1 越权状态写入风险

**风险点1**：直接数据库操作可能绕过状态机验证
- **位置**：所有涉及状态更新的服务方法
- **防护**：数据库层面添加检查约束

**风险点2**：<mcsymbol name="updateClaim" filename="claimsService.ts" path="/Users/zhaomosheng/Desktop/LiqPass-clean/apps/us-backend/src/services/claimsService.ts" startline="180" type="function">updateClaim</mcsymbol> 方法缺少严格的转移验证
- **问题**：第180-220行直接更新状态，缺少前置条件检查
- **建议**：添加状态转移验证函数

```typescript
private validateStatusTransition(current: ClaimStatus, next: ClaimStatus): boolean {
  const validTransitions = {
    pending: ['submitted', 'cancelled'],
    submitted: ['under_review', 'cancelled'],
    under_review: ['approved', 'rejected'],
    approved: ['paid'],
    // 其他状态转移规则
  };
  return validTransitions[current]?.includes(next) ?? false;
}
```

## 5. 每日对账SQL示例

### 5.1 链上事件与订单支付对账

```sql
-- 昨日链上事件与订单支付对账查询
WITH event_stats AS (
  SELECT 
    DATE(created_at) as event_date,
    COUNT(*) as total_events,
    COUNT(DISTINCT tx_hash) as unique_txs,
    SUM(CAST(amount AS DECIMAL(20,8))) as total_amount
  FROM contract_events 
  WHERE DATE(created_at) = CURRENT_DATE - INTERVAL 1 DAY
  GROUP BY DATE(created_at)
),
payment_stats AS (
  SELECT 
    DATE(created_at) as payment_date,
    COUNT(*) as total_payments,
    COUNT(DISTINCT tx_hash) as unique_payment_txs,
    SUM(amount_usdc) as total_payment_amount
  FROM order_payments 
  WHERE DATE(created_at) = CURRENT_DATE - INTERVAL 1 DAY
    AND status = 'paid'
  GROUP BY DATE(created_at)
),
order_stats AS (
  SELECT 
    DATE(created_at) as order_date,
    COUNT(*) as total_orders,
    COUNT(CASE WHEN status = 'paid' THEN 1 END) as paid_orders,
    COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_orders
  FROM orders 
  WHERE DATE(created_at) = CURRENT_DATE - INTERVAL 1 DAY
  GROUP BY DATE(created_at)
),
reconciliation AS (
  SELECT 
    e.event_date,
    e.total_events,
    p.total_payments,
    o.total_orders,
    o.paid_orders,
    o.pending_orders,
    -- 对账差异检测
    CASE 
      WHEN e.total_events != p.total_payments THEN '事件与支付数量不匹配'
      WHEN e.total_amount != p.total_payment_amount THEN '金额不匹配'
      ELSE '对账通过'
    END as reconciliation_status,
    ABS(e.total_amount - COALESCE(p.total_payment_amount, 0)) as amount_diff
  FROM event_stats e
  LEFT JOIN payment_stats p ON e.event_date = p.payment_date
  LEFT JOIN order_stats o ON e.event_date = o.order_date
)
SELECT * FROM reconciliation;
```

### 5.2 索赔处理进度对账

```sql
-- 索赔处理进度日报
SELECT 
  DATE(submitted_at) as claim_date,
  COUNT(*) as total_claims,
  COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_claims,
  COUNT(CASE WHEN status = 'submitted' THEN 1 END) as submitted_claims,
  COUNT(CASE WHEN status = 'under_review' THEN 1 END) as under_review_claims,
  COUNT(CASE WHEN status = 'approved' THEN 1 END) as approved_claims,
  COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_claims,
  COUNT(CASE WHEN status = 'paid' THEN 1 END) as paid_claims,
  SUM(CASE WHEN status = 'paid' THEN amountUSDC ELSE 0 END) as total_payout_amount,
  -- 平均处理时间（小时）
  AVG(
    CASE 
      WHEN status IN ('approved', 'rejected', 'paid') THEN
        EXTRACT(EPOCH FROM (reviewed_at - submitted_at)) / 3600
      ELSE NULL
    END
  ) as avg_processing_hours
FROM claims 
WHERE DATE(submitted_at) = CURRENT_DATE - INTERVAL 1 DAY
GROUP BY DATE(submitted_at)
ORDER BY claim_date DESC;
```

### 5.3 审计事件完整性检查

```sql
-- 审计事件完整性检查
SELECT 
  event_type,
  COUNT(*) as event_count,
  MIN(ts) as first_event,
  MAX(ts) as last_event,
  COUNT(DISTINCT order_id) as affected_orders,
  -- 检测缺失的审计事件
  CASE 
    WHEN event_type = 'order_created' THEN
      (SELECT COUNT(*) FROM orders WHERE DATE(created_at) = CURRENT_DATE - INTERVAL 1 DAY) - COUNT(*)
    WHEN event_type = 'payment_received' THEN
      (SELECT COUNT(*) FROM order_payments WHERE DATE(created_at) = CURRENT_DATE - INTERVAL 1 DAY) - COUNT(*)
    ELSE 0
  END as missing_events
FROM audit_events 
WHERE DATE(ts) = CURRENT_DATE - INTERVAL 1 DAY
GROUP BY event_type
ORDER BY event_count DESC;
```

## 6. 执行说明与建议

### 6.1 优先级实施建议

**高优先级（立即实施）**：
1. 添加缺失的外键约束
2. 实施状态机检查约束
3. 修复金额字段命名不一致问题

**中优先级（下个版本）**：
1. 金额字段统一迁移
2. 优化复合索引
3. 完善审计事件记录

**低优先级（规划中）**：
1. 数据库分区策略
2. 归档策略实施
3. 监控告警完善

### 6.2 监控指标

建议监控以下关键指标：
- 数据库约束违反次数
- 状态非法转移次数
- 对账差异金额
- 事件处理延迟

### 6.3 风险评估

**低风险**：约束添加、索引优化
**中风险**：金额字段迁移（需要充分测试）
**高风险**：生产环境数据库结构变更

## 结论

LiqPass 数据库层整体设计良好，具备较好的可审计性和幂等性基础。通过实施本报告中的建议，可以进一步提升数据一致性、查询性能和系统可靠性。建议按优先级分阶段实施改进措施。

---

**报告生成时间**：2024年12月  
**审查版本**：基于当前代码库最新状态  
**下次审查建议**：6个月后或重大功能变更后