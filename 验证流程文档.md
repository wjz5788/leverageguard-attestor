# LiqPass 订单验证系统 - 验证流程文档

## 系统架构概述

LiqPass 订单验证系统采用分布式架构，包含三个核心组件：

1. **us-frontend** (前端) - 端口 5173
   - React + TypeScript + Tailwind CSS
   - 提供订单验证器用户界面

2. **us-backend** (美国后端) - 端口 8080
   - Node.js + Express + TypeScript
   - 提供薄代理路由，转发验证请求到日本服务器
   - 管理 SQLite 数据库和证据文件存储

3. **jp-verify** (日本验证服务) - 端口 8082
   - Python + FastAPI
   - 直接调用 OKX API 进行订单验证
   - 生成可审计的证据包

## 验证流程

### 1. 用户界面交互
用户在前端页面输入以下信息：
- **订单ID (ordId)**: 例如 `2940071038556348417`
- **交易对 (instId)**: 例如 `BTC-USDT-SWAP`
- **API 密钥信息**: apiKey, secretKey, passphrase, UID(可选)
- **验证参数**: 实时模式、强制刷新、绕过缓存

### 2. 前端请求流程
```typescript
// 前端发送验证请求
POST /api/v1/verify/okx
Content-Type: application/json

{
  "ordId": "2940071038556348417",
  "instId": "BTC-USDT-SWAP",
  "live": true,
  "fresh": true,
  "noCache": true,
  "keyMode": "inline",
  "apiKey": "...",
  "secretKey": "...",
  "passphrase": "...",
  "uid": "..."
}
```

### 3. 后端代理流程
us-backend 接收到请求后：
1. **验证请求参数** - 检查必填字段和格式
2. **生成请求ID** - 用于追踪和日志记录
3. **转发到 jp-verify** - 通过 HTTP POST 转发请求
4. **处理响应** - 接收 jp-verify 的验证结果
5. **保存证据** - 将验证结果保存到文件系统和数据库
6. **返回响应** - 将结果返回给前端

### 4. 日本验证服务流程
jp-verify 接收到请求后：
1. **调用 OKX API** - 使用提供的 API 密钥调用订单详情和持仓接口
2. **数据归一化** - 将原始数据转换为标准格式
3. **强平判定** - 分析订单状态和持仓信息，判断是否被强平
4. **生成证据包** - 创建包含原始数据、归一化数据和哈希的证据包
5. **返回完整响应** - 包含验证结果和证据信息

### 5. 证据存储流程
验证完成后，系统会：
1. **生成证据ID** - 格式: `evi_20251104_12345678`
2. **保存到文件系统** - `reports/evidence/2024-01-15/evi_xxx.json`
3. **保存根哈希文件** - 同时保存 `.root` 文件用于快速检索
4. **写入数据库** - 将验证摘要保存到 SQLite 数据库

## 数据流图

```
用户界面 (前端) → us-backend (代理) → jp-verify (验证) → OKX API
     ↓              ↓                    ↓              ↓
   输入表单       参数验证             调用交易所      返回原始数据
     ↓              ↓                    ↓              ↓
   显示结果 ← 保存证据 ← 生成证据包 ← 数据归一化 ← 处理响应
```

## 关键接口定义

### jp-verify 验证接口
```bash
POST /api/verify
Content-Type: application/json

# 请求体
{
  "exchange": "okx",
  "ordId": "2940071038556348417",
  "instId": "BTC-USDT-SWAP",
  "live": true,
  "fresh": true,
  "noCache": true,
  "keyMode": "inline",
  "apiKey": "...",
  "secretKey": "...",
  "passphrase": "...",
  "uid": "...",
  "clientMeta": {
    "source": "us-backend",
    "requestId": "uuid-xxx"
  }
}

# 响应体
{
  "meta": {...},
  "normalized": {
    "order": {...},
    "position": {
      "liquidated": true,      // 关键字段
      "liquidatedAt": "...",
      "reason": "forced-liquidation"
    }
  },
  "raw": {...},
  "evidence": {
    "root": "0x...",
    "evidenceId": "evi_..."
  },
  "perf": {...},
  "error": null
}
```

### us-backend 代理接口
```bash
POST /api/v1/verify/okx
# 同上，但响应会额外包含 evidenceId 字段
```

## 数据库表结构

### orders 表 (验证记录)
- `id` - 主键
- `user_id` - 用户ID
- `exchange` - 交易所
- `ord_id` - 订单ID
- `inst_id` - 交易对
- `verified_at` - 验证时间
- `liquidated` - 是否强平
- `reason` - 强平原因
- `evidence_id` - 证据ID

### api_keys 表 (API密钥)
- `id` - 主键
- `user_id` - 用户ID
- `exchange` - 交易所
- `key_alias` - 密钥别名
- `enc_payload` - 加密的密钥信息
- `created_at` - 创建时间
- `last_used_at` - 最后使用时间

### audit_logs 表 (审计日志)
- `id` - 主键
- `topic` - 日志主题
- `ref_id` - 关联ID
- `created_at` - 创建时间
- `payload_json` - 日志内容

## 证据文件格式

### JSON 证据文件
```json
{
  "evidenceId": "evi_20241104_12345678",
  "requestId": "uuid-xxx",
  "timestamp": "2024-01-15T10:30:00Z",
  "status": 200,
  "request": {
    "ordId": "2940071038556348417",
    "instId": "BTC-USDT-SWAP",
    "live": true,
    "fresh": true
    // 敏感字段已被移除
  },
  "response": {
    "meta": {...},
    "normalized": {...},
    "evidence": {
      "root": "0x...",
      "evidenceId": "evi_..."
    }
  }
}
```

### 根哈希文件
```
0x5f6b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8
```

## 错误处理

### 常见错误代码
- `AUTH_ERROR` - 认证失败
- `NOT_FOUND` - 订单不存在
- `RATE_LIMIT` - 频率限制
- `REMOTE_4XX` - 远程服务客户端错误
- `REMOTE_5XX` - 远程服务服务器错误
- `TIMEOUT` - 请求超时

### 错误响应格式
```json
{
  "error": {
    "code": "AUTH_ERROR",
    "msg": "API 密钥认证失败",
    "hint": "请检查您的 API 密钥、Secret 和 Passphrase 是否正确"
  }
}
```

## 性能监控

### 关键指标
- **总耗时**: 从请求到响应的总时间
- **OKX API 耗时**: 调用交易所 API 的时间
- **缓存命中率**: 缓存使用情况
- **错误率**: 各类型错误的统计

### 性能日志
```json
{
  "okxRttMs": 420,
  "totalMs": 650,
  "cache": false,
  "rateLimit": {
    "remaining": 98,
    "resetSec": 1
  }
}
```

## 部署和测试

### 本地开发环境
1. **启动 jp-verify**: `cd jp-verify && ./start.sh`
2. **启动 us-backend**: `cd us-backend && npm run dev`
3. **启动 us-frontend**: `cd us-frontend && npm run dev`

### 自测脚本
```bash
./test-verification.sh
```

### 手动测试命令
```bash
# 健康检查
curl http://127.0.0.1:8082/healthz
curl http://127.0.0.1:8080/api/v1/health
curl http://127.0.0.1:8080/api/v1/verify/health

# 订单验证测试
curl -X POST http://127.0.0.1:8080/api/v1/verify/okx \
  -H "Content-Type: application/json" \
  -d '{
    "ordId": "2940071038556348417",
    "instId": "BTC-USDT-SWAP",
    "live": true,
    "fresh": true,
    "noCache": true,
    "keyMode": "inline",
    "apiKey": "your-api-key",
    "secretKey": "your-secret",
    "passphrase": "your-passphrase"
  }'
```

## 迁移到生产环境

### 日本服务器部署
1. 将 jp-verify 代码部署到日本服务器
2. 配置 systemd 服务自动启动
3. 设置防火墙规则，仅允许美国后端 IP 访问
4. 配置 HTTPS 和认证

### 美国后端配置更新
```env
JP_VERIFY_BASE_URL=https://jp-server:8082
JP_VERIFY_HMAC_SECRET=shared-secret-key
```

### 监控和告警
- 设置健康检查监控
- 配置性能指标收集
- 建立错误告警机制

---

*本文档最后更新: 2024年1月15日*