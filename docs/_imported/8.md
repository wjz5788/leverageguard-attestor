明白，你想区分 **线上（链上/用户可交互）** 和 **线下（本地验证/后台逻辑）** 部分。根据我们前面的设计，我帮你梳理如下：

------

## **1️⃣ 线上部分（用户可交互 / 链上操作）**

### **包括：**

1. **前端网页（`index.html` 或 React/Vue 前端）**
   - 用户连接钱包（MetaMask）
   - 用户选择套餐（本金、杠杆、保费）
   - 展示链上状态、赔付结果
   - 提交 OKX 订单验证请求（通过后端 API）
2. **智能合约（`LeverageGuard.sol`）**
   - **核心功能**：
     - `addFunds` / `withdraw` → 管理合约资金池
     - `markLiquidation` → 标记爆仓事件
     - `executePayout` → 执行赔付
     - 白名单/黑名单管理
   - **事件触发**：
     - `verifyAndEmitEvent` → 记录用户订单验证结果
     - `PayoutExecuted` → 赔付事件
3. **链上事件存证（通过 Web3.py / Web3.js 调用）**
   - 后端将验证结果发送到链上（`verifyAndEmitEvent`），用户钱包可看到事件日志
   - 防篡改存证，确保赔付依据链上事件

✅ **特点**：

- 用户可直接看到操作结果
- 依赖区块链网络
- 必须上线部署

------

## **2️⃣ 线下部分（后台验证 / 本地逻辑）**

### **包括：**

1. **Python 后端（Flask / FastAPI）**
   - `/api/buy_plan` → 记录用户选择的本金/杠杆/保费
   - `/api/verify_order` → 验证用户提交的 OKX 订单
   - 计算赔付金额（本金 × 杠杆 × 保费）
   - 与链上交互，但核心计算逻辑和 API 请求在线下执行
2. **交易所 API 调用（OKX、Binance、Gate 等）**
   - 查询订单详情和成交记录
   - 判断是否爆仓
   - **仅能查询用户自己账户数据**
   - 防止用户用他人订单骗赔
3. **本地存储 / 缓存**
   - 用户购买套餐信息
   - 用户验证记录
   - 可存数据库或本地 JSON 文件

✅ **特点**：

- 用户无需区块链操作即可完成验证
- 可以做更复杂的逻辑（多交易所、批量验证、统计）
- 不直接消耗链上 Gas

------

## **3️⃣ 对应到代码文件**

| 代码文件                                    | 类型      | 作用                                           |
| ------------------------------------------- | --------- | ---------------------------------------------- |
| `index.html`                                | 线上      | 前端交互界面，钱包连接、套餐选择、显示验证结果 |
| `LeverageGuard.sol`                         | 线上      | 智能合约，存储资金、执行赔付、事件存证         |
| `event_listener.py`                         | 线上/线下 | 监听链上事件并处理自动赔付                     |
| `okx_verification.py` / `verify_order` 模块 | 线下      | 调用 OKX API 验证订单、计算赔付金额            |
| `app.py` / Flask 后端                       | 线下      | 提供前端 API 接口，调用验证模块和链上事件      |
| `user_plans.json` 或数据库                  | 线下      | 存储用户套餐和验证记录                         |

------

总结一句话：

- **线上部分** = 用户可见/区块链可触发/钱包可操作 → 前端 + 智能合约 + 链上事件
- **线下部分** = 后端验证、计算、缓存 → Python 后端 + 交易所 API + 本地存储

------

如果你需要，我可以帮你画一个 **清晰的线上/线下流程图**，用箭头标明哪些操作在链上，哪些在本地，方便团队开发和部署。

你希望我画吗？

```
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>简易爆仓保险计算器</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            box-sizing: border-box;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #45a049;
        }
        #result {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .error {
            color: red;
        }
    </style>
</head>
<body>
    <h2>爆仓保险计算器</h2>
    
    <div>
        <label for="principal">本金 (USDT，范围：50-500):</label>
        <input type="number" id="principal" min="50" max="500" step="0.01" value="100">
    </div>
    
    <div>
        <label for="leverage">杠杆倍数:</label>
        <input type="number" id="leverage" min="1" max="200" value="20">
    </div>
    
    <button onclick="calculateInsurance()">计算</button>
    
    <div id="result">
        <h3>计算结果将显示在这里</h3>
    </div>
    
    <script>
        function calculateInsurance() {
            // 获取输入值
            const principal = parseFloat(document.getElementById('principal').value);
            const leverage = parseFloat(document.getElementById('leverage').value);
            const resultDiv = document.getElementById('result');
            
            // 输入验证
            if (isNaN(principal) || isNaN(leverage) || principal < 50 || principal > 500) {
                resultDiv.innerHTML = '<p class="error">错误: 请输入有效的本金（50-500 USDT）和杠杆倍数！</p>';
                return;
            }
            
            // 计算保费
            const basePremiumRatio = 0.05 + (leverage - 20) * 0.001 + (principal / 500) * 0.02;
            const premiumRatio = Math.min(0.15, basePremiumRatio);
            const premium = premiumRatio * principal;
            
            // 计算赔付比例
            const basePayoutRatio = 0.25 + (leverage - 50) * 0.005 - (principal / 500) * 0.1;
            const payoutRatio = Math.min(0.5, Math.max(0.1, basePayoutRatio));
            const payout = payoutRatio * principal;
            
            // 显示结果
            resultDiv.innerHTML = `
                <h3>计算结果</h3>
                <p>本金: ${principal.toFixed(2)} USDT</p>
                <p>杠杆: ${leverage}x</p>
                <p>保费额: ${premium.toFixed(2)} USDT</p>
                <p>赔付比例: ${(payoutRatio * 100).toFixed(1)}%</p>
                <p>赔付额: ${payout.toFixed(2)} USDT</p>
            `;
            
            // 控制台输出，便于调试
            console.log('计算参数:', { principal, leverage });
            console.log('计算结果:', { premium, payoutRatio, payout });
        }
        
        // 初始加载时自动计算一次
        window.onload = function() {
            calculateInsurance();
        };
    </script>
</body>
</html>
```

明白，你希望直接拿到一个**可落地上线的实操方案**，把前端、后端、链上、OKX验证、赔付逻辑整合起来。我帮你梳理成 **端到端实施方案**，可直接落地。

------

## **1️⃣ 项目整体思路**

### **流程概览**

1. 用户打开前端网页。
2. 钱包连接（MetaMask 或其他支持 Arbitrum Sepolia 的钱包）。
3. 用户选择套餐（本金、杠杆、保费）。
4. 系统记录用户购买信息（后端 Python 或数据库）。
5. 用户提供交易所 API Key（如 OKX）。
6. 用户提交订单号。
7. 后端 Python 模块验证订单是否爆仓。
8. 验证结果上链：调用 `verifyAndEmitEvent` 事件。
9. 用户确认后，调用 `executePayout` 执行实际赔付。
10. 前端展示链上事件和赔付状态。

------

## **2️⃣ 前端实现（核心）**

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LeverageGuard</title>
<script src="https://cdn.jsdelivr.net/npm/web3@1.9.0/dist/web3.min.js"></script>
</head>
<body>
<h2>LeverageGuard 杠杆保障</h2>

<!-- 钱包连接 -->
<button id="connectWallet">连接钱包</button>
<p id="walletAddress"></p>

<!-- 用户套餐选择 -->
<label>本金 USDC: <input type="number" id="principal" value="100"></label><br>
<label>杠杆倍数: <input type="number" id="leverage" value="10"></label><br>
<label>保费比例 %: <input type="number" id="insurance" value="2"></label><br>
<button id="buyPlan">购买套餐</button>

<!-- API Key 输入 -->
<h3>交易所API验证</h3>
<label>OKX API Key: <input type="text" id="apiKey"></label><br>
<label>Secret: <input type="text" id="apiSecret"></label><br>
<label>Passphrase: <input type="text" id="passphrase"></label><br>
<label>订单ID: <input type="text" id="orderId"></label><br>
<button id="verifyOrder">验证订单</button>

<!-- 显示结果 -->
<pre id="result"></pre>

<script>
let web3;
let userAccount;

async function connectWallet() {
    if (window.ethereum) {
        web3 = new Web3(window.ethereum);
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAccount = accounts[0];
        document.getElementById('walletAddress').innerText = userAccount;
    } else {
        alert("请安装 MetaMask 或兼容钱包");
    }
}

document.getElementById('connectWallet').onclick = connectWallet;

document.getElementById('buyPlan').onclick = async () => {
    const principal = document.getElementById('principal').value;
    const leverage = document.getElementById('leverage').value;
    const insurance = document.getElementById('insurance').value;

    // 这里可以发送到后端记录购买信息
    fetch("/api/buy_plan", {
        method: "POST",
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ wallet: userAccount, principal, leverage, insurance })
    }).then(res => res.json())
      .then(data => alert("购买成功: " + JSON.stringify(data)));
};

document.getElementById('verifyOrder').onclick = async () => {
    const apiKey = document.getElementById('apiKey').value;
    const apiSecret = document.getElementById('apiSecret').value;
    const passphrase = document.getElementById('passphrase').value;
    const orderId = document.getElementById('orderId').value;

    fetch("/api/verify_order", {
        method: "POST",
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ wallet: userAccount, apiKey, apiSecret, passphrase, orderId })
    }).then(res => res.json())
      .then(data => document.getElementById('result').innerText = JSON.stringify(data, null, 2));
};
</script>
</body>
</html>
```

------

## **3️⃣ 后端 Python 实现（Flask + Web3 + OKX）**

```python
from flask import Flask, request, jsonify
from web3 import Web3
import json
import requests, hmac, hashlib, base64
from datetime import datetime, timezone

app = Flask(__name__)

# ====== 链上配置 ======
RPC_URL = "https://arbitrum-sepolia.blockpi.network/v1/rpc/public"
CONTRACT_ADDRESS = "0xYourContractAddress"
OWNER_ADDRESS = "0xYourOwnerAddress"
OWNER_PRIVATE_KEY = "0xYourOwnerPrivateKey"
w3 = Web3(Web3.HTTPProvider(RPC_URL))

with open("LeverageGuard_abi.json") as f:
    contract_abi = json.load(f)
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=contract_abi)

# ====== 用户套餐存储 ======
user_plans = {}

# ====== OKX 验证函数 ======
def okx_sign(timestamp, method, request_path, body, secret):
    msg = f"{timestamp}{method.upper()}{request_path}{body or ''}"
    return base64.b64encode(hmac.new(secret.encode(), msg.encode(), hashlib.sha256).digest()).decode()

def okx_request(api_key, api_secret, passphrase, method, path, params=None):
    timestamp = datetime.utcnow().isoformat("T", "milliseconds") + "Z"
    query = "?" + "&".join(f"{k}={v}" for k,v in (params or {}).items()) if params else ""
    full_path = path + query
    sign = okx_sign(timestamp, method, full_path, "", api_secret)
    headers = {
        "OK-ACCESS-KEY": api_key,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": passphrase,
        "Content-Type": "application/json"
    }
    url = "https://www.okx.com" + full_path
    r = requests.request(method, url, headers=headers)
    return r.json()

# ====== 链上事件发送 ======
def send_to_contract_event(user_wallet, order_id, payout_amount, verified):
    tx = contract.functions.verifyAndEmitEvent(user_wallet, order_id, payout_amount, verified).buildTransaction({
        'from': OWNER_ADDRESS,
        'nonce': w3.eth.get_transaction_count(OWNER_ADDRESS),
        'gas': 200000
    })
    signed_tx = w3.eth.account.sign_transaction(tx, private_key=OWNER_PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
    return tx_hash.hex()

# ====== API: 购买套餐 ======
@app.route("/api/buy_plan", methods=["POST"])
def buy_plan():
    data = request.json
    wallet = data["wallet"]
    user_plans[wallet] = {
        "principal": float(data["principal"]),
        "leverage": float(data["leverage"]),
        "insurance": float(data["insurance"])
    }
    return jsonify({"status": "ok", "plan": user_plans[wallet]})

# ====== API: 验证订单 ======
@app.route("/api/verify_order", methods=["POST"])
def verify_order():
    data = request.json
    wallet = data["wallet"]
    api_key = data["apiKey"]
    api_secret = data["apiSecret"]
    passphrase = data["passphrase"]
    order_id = data["orderId"]

    order_info = okx_request(api_key, api_secret, passphrase, "GET", "/api/v5/trade/order", {"ordId": order_id})

    if order_info.get("code") != "0":
        return jsonify({"status": "fail", "error": order_info.get("msg")})

    pnl = float(order_info["data"][0].get("fillPnl", 0))
    is_liquidated = pnl < 0
    plan = user_plans.get(wallet, {"principal": 100, "leverage": 10, "insurance": 2})
    payout_amount = abs(pnl) * plan["leverage"] * plan["insurance"] / 100

    tx_hash = send_to_contract_event(wallet, int(order_id), payout_amount, is_liquidated)

    return jsonify({
        "wallet": wallet,
        "order_id": order_id,
        "pnl": pnl,
        "is_liquidated": is_liquidated,
        "payout_amount": payout_amount,
        "tx_hash": tx_hash
    })

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
```

------

## **4️⃣ 上线实操步骤**

1. 部署 **LeverageGuard.sol** 到 Arbitrum Sepolia 测试网。
2. 保存 ABI 到 `LeverageGuard_abi.json`。
3. 启动 Flask 后端 (`python3 app.py`)。
4. 前端通过 `fetch` 调用 `/api/buy_plan` 和 `/api/verify_order`。
5. 用户连接钱包购买套餐。
6. 用户输入 OKX API Key、订单号，触发验证。
7. 后端调用链上事件 `verifyAndEmitEvent` 存证。
8. 用户确认后，调用 `executePayout` 真正打款。
9. 可扩展：添加 Binance、Gate 验证模块。

------

✅ **特点**：

- 前端用户交互清晰
- 后端独立验证交易所数据
- 链上事件存证防篡改
- 赔付逻辑可控，支持人工确认或自动支付
- 模块化设计，易扩展

------

我可以帮你再画一张 **完整架构图**，标明 **前端→后端→链上→赔付流程**，让你一眼就明白上线方案。

你希望我画吗？

明白，我帮你生成一个 **整合后的模块化版本**，包含：

1. **智能合约**：新增链上验证事件 `PayoutVerified`，拆分验证与赔付逻辑。
2. **OKX验证模块**：用户绑定钱包，验证订单后发送链上事件。
3. **模块化结构**：前端/后端/链上分离，便于扩展到 Binance、Gate 等交易所。

------

## **1️⃣ 智能合约：LeverageGuard.sol**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract LeverageGuard {
    address public owner;
    uint256 public contractBalance;

    mapping(address => uint256) public userBalances;
    mapping(address => bool) public whitelistedUsers;
    mapping(address => bool) public blacklistedUsers;

    uint256 public feePercentage; // 手续费上限5%
    uint256 public liquidationThreshold; // 0-100%

    // 链上验证事件
    event PayoutVerified(
        address indexed user,
        uint256 indexed orderId,
        uint256 payoutAmount,
        bool verified
    );

    // 赔付事件
    event PayoutExecuted(address indexed user, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor() {
        owner = msg.sender;
        feePercentage = 5; 
        liquidationThreshold = 80; // 默认80%
    }

    // 添加资金到合约
    function addFunds() external payable onlyOwner {
        contractBalance += msg.value;
    }

    // 提取资金
    function withdraw(uint256 amount) external onlyOwner {
        require(amount <= contractBalance, "Insufficient balance");
        contractBalance -= amount;
        payable(owner).transfer(amount);
    }

    // 链上存证验证结果，不直接打钱
    function verifyAndEmitEvent(
        address user,
        uint256 orderId,
        uint256 payoutAmount,
        bool verified
    ) external onlyOwner {
        emit PayoutVerified(user, orderId, payoutAmount, verified);
    }

    // 执行实际赔付
    function executePayout(address user, uint256 amount) external onlyOwner {
        require(userBalances[user] + amount <= contractBalance, "Insufficient funds");
        userBalances[user] += amount;
        contractBalance -= amount;
        payable(user).transfer(amount);
        emit PayoutExecuted(user, amount);
    }

    // 查询用户余额
    function getUserBalance(address user) external view returns (uint256) {
        return userBalances[user];
    }

    receive() external payable {
        contractBalance += msg.value;
    }
}
```

------

## **2️⃣ OKX验证模块（Python示例）**

```python
from web3 import Web3
import requests
import hmac, base64, hashlib
from datetime import datetime, timezone

# ====== 用户配置 ======
RPC_URL = "https://arbitrum-sepolia.blockpi.network/v1/rpc/public"
CONTRACT_ADDRESS = "0xYourContractAddress"
OWNER_ADDRESS = "0xYourOwnerAddress"
OWNER_PRIVATE_KEY = "0xYourOwnerPrivateKey"

w3 = Web3(Web3.HTTPProvider(RPC_URL))
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=contract_abi)

# ====== OKX API 验证 ======
def okx_sign(timestamp, method, request_path, body, secret):
    msg = f"{timestamp}{method.upper()}{request_path}{body or ''}"
    return base64.b64encode(hmac.new(secret.encode(), msg.encode(), hashlib.sha256).digest()).decode()

def okx_request(api_key, api_secret, passphrase, method, path, params=None):
    timestamp = datetime.utcnow().isoformat("T", "milliseconds") + "Z"
    query = "?" + "&".join(f"{k}={v}" for k,v in (params or {}).items()) if params else ""
    full_path = path + query
    sign = okx_sign(timestamp, method, full_path, "", api_secret)
    headers = {
        "OK-ACCESS-KEY": api_key,
        "OK-ACCESS-SIGN": sign,
        "OK-ACCESS-TIMESTAMP": timestamp,
        "OK-ACCESS-PASSPHRASE": passphrase,
        "Content-Type": "application/json"
    }
    url = "https://www.okx.com" + full_path
    r = requests.request(method, url, headers=headers)
    return r.json()

# ====== 链上存证函数 ======
def send_to_contract_event(user_wallet, order_id, payout_amount, verified):
    tx = contract.functions.verifyAndEmitEvent(
        user_wallet, order_id, payout_amount, verified
    ).buildTransaction({
        'from': OWNER_ADDRESS,
        'nonce': w3.eth.get_transaction_count(OWNER_ADDRESS),
        'gas': 200000
    })
    signed_tx = w3.eth.account.sign_transaction(tx, private_key=OWNER_PRIVATE_KEY)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
    print(f"✅ 链上事件发送成功, tx_hash: {tx_hash.hex()}")

# ====== 核心验证逻辑 ======
def verify_user_order(user_wallet, order_id, api_key, api_secret, passphrase):
    order_info = okx_request(api_key, api_secret, passphrase, "GET", "/api/v5/trade/order", {"ordId": order_id})
    
    # 简化示例：判断是否爆仓
    pnl = float(order_info["data"][0].get("fillPnl", 0))
    is_liquidated = pnl < 0  # 或者其他规则
    
    payout_amount = abs(pnl) * 1.25  # 假设赔付逻辑
    send_to_contract_event(user_wallet, order_id, payout_amount, is_liquidated)
```

------

## **3️⃣ 模块化设计建议**

- **前端**：钱包连接、选择套餐、显示验证结果、确认赔付
- **后端**：OKX/Binance/Gate验证模块
- **链上**：`verifyAndEmitEvent` 链上存证、`executePayout` 实际转账
- **数据存储**：用户购买套餐、验证结果、历史赔付
- **安全**：每个用户API Key独立验证、防冒领、链上事件存证

------

如果你愿意，我可以帮你 **画一张完整架构图**，显示用户前端、后端验证模块、链上事件和赔付流程，这样更清晰直观。

你希望我画吗？

# 计算保费额（USDT）
def calculate_premium(principal, leverage):
    base_ratio = 0.05 + (leverage - 20) * 0.001 + (principal / 500) * 0.02
    premium_ratio = min(0.15, base_ratio)
    return premium_ratio * principal

# 计算赔付比例（返回小数）
def calculate_payout_ratio(principal, leverage):
    base_ratio = 0.25 + (leverage - 50) * 0.005 - (principal / 500) * 0.1
    return min(0.5, max(0.1, base_ratio))

# 计算赔付额（USDT）
def calculate_payout(principal, leverage):
    ratio = calculate_payout_ratio(principal, leverage)
    return ratio * principal

function calculateInsurance() {
    // 获取输入值
    const principal = parseFloat(document.getElementById('principal').value);
    const leverage = parseFloat(document.getElementById('leverage').value);
    
    // 输入验证
    if (isNaN(principal) || isNaN(leverage) || principal < 50 || principal > 500) {
        // 显示错误信息
        return;
    }
    
    // 计算保费（与后端公式完全一致）
    const basePremiumRatio = 0.05 + (leverage - 20) * 0.001 + (principal / 500) * 0.02;
    const premiumRatio = Math.min(0.15, basePremiumRatio);
    const premium = premiumRatio * principal;
    
    // 计算赔付比例和赔付额（与后端公式完全一致）
    const basePayoutRatio = 0.25 + (leverage - 50) * 0.005 - (principal / 500) * 0.1;
    const payoutRatio = Math.min(0.5, Math.max(0.1, basePayoutRatio));
    const payout = payoutRatio * principal;
    
    // 显示结果
    // 控制台调试输出
}