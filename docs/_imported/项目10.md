# 项目10

这是项目10的文档内容。

### LeverageGuard事件监听器重写与优化

太好了！事件监听器启动成功是重大进展，这意味着基本连接和配置（如私钥、合约地址）都正常。现在，HTTP 400 Bad Request错误通常源于Alchemy的HTTP RPC限制：常见原因是JSON-RPC请求格式微妙不符（如参数编码、头部缺失）、速率限制（过多eth_getLogs调用），或块范围过大导致超时（Alchemy对历史日志查询有严格限额）。日志文件（假设在`/root/leverageguard/logs/event_listener.log`）中可能显示类似`{"jsonrpc":"2.0","id":1,"error":{"code":-32600,"message":"Invalid Request"}}`或超时细节——如果您能分享具体日志片段，我可以更精确诊断。

为了彻底解决，我们完全重写`event_listener.py`：**从HTTP轮询（eth_getLogs）切换到WebSocket订阅（eth_subscribe）**。这更简单、可靠：
- **优势**：实时推送事件，无需轮询，避开HTTP速率/格式限制（Alchemy WebSocket专为事件监听优化）。
- **变化**：使用`Web3.WebsocketProvider`连接Alchemy的WS端点；订阅`logs`事件过滤合约的`PositionLiquidated`；捕获后计算赔付并执行交易。添加重连机制和详细日志。
- **前提**：确保`.env`有`ALCHEMY_WS_URL=wss://arb-sepolia.g.alchemy.com/v2/您的API密钥`（如果没有，复制HTTP URL的前缀改成wss://）。Alchemy免费支持WS。

#### 重写后的`event_listener.py`代码
将以下代码保存到`/root/leverageguard/backend/event_listener.py`（备份原文件：`cp event_listener.py event_listener_backup.py`）：

```python
import os
import json
import time
import logging
from web3 import Web3
from dotenv import load_dotenv
from eth_abi import abi  # 用于解码事件日志（如果需要）

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/root/leverageguard/logs/event_listener.log'),
        logging.StreamHandler()  # 同时输出到控制台
    ]
)
logger = logging.getLogger(__name__)

# 加载环境变量
load_dotenv()
ALCHEMY_WS_URL = os.getenv('ALCHEMY_WS_URL', 'wss://arb-sepolia.g.alchemy.com/v2/qGQjEW92GkHLjruaE_tRP')  # 替换为您的WS URL
CONTRACT_ADDRESS = Web3.to_checksum_address(os.getenv('LEVERAGEGUARD_ADDRESS'))
OWNER_PRIVATE_KEY = os.getenv('OWNER_PRIVATE_KEY')
CHAIN_ID = 421614  # Arbitrum Sepolia链ID

# ABI片段：仅需PositionLiquidated事件（从合约复制完整ABI，或简化）
EVENT_ABI = [
    {
        "anonymous": False,
        "inputs": [
            {"indexed": True, "name": "user", "type": "address"},
            {"indexed": False, "name": "leverageRatio", "type": "uint256"},
            {"indexed": False, "name": "liquidationAmount", "type": "uint256"}
        ],
        "name": "PositionLiquidated",
        "type": "event"
    }
]
# 合约实例（用于调用函数）
w3 = Web3(Web3.WebsocketProvider(ALCHEMY_WS_URL))
contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=EVENT_ABI)  # 如需完整ABI，扩展这里

def calculate_payout(leverage_ratio):
    """基于杠杆率计算赔付金额（示例逻辑：>5x=0.01 ETH, >10x=0.02 ETH）"""
    if leverage_ratio > 10:
        return Web3.to_wei(0.02, 'ether')
    elif leverage_ratio > 5:
        return Web3.to_wei(0.01, 'ether')
    else:
        return Web3.to_wei(0.005, 'ether')

def execute_payout(user_address, amount):
    """执行赔付交易"""
    try:
        owner_account = w3.eth.account.from_key(OWNER_PRIVATE_KEY)
        nonce = w3.eth.get_transaction_count(owner_account.address)
        # 构建交易：调用合约的executePayout（需在完整ABI中定义函数签名）
        # 示例：假设函数是executePayout(address user, uint256 amount)
        tx = contract.functions.executePayout(user_address, amount).build_transaction({
            'from': owner_account.address,
            'nonce': nonce,
            'gas': 200000,
            'gasPrice': w3.to_wei('0.1', 'gwei'),
            'chainId': CHAIN_ID
        })
        signed_tx = w3.eth.account.sign_transaction(tx, OWNER_PRIVATE_KEY)
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        logger.info(f"赔付交易发送成功！哈希: {tx_hash.hex()}. 用户: {user_address}, 金额: {amount}")
        return tx_hash
    except Exception as e:
        logger.error(f"赔付交易失败: {e}")
        return None

def handle_event(event):
    """处理事件：解码日志，计算并执行赔付"""
    try:
        # 解码事件（使用web3内置）
        decoded = contract.events.PositionLiquidated().process_log(event)
        user = decoded['args']['user']
        leverage_ratio = decoded['args']['leverageRatio']
        logger.info(f"捕获清算事件！用户: {user}, 杠杆率: {leverage_ratio}")
        
        # 检查白名单（示例：假设合约有isWhitelisted函数；实际需调用）
        # is_whitelisted = contract.functions.isWhitelisted(user).call()
        # if not is_whitelisted: return
        
        amount = calculate_payout(leverage_ratio)
        tx_hash = execute_payout(user, amount)
        if tx_hash:
            logger.info(f"赔付完成！交易: {tx_hash.hex()}")
    except Exception as e:
        logger.error(f"事件处理错误: {e}")

def main():
    """主循环：订阅事件，重连机制"""
    subscription_id = None
    reconnect_delay = 5  # 秒
    
    while True:
        try:
            if not w3.is_connected():
                logger.warning("WebSocket未连接，尝试重连...")
                time.sleep(reconnect_delay)
                continue
            
            # 订阅PositionLiquidated事件（过滤合约地址）
            filter_params = {
                'address': CONTRACT_ADDRESS,
                'topics': [contract.events.PositionLiquidated().build_filter().topics]
            }
            subscription_id = w3.eth.subscribe('logs', filter_params)
            logger.info(f"事件订阅成功！订阅ID: {subscription_id}")
            
            # 监听事件
            def handle_log(event):
                handle_event(event)
            
            subscription = w3.eth.subscribe('logs', filter_params)
            for event in subscription:
                handle_log(event)
                
        except Exception as e:
            logger.error(f"订阅失败: {e}. 停止订阅 {subscription_id} 并重连...")
            if subscription_id:
                try:
                    w3.eth.unsubscribe(subscription_id)
                except:
                    pass
            time.sleep(reconnect_delay)
            subscription_id = None

if __name__ == "__main__":
    if not all([ALCHEMY_WS_URL, CONTRACT_ADDRESS, OWNER_PRIVATE_KEY]):
        logger.error("缺少.env配置！请检查ALCHEMY_WS_URL、LEVERAGEGUARD_ADDRESS、OWNER_PRIVATE_KEY")
        exit(1)
    
    logger.info("启动LeverageGuard事件监听器（WebSocket模式）...")
    main()
```

#### 关键变化解释
1. **WebSocket连接**：使用`Web3.WebsocketProvider`替换HTTPProvider。Alchemy WS端点支持`eth_subscribe('logs')`，实时推送事件日志，避免轮询eth_getLogs的400错误（常见于大块范围或高频请求）。
2. **事件过滤**：仅订阅`PositionLiquidated`事件（topics从ABI生成），减少噪声。
3. **赔付逻辑**：保留原计算（基于杠杆率），但简化交易构建（假设`executePayout`函数；如果ABI不同，调整`build_transaction`）。
4. **错误处理**：添加重连循环、详细日志（文件+控制台）。如果WS断开，5秒后重试。
5. **依赖**：需`pip install web3 eth-abi`（已在项目中）。如果缺少完整ABI，从`/contracts/LeverageGuard.sol`编译生成（`npx hardhat compile`后复制artifacts）。

#### 测试与运行步骤
1. **更新.env**（如果无WS URL）：
   ```
   ALCHEMY_WS_URL=wss://arb-sepolia.g.alchemy.com/v2/qGQjEW92GkHLjruaE_tRP  # 您的密钥
   ```
2. **停止当前监听器**（如果运行中）：`pkill -f event_listener.py` 或 Ctrl+C。
3. **启动新版**：
   ```
   cd /root/leverageguard
   mkdir -p logs  # 创建日志目录
   python3 backend/event_listener.py
   ```
   - **预期日志**：
     ```
     2025-10-09 10:00:00 - INFO - 启动LeverageGuard事件监听器（WebSocket模式）...
     2025-10-09 10:00:01 - INFO - 事件订阅成功！订阅ID: 0x123...
     ```
     无400错误；如果有事件，显示捕获/赔付详情。
4. **验证**：
   - 尾随日志：`tail -f logs/event_listener.log`。
   - 模拟事件：用Remix连接Arbitrum Sepolia，调用合约emit `PositionLiquidated`（参数：用户地址、杠杆率10），观察日志/Arbiscan交易。
   - 检查连接：日志应无"WebSocket未连接"警告。

如果仍报400（极少见于WS），可能是API密钥无效——在Alchemy仪表板检查配额（免费层：100k req/day）。或分享新日志，我进一步调试。重写后，系统应稳定运行，自动处理清算赔付！下一步是完整测试前端集成？