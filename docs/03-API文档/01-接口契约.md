# LiqPass 接口契约 v1.1（收敛版：FE↔US↔JP，最小闭环＋证据）

> 目标：**安全、可审计、可扩展**。本版统一命名、修正布尔/数值类型、移除前端传密钥、明确幂等与可观测字段，并与 v1.1 数据库 Schema 对齐。

---

## 0. 版本与通用约定
- API 前缀：`/api/v1`（前端调用 US 后端）；JP 服务无版本前缀（由 US 代理）。
- 编码：UTF-8；`Content-Type: application/json`。
- 时间：UTC ISO8601（如 `2025-11-04T09:00:00Z`）。
- 金额与价格：**字符串表示的小数**（避免精度丢失），字段名以 `*_usd`/`price` 结尾。
- **金额字段标准化**：系统内一律使用 `premiumUSDC_6d`（字符串承载6位整数）；前端兼容 `premiumUSDC` 小数入口，仅在拦截器转换为 *_6d 后发送。
- ID：对外展示使用 `*_uid`（ULID/UUIDv7）；交易所原始 ID 使用 `ordId`/`instId` 原样保存。
- 通用请求头：
  - `Authorization: Bearer <token>`（FE→US）
  - `X-Request-Id`（可选，若未提供由服务生成并回显）
  - `Idempotency-Key`（对写/编排类接口可选，启用时保证重放安全）

- 通用响应头：
  - `X-Request-Id`：贯穿链路（US 透传至 JP 并回显）
  - 速率：`X-RateLimit-Limit|Remaining|Reset`；超限返回 `429` 并含 `Retry-After`

- 错误统一：
```json
{
  "success": false,
  "error": { "code": "400_VALIDATION", "message": "...", "details": {"field": "..."} }
}
```
HTTP 状态码与 `error.code` 对齐（见 §7）。

---

## 1. 前端 ↔ US 后端

### 1.1 保存/更新交易所 API 凭据（前端**不直传**到 JP）
**POST** `/api/v1/api-keys`

**Headers**：`Authorization`、`X-Request-Id?`

**Body**
```json
{
  "exchange": "okx",
  "label": "primary",
  "apiKey": "...",
  "secret": "...",
  "passphrase": "...",
  "uid": "2019..."
}
```
> 仅 US 持久化（加密），JP 不与前端直接交互。

**200**
```json
{"success": true, "data": {"id": "ak_01Hx...", "exchange": "okx", "label": "primary", "lastVerifiedAt": null}}
```

---

### 1.2 订单验证（US 代理到 JP）
**POST** `/api/v1/verify`

**Headers**：`Authorization`、`X-Request-Id?`、`Idempotency-Key?`

**Body**（**不含任何密钥**）
```json
{
  "exchange": "okx",
  "ordId": "2940071038556348417",
  "instId": "BTC-USDT-SWAP",
  "live": true,
  "fresh": true,
  "noCache": true,
  "credentialLabel": "primary"
}
```

**200**
```json
{
  "success": true,
  "data": {
    "meta": {
      "exchange": "okx",
      "ordId": "2940071038556348417",
      "instId": "BTC-USDT-SWAP",
      "verifiedAt": "2025-11-04T09:00:00Z"
    },
    "normalized": {
      "status": "filled",
      "side": "buy",
      "size": "0.64000000",
      "price": "34980.12000000",
      "timestamp": "2025-10-30T12:34:56Z",
      "liquidated": false,
      "liquidationPrice": null,
      "marginRatio": "0.0450",
      "leverage": 50
    },
    "raw": { "okxOrder": { "...": "原始响应" } },
    "evidence": {
      "evidenceUid": "ev_01Hy...",
      "hash": "0xabc...",
      "jpUrl": "https://jp.example/evidence/ev_01Hy..."
    },
    "perf": { "okxLatencyMs": 180, "totalMs": 260 }
  }
}
```

**错误示例** `401_UNAUTHORIZED`
```json
{"success": false, "error": {"code": "401_UNAUTHORIZED", "message": "invalid token"}}
```

> US 行为：根据 `credentialLabel` 取出加密凭据 → 带密钥调用 JP `/api/verify` → 写入 `verification_jobs`、`evidence_bundles`，并**不回显任何密钥**。

---

### 1.3 订单列表（标准化只读）
**GET** `/api/v1/orders`

**Query**：`page=1&limit=20&status=verified|pending`（可选）

**200**
```json
{
  "success": true,
  "data": {
    "orders": [
      {
        "id": "eo_01Hx...",
        "exchange": "okx",
        "orderId": "2940071038556348417",
        "instrumentId": "BTC-USDT-SWAP",
        "status": "verified",
        "createdAt": "2025-10-30T13:00:00Z",
        "liquidated": false
      }
    ],
    "pagination": {"page": 1, "limit": 20, "total": 1, "pages": 1}
  }
}
```

---

## 2. US 后端 ↔ JP Verify（仅服务间）

### 2.1 验证接口
**POST** `http://<JP_HOST>:8082/api/verify`

**Headers**：
- `Content-Type: application/json`
- `X-Service-Key: <service_key>`（或基于 IP 白名单）
- `X-Request-Id?`（US 透传）

**Body**（**仅此处包含密钥**）
```json
{
  "exchange": "okx",
  "ordId": "2940071038556348417",
  "instId": "BTC-USDT-SWAP",
  "live": true,
  "fresh": true,
  "noCache": true,
  "apiKey": "...",
  "secret": "...",
  "passphrase": "...",
  "uid": "2019..."
}
```

**200**（JP 统一返回结构）
```json
{
  "meta": {"exchange": "okx", "ordId": "...", "instId": "...", "verifiedAt": "2025-11-04T09:00:00Z"},
  "normalized": {"status": "filled|canceled|liquidated", "side": "buy|sell", "size": "...", "price": "...", "timestamp": "...", "liquidated": false, "liquidationPrice": null, "marginRatio": "0.0450", "leverage": 50},
  "raw": {"okxOrder": {"...": "原始返回"}},
  "evidence": {"evidenceUid": "ev_01Hy...", "hash": "0x..", "merkle": {"root": "0x..", "index": 123}},
  "perf": {"okxLatencyMs": 180, "totalMs": 260}
}
```

**错误**：`401 Service Key 错误`、`429 限频`、`502 OKX 上游错误`、`504 超时`（见 §7）。

### 2.2 证据只读
**GET** `http://<JP_HOST>:8082/api/evidence/{evidenceUid}`

**200** 返回**不含任何密钥**的证据 JSON；可选签名/哈希。

---

## 3. 数据映射（与 DB Schema 对齐）
- `POST /api/v1/verify` 成功：
  - 写 `verification_jobs(job_uid, exchange, order_id, instrument_id, status, finished_at)`
  - 写/更 `exchange_orders(exchange, order_id, instrument_id, status, liquidated, normalized_json, raw_json, verified_at)`；`UNIQUE(exchange, order_id)`
  - 写 `evidence_bundles(evidence_uid, job_uid, evidence_hash, storage_url, bytes_size)`
- 列表 `/api/v1/orders` 从 `exchange_orders` 读取；分页按 `created_at DESC`。

---

## 4. JSON Schema（片段）

### 4.1 FE→US：Verify Request
```json
{
  "$id": "https://liqpass.io/schemas/fe.us.verify.request.v1.json",
  "type": "object",
  "required": ["exchange", "ordId", "instId", "live", "credentialLabel"],
  "properties": {
    "exchange": {"enum": ["okx", "binance"]},
    "ordId": {"type": "string"},
    "instId": {"type": "string", "pattern": "^[A-Z0-9-]+$"},
    "live": {"type": "boolean"},
    "fresh": {"type": "boolean"},
    "noCache": {"type": "boolean"},
    "credentialLabel": {"type": "string", "minLength": 1}
  }
}
```

### 4.2 US→FE：Verify Response
```json
{
  "$id": "https://liqpass.io/schemas/us.fe.verify.response.v1.json",
  "type": "object",
  "required": ["success"],
  "properties": {
    "success": {"type": "boolean"},
    "data": {"type": "object"},
    "error": {"type": "object"}
  }
}
```

### 4.3 US→JP：Verify Request
```json
{
  "$id": "https://liqpass.io/schemas/us.jp.verify.request.v1.json",
  "type": "object",
  "required": ["exchange", "ordId", "instId", "live", "apiKey", "secret"],
  "properties": {
    "exchange": {"enum": ["okx", "binance"]},
    "ordId": {"type": "string"},
    "instId": {"type": "string"},
    "live": {"type": "boolean"},
    "fresh": {"type": "boolean"},
    "noCache": {"type": "boolean"},
    "apiKey": {"type": "string"},
    "secret": {"type": "string"},
    "passphrase": {"type": "string"},
    "uid": {"type": "string"}
  }
}
```

---

## 5. 枚举与命名收敛
- 交易所：`okx|binance`
- 方向：`buy|sell`
- 订单状态（normalized.status）：`filled|partially_filled|canceled|rejected|open|liquidated`

**字段统一**：
- `orderId/instrumentId` → **`ordId/instId`**
- 布尔值使用 JSON `true/false`，不使用字符串
- 数值型金额/价格以字符串传输：`"34980.12000000"`

---

## 6. 性能与 SLO
- FE→US：P95 < 5s
- US→JP：P95 < 10s，超时返回 `504_UPSTREAM_TIMEOUT`
- DB 查询：P95 < 1s

---

## 7. 错误码与 HTTP 状态

| HTTP状态码 | 错误码 | 说明 | 前端Toast提示 |
|-----------|--------|------|---------------|
| 200 | OPERATION_PENDING | 异步处理中 | "确认中，请稍候..." |
| 400 | VALIDATION_ERROR | 参数校验失败 | "字段不匹配，请检查输入" |
| 401 | UNAUTHORIZED | 认证失败/令牌无效 | "系统繁忙，请稍后再试" |
| 403 | FORBIDDEN | 权限不足/来源不允许 | "系统繁忙，请稍后再试" |
| 404 | NOT_FOUND | 资源不存在 | "字段不匹配，请检查输入" |
| 409 | CONFLICT | 幂等冲突/重复请求 | "系统繁忙，请稍后再试" |
| 422 | SEMANTIC_ERROR | 业务校验不通过 | "字段不匹配，请检查输入" |
| 429 | RATE_LIMIT | 触发限流 | "系统繁忙，请稍后再试" |
| 500 | INTERNAL_ERROR | 服务内部错误 | "系统繁忙，请稍后再试" |
| 502 | UPSTREAM_ERROR | 上游（交易所/JP）错误 | "系统繁忙，请稍后再试" |
| 503 | SERVICE_UNAVAILABLE | 服务暂时不可用 | "系统繁忙，请稍后再试" |
| 504 | UPSTREAM_TIMEOUT | 上游超时 | "系统繁忙，请稍后再试" |

### 错误响应示例
```json
{
  "success": false,
  "error": {
    "code": "400_VALIDATION",
    "message": "参数校验失败",
    "details": {
      "field": "premiumUSDC_6d",
      "expected": "字符串形式的微USDC整数",
      "received": "0.01"
    }
  }
}
```

### 异步处理响应
```json
{
  "success": true,
  "data": {
    "jobId": "job_20241219_123456_abc123",
    "status": "processing",
    "estimatedTime": 30
  },
  "message": "确认中，请稍候..."
}
```

示例：JP 向 OKX 返回 401 → US 统一转译为 `502_UPSTREAM` 并在 `details.upstream` 写明。

---

## 8. 安全与合规
- 前端**禁止**直传密钥到 JP；仅向 US 提交并由 US 加密存储与取用。
- JP `/api/*` 仅允许 US IP 或 `X-Service-Key`；`/healthz` 可独立白名单。
- 日志脱敏：屏蔽 `apiKey/secret/passphrase/uid`；仅记录哈希指纹。
- 审计：FE→US、US→JP 请求均落 `audit_logs`，绑定 `user_id` 与 `X-Request-Id`。

---

## 9.### 示例端到端（OKX 实单）
1) FE 调用 US `/api/v1/verify`（credentialLabel="primary"）
2) US 取密钥→调用 JP `/api/verify`→收敛响应
3) US 写 `verification_jobs`/`exchange_orders`/`evidence_bundles` 并回 FE

### 金额限制说明
- **最小金额**：0.01 USDC（10000 micro-USDC）
- **最大金额**：100 USDC（100000000 micro-USDC）
- **步长要求**：1e-6 USDC（1 micro-USDC）
- **验证规则**：金额必须为正数且能被 1e6 整除（符合合约 isValidAmount 验证）

---

## 10. 兼容你 v1.0 文档的关键修正
- **布尔与数值类型修正**：`"boolean"` → `true/false`；价格/金额改**字符串**。
- **接口路径统一**：推荐 `/api/v1/verify`（Body 带 `exchange`），不再拆 `/verify/okx`。
- **数据库契约修正**：`orders` 中**不要存 `api_key`**；证据从订单中剥离到 `evidence_bundles`；新增 `verification_jobs`。
- **错误码完善**：加入 `409/422/429/502/504` 与限流/重试头。

---

## 11. 金额字段标准化

为了确保前后端金额处理的一致性和精度，我们统一使用 `premiumUSDC_6d` 字段（微USDC整数）进行传输和存储。

### 金额字段标准化

为了确保前后端金额处理的一致性和精度，我们统一使用 `premiumUSDC_6d` 字段（微USDC整数）进行传输和存储。

### 字段格式说明

- `premiumUSDC_6d`: 字符串类型，表示微USDC（6位小数精度）的整数值
- 示例转换：
  - 0.01 USDC → premiumUSDC_6d = "10000" （0.01 * 1,000,000 = 10,000）
  - 0.1 USDC → premiumUSDC_6d = "100000" （0.1 * 1,000,000 = 100,000）
  - 1 USDC → premiumUSDC_6d = "1000000" （1 * 1,000,000 = 1,000,000）

### 金额范围限制

- **最小金额**：0.01 USDC（10000 micro-USDC）
- **最大金额**：100 USDC（100000000 micro-USDC）
- **步长要求**：1e-6 USDC（1 micro-USDC）
- **验证规则**：金额必须为正数且能被 1e6 整除（符合合约 isValidAmount 验证）

超出范围的金额将被拒绝，并返回错误信息："金额超出允许范围：最小 0.01 USDC，最大 100 USDC"

### 前端使用说明

前端可以继续使用 `premiumUSDC` 小数格式作为输入，系统会在请求拦截器中自动将其转换为 `premiumUSDC_6d` 字符串格式：

```javascript
// 前端可以这样发送请求
const orderData = {
  policyId: 'policy-123',
  wallet: '0x1234567890123456789012345678901234567890',
  principal: '1000',
  leverage: '2',
  premiumUSDC: 0.01 // 系统会自动转换为 premiumUSDC_6d: "10000"
};

// 请求发送时会被自动转换为
{
  policyId: 'policy-123',
  wallet: '0x1234567890123456789012345678901234567890',
  principal: '1000',
  leverage: '2',
  premiumUSDC_6d: '10000'
}
```

### 后端处理说明

后端只接受 `premiumUSDC_6d` 字段，如果收到 `premiumUSDC` 字段将会返回 400 错误：

```json
{
  "error": "ERR_SCHEMA_FIELD_MISMATCH",
  "message": "expected: premiumUSDC_6d (micro-USDC, integer)"
}
```

### 错误处理

当金额字段格式不正确时，系统会显示友好的错误提示：
- Toast 提示："金额单位不匹配：应为6位整数（*_6d）"

### 兼容性说明

系统提供了7天的兼容期，在此期间前端可以继续使用旧的 `premiumUSDC` 字段，系统会自动进行转换。

---

> 本契约与《LiqPass 数据库 Schema v1.1》一一对应，可直接作为前后端/JP 的 OpenAPI/JSON Schema 来源。后续若引入 Binance，仅需在 JP 的 `normalized` 适配层补充映射即可。

