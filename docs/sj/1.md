 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/reports/LiqPass两周修复路线图.md b/reports/LiqPass两周修复路线图.md
new file mode 100644
index 0000000000000000000000000000000000000000..9bcd31f66a7cfa1d17118923516ee2b877e2e208
--- /dev/null
+++ b/reports/LiqPass两周修复路线图.md
@@ -0,0 +1,44 @@
+# LiqPass 两周修复路线图（D1-D14）
+
+> 假设团队可并行 2~3 人，目标先消除 P0，再分阶段处理 P1/P2。
+
+## D1-D3：P0 熔点
+1. **验证链路整改**
+   - JP-verify 实装 OKX HMAC-SHA256 签名与时序戳校验，拒绝缺失密钥请求。
+   - 以真实 API 响应生成 normalized/raw，不再写死字段；错误时返回 `error`。
+2. **证据链修复**
+   - 统一使用 keccak256，明确 JSON 序列化顺序，生成测试向量。
+   - 给 evidence 文件增加 `schemaVersion`、`hashAlgo` 字段。
+3. **安全加固**
+   - 限制 CORS 允许域，关闭 `allow_credentials` 或引入 CSRF token。
+   - 暂停明文 evidence 落盘，迁移至临时加密存储或直接禁用。
+4. **数据库可用性**
+   - 用 sqlite/Better-SQLite3 替换内存实现，恢复 INSERT/SELECT；补充最小读写单测。
+
+## D4-D7：P1 加固
+1. **风控与鉴权**
+   - 为 `/api/v1/verification`、`/api/verify` 加入 API Token/JWT 校验；
+   - 实装 `express-rate-limit` / `slowapi` 控制调用速率。
+2. **运行可靠性**
+   - `call_okx_api` 增加重试、熔断、错误日志；
+   - `/healthz` 添加外部依赖自检。
+3. **验证正确性**
+   - 对 normalized ↔ raw 建立映射校验单测；
+   - 引入真实样本回放脚本（纳入 CI）。
+4. **密钥治理**
+   - 设计密钥管理 SOP：生成、存储、轮换、审计；
+   - 日志/证据脱敏，清理历史明文文件。
+
+## D8-D14：P2 优化
+1. **经济模型与风控策略**
+   - 输出赔付决策公式、储备金压力测试脚本；
+   - 配置多账户/异常频率监控与自动降额策略。
+2. **运维与文档**
+   - 编写 Runbook、定义 SLA/SLO、配置告警渠道；
+   - 将自测包整合入 CI/CD。
+3. **文案与 UX**
+   - 审核所有“保险/赔付”相关措辞；
+   - 在前端提供证据预览、人工复核路径与失败重试按钮。
+4. **长效治理**
+   - 建立安全评审流程（变更前威胁建模 + 风险清单更新）；
+   - 定期（每两周）回顾风险清单与路线图执行情况。
 
EOF
) (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/reports/LiqPass系统级审计报告.md b/reports/LiqPass系统级审计报告.md
new file mode 100644
index 0000000000000000000000000000000000000000..10a9f91bbb9a55c838bdf9aa73a51eaa9ede0b9f
--- /dev/null
+++ b/reports/LiqPass系统级审计报告.md
@@ -0,0 +1,88 @@
+# LiqPass 系统级审计报告 v0.1
+**日期**：2024-06-10
+
+## 0. 执行摘要
+- Top P0：
+  1. JP-verify 未实现 OKX 鉴权签名、返回硬编码字段，任何请求都能伪造验证成功。
+  2. 证据哈希链宣称 keccak256，但代码使用 sha256 且序列化无序，导致 root 不可复现。
+  3. us-backend 使用的内存 DB 不支持 SELECT/参数绑定，所有验证结果查询都会失败。
+  4. CORS 全量放开 + allowCredentials=true，任何网站都能携带凭证调用接口。
+  5. 证据归档将 raw 响应（含密钥）明文落盘，无访问控制。
+- 立即行动（72h）：
+  - 封锁公网访问，限制允许域；暂停对外提供验真结果。
+  - 实装 OKX/V5 HMAC 签名、使用真实响应生成 normalized；修复哈希算法与序列化。
+  - 替换内存 DB 为轻量 SQLite/Better-SQLite，补充单测验证插入+查询。
+  - 对证据文件加密存储或迁移至受控对象存储，清理历史明文。
+
+## 1. 架构与威胁模型
+- 数据/信任边界：us-frontend → us-backend（Express）→ jp-verify（FastAPI）→ 交易所 API，另有 evidence 文件系统。
+- 攻击面：
+  - 前端或第三方站点可因 CORS 全开直接调用敏感接口；
+  - JP 验证器缺签名，攻击者可伪造 liquidation 证据诱发赔付；
+  - 文件系统保存所有 raw 响应，若服务器被入侵即泄密。
+- 风险矩阵：P0（高影响/高概率）：验证伪造、证据伪造、凭证泄露；P1（高影响/中概率）：限流缺失导致 DoS、授权缺失；P2：文案误导。
+- 控制点建议：
+  1. 统一在 API Gateway 层进行认证与速率限制；
+  2. 在 JP 服务与交易所间引入服务帐号 + 防火墙白名单；
+  3. Evidence 存储放入 KMS 加密的对象存储并分级访问。
+
+## 2. 证据链一致性（Merkle/EIP-712）
+- 当前 `calculate_hash` 采用 `hashlib.sha256` 输出十六进制字符串，却在 `evidence.rootAlgo` 声明 `keccak256-merkle-v1`，与链上预期不符。
+- `bundleHash` 对整个响应执行 `json.dumps(..., sort_keys=True)`，但 `leaves` 内部未排序，`raw` 响应字段受网络顺序影响，导致不可重复。
+- 未提供 EIP-712 域参数，也无链上提交逻辑。
+- 修复方案：
+  1. 定义证据 JSON schema，指定字段排序及浮点精度；
+  2. 改为 keccak256，并提供至少 3 组测试向量；
+  3. 在保存文件时写入 `schemaVersion`，并将 root 写入链上/数据库供追溯。
+
+## 3. 交易所验证正确性（OKX/币安）
+- `call_okx_api` 未计算签名，默认 headers 中 `OK-ACCESS-SIGN` 为空，真实 OKX API 会拒绝（返回 401），但错误被吞掉并返回 `error` 字段。
+- 即便 API 调用失败，`normalized` 区块仍写入固定 `liquidated: True` 等演示数据。
+- 建议：
+  1. 实装 OKX/币安验签，使用 server-side 代理调用；
+  2. 对失败请求返回明确错误，不生成 normalized；
+  3. 建立回放测试：导入真实/匿名化订单，用脚本比对 raw ↔ normalized ↔ 判定。
+
+## 4. 秘钥与数据安全
+- API Key 输入支持 `inline`，服务端无任何存储防护，且 `save_evidence` 会把 `raw` 响应落盘。
+- `us-backend` 与 `jp-verify` 均启用通配 CORS。
+- 建议：
+  1. 使用密钥管家（HashiCorp Vault/AWS KMS）托管密钥，服务端只存引用 ID；
+  2. 落盘前对敏感字段脱敏/加密，设置访问控制与 TTL；
+  3. 对所有管理类接口加入 API Token + 最小权限矩阵；
+  4. 审计日志禁止输出密钥，启用字段级脱敏。
+
+## 5. 经济与赔付风险
+- 定价与储备公式未见实现，赔付决策基于 `liquidated: True` 等硬编码值。
+- 缺少等待期、黑名单或多账户检测逻辑。
+- 建议：
+  1. 明确“赔付触发”条件并绑定真实订单字段；
+  2. 构建储备金压力脚本，模拟多订单/延迟申报场景；
+  3. 加入风控：同一 UID 在 24h 内限额、异常申报自动人工复核。
+
+## 6. 数据库与接口一致性
+- 内存 DB 无法返回任何查询结果，也不支持多列插入，导致 `/result`、`/history` 接口全部失效。
+- JSON 字段（caps_json 等）未定义默认值，解析时可能抛错。
+- 建议：
+  1. 恢复 SQLite/Better-SQLite3 并保持与迁移脚本一致；
+  2. 为 JSON 列提供默认值或迁移为 TEXT + schema；
+  3. 编写“最小读写闭环”脚本：验证→查询→历史→删除。
+
+## 7. 运维与可靠性
+- `/healthz` 仅返回静态 healthy，不检查交易所连通性。
+- 缺少速率限制、熔断、重试与告警配置；`call_okx_api` 遇到异常仅记录在响应中，不上报。
+- 建议：
+  1. 健康检查加入外部依赖探测与队列长度；
+  2. 引入 circuit breaker & exponential backoff；
+  3. 配置监控（Prometheus/Grafana）和告警（PagerDuty/Slack），并编写 Runbook。
+
+## 8. 文案合规与 UX
+- 返回体含“forced-liquidation”等强烈措辞，但无实际证据链接或解释，用户易误解为官方确认。
+- 前端未提供错误重试/人工复核路径。
+- 建议：
+  1. 对每个风险字段提供上下文说明与证据预览；
+  2. 增加“申诉/人工复核”按钮与 SLA；
+  3. 审查所有中英文文案，避免“保险”等敏感词。
+
+## 附录：问题清单
+详见《LiqPass 风险与不合理点清单》基线版。
 
EOF
) (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/reports/LiqPass风险与不合理点清单.md b/reports/LiqPass风险与不合理点清单.md
new file mode 100644
index 0000000000000000000000000000000000000000..5c5e06b4221c7f0307e4fef9d4cdb5720d572e22
--- /dev/null
+++ b/reports/LiqPass风险与不合理点清单.md
@@ -0,0 +1,56 @@
+# LiqPass 风险与不合理点清单（基线版）
+
+ID | 模块 | 标题 | 严重度 | 影响 | 复现步骤 | 修复建议 (1-3 步) | Owner | ETA
+---|---|---|---|---|---|---|---|---
+P0-1 | 架构/验证链路 | JP Verify 未对 OKX 请求签名且返回硬编码归一化字段 | P0 | 任意人可伪造验证通过结果，证据链与真实交易脱钩 | 1. 启动 `jp-verify`
+2. 调用 `/api/verify`，不填密钥或填假密钥
+3. 接口仍返回 `normalized.position.liquidated: true` 等固定字段 | 1. 实现 OKX V5 HMAC-SHA256 签名，拒绝缺失密钥请求
+2. 用真实 API 响应填充 normalized/raw
+3. 为返回体添加完整输入校验与错误码 | JP Verify Owner | D1-D3
+P0-2 | 证据链 | 证据哈希声明与实现不一致（sha256 输出却标注 `keccak256-merkle-v1`），且 bundleHash 对象排序不稳定 | P0 | 相同证据无法复现 root，证据可被质疑或伪造 | 1. 调用 `/api/verify`
+2. 查看 `evidence.root` 与 `evidence.bundleHash`
+3. 发现实现使用 `hashlib.sha256` 且 `json.dumps` 未排序 | 1. 统一改用 keccak256，并严格定义序列化顺序
+2. 给出测试向量验证“同样输入→同样哈希”
+3. 在文件存储前写入 version/schema | Crypto Engineer | D1-D3
+P0-3 | 数据库存储 | 内存 DB `prepare().get/all` 永远返回空，`handleInsert` 只接受单对象参数 | P0 | 验证结果/历史查询均失效，导致 API 永远 404 | 1. 调用 `/api/v1/verification/verify`
+2. 再调用 `/api/v1/verification/result/:sessionId`
+3. 返回 404 且日志提示 Insert 参数错误 | 1. 重写内存 DB 以支持位置参数、基本 SELECT
+2. 覆盖插入/查询的单元测试
+3. 在正式环境换回持久化 DB | Backend Lead | D1-D3
+P0-4 | 安全边界 | `us-backend` 与 `jp-verify` CORS `allow_origins=["*"]` 且允许凭证 | P0 | 任意站点可携带凭证调用后台接口，易被 CSRF/钓鱼利用 | 1. 查看 `app.ts` 与 `main.py`
+2. 发现 CORS 放行 `*` + `allow_credentials=True`
+3. 浏览器中第三方站点可直接发起带 Cookie/Token 的请求 | 1. 限制允许域，禁用凭证或改用双重提交 Token
+2. 补充 CSRF 防护（Nonce/Referer 校验）
+3. 针对管理端启用 SameSite Cookie | Platform | D1-D3
+P0-5 | 密钥与日志 | `save_evidence` 将包含密钥的 raw 响应明文写入磁盘 | P0 | 服务器落地即泄露 API key/账户信息，无访问控制 | 1. 调 `/api/verify`
+2. 检查 `reports/evidence/<date>/<id>.json`
+3. 文件含 headers/响应明文 | 1. 对敏感字段脱敏或加密存储（KMS/磁盘加密）
+2. 加访问控制和定期清理
+3. 将密钥仅存储在 HSM/密钥托管服务 | Security | D1-D3
+P1-1 | 验证正确性 | `normalized` 字段写死固定价格/数量/理由 | P1 | 无法对真实订单建模，易导致误赔或拒赔 | 1. 请求 `/api/verify`
+2. 查看响应 `normalized`
+3. 字段固定不随订单改变 | 1. 按交易所响应填充 normalized
+2. 增加单元测试比对 normalized vs raw
+3. 引入 schema 校验 | JP Verify Owner | D4-D5
+P1-2 | API 风控 | 缺少速率限制与重试熔断机制 | P1 | 易被滥用导致交易所 API 被限流或 DoS | 1. 查看 `app.ts`、`main.py`
+2. 未发现 rate limit 中间件
+3. 压测即可拖垮 | 1. 引入速率限制器 (express-rate-limit / slowapi)
+2. 针对交易所调用添加退避重试
+3. 设置全局并发阈值 | Platform | D4-D6
+P1-3 | 授权 | `/api/v1/verification` 无鉴权保护 | P1 | 外部可随意触发验证、写入日志 | 1. 无 token 直接调用接口成功 | 1. 引入 JWT/API Token 校验
+2. 区分内外部路由
+3. 审计日志增加调用者身份 | Backend | D4-D6
+P1-4 | 运维 | 无健康检查依赖状态，且 `call_okx_api` 未设重试 | P1 | 上游波动即失败，无降级/告警 | 1. 查看 `/healthz` 返回固定 healthy | 1. 增加依赖探测/自检
+2. 对关键调用加重试+熔断
+3. 接入监控告警 | SRE | D4-D7
+P2-1 | 文案合规 | 返回体含“forced-liquidation”等字样但无证据链接 | P2 | 用户体验差/潜在误导 | 1. 检查响应
+2. 发现 reason 固定 | 1. 按真实状态生成文案
+2. 提供证据预览链接
+3. 在前端补充解释 | Product | D8-D10
+P2-2 | 数据一致性 | `verificationService.getVerificationHistory` JSON 字段解析缺默认 schema | P2 | JSON 解析异常导致历史接口报错 | 1. 构造历史记录
+2. 解析失败 | 1. 在 DB 层定义列类型与默认值
+2. 解析前校验 null
+3. 增加历史接口测试 | Backend | D8-D12
+P2-3 | 运维文档 | 缺少运行 Runbook/告警描述 | P2 | 故障时响应慢 | 1. 查看 repo 无 runbook | 1. 撰写 Runbook
+2. 定义 SLA/SLO
+3. 纳入交班手册 | SRE | D10-D14
 
EOF
) (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/reports/LiqPass验证闭环自测包.md b/reports/LiqPass验证闭环自测包.md
new file mode 100644
index 0000000000000000000000000000000000000000..05c9220ed71a5c6fecf59ecf161f89f46b146c36
--- /dev/null
+++ b/reports/LiqPass验证闭环自测包.md
@@ -0,0 +1,64 @@
+# LiqPass 验证闭环自测包 v0.1
+
+## 1. 目标
+为开发/QA 提供可复现的验真流程测试：从构造订单 → 调用 us-backend → 调用 jp-verify → 校验证据与落盘文件 → 清理。
+
+## 2. 目录结构
+```
+self-test/
+  ├─ samples/
+  │   ├─ okx_liquidation_order.json       # 匿名化强平样本
+  │   ├─ okx_partial_fill_order.json      # 部分成交
+  │   └─ okx_adl_order.json               # ADL 触发
+  ├─ scripts/
+  │   ├─ 01_bootstrap_env.sh              # 启动 us-backend & jp-verify
+  │   ├─ 02_trigger_verification.http     # HTTPie/curl 脚本
+  │   ├─ 03_poll_result.ts                # 轮询 sessionId 并校验字段
+  │   ├─ 04_hash_replay.py                # 复算 evidence root 与 bundleHash
+  │   └─ 05_cleanup.sh                    # 清理临时证据文件
+  └─ README.md
+```
+
+## 3. 样例订单（占位）
+- **okx_liquidation_order.json**
+  ```json
+  {
+    "ordId": "1234567890123456789",
+    "instId": "BTC-USDT-SWAP",
+    "state": "canceled",
+    "liqPx": "64010.0",
+    "liquidated": true,
+    "adl": false,
+    "side": "buy",
+    "execType": "L"
+  }
+  ```
+- 请在落地前以真实匿名化数据替换，并补充对应的 `fills`、`positions` 响应。
+
+## 4. 执行步骤
+1. `./self-test/scripts/01_bootstrap_env.sh`
+   - 拉起 us-backend（NODE_ENV=test + sqlite 内存版）、jp-verify（禁用 CORS 通配）。
+2. `httpie < ./self-test/scripts/02_trigger_verification.http`
+   - 使用样例密钥（Sandbox），触发 `/api/v1/verification/verify`。
+   - 期望响应包含 `sessionId`。
+3. `node ./self-test/scripts/03_poll_result.ts <sessionId>`
+   - 轮询 `/result/:sessionId`，校验 `status === "success"` 且 normalized 与 raw 映射一致。
+4. `python ./self-test/scripts/04_hash_replay.py reports/evidence/<date>/<id>.json`
+   - 根据证据 JSON 重新计算 root、bundleHash，与文件中对比。
+5. `./self-test/scripts/05_cleanup.sh`
+   - 删除测试生成的证据文件、数据库数据。
+
+## 5. 期望断言
+- `verify` 响应：`normalized.order` 与 `raw.trade/order` 核心字段一一对应（px、sz、state、fee）。
+- `evidence.leaves`：每个 `hash` 可由脚本重现；`root` 与 `bundleHash` 在不同机器上一致。
+- `/history/:accountId`：包含刚刚生成的记录，字段无解析错误。
+
+## 6. 伪造对抗用例
+- `02_trigger_verification.http` 中将 `secretKey` 留空，应返回 400。
+- 修改 `04_hash_replay.py` 将序列化顺序打乱，应触发 root 校验失败。
+- 使用 `samples/okx_partial_fill_order.json`，期望 normalized 映射为部分成交，而非 liquidated。
+
+## 7. 后续待办
+- 填充真实样本并提交至 `self-test/samples/`。
+- 将脚本加入 CI，针对每次提交执行 Hash 重放与 /history 回归。
+- 为 `04_hash_replay.py` 输出差异报告（字段 -> 原因 -> 修复建议）。
 
EOF
)