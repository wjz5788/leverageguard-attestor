zms，按你现在的阶段（**本地完成、一家交易所=OKX**），我给出一套“最小闭环→平滑上云（US+JP）”的务实方案。目标：**今天就能跑通验证闭环**，并且**接口契约不变**，后续只需把“验证”指向日本服务器即可。

---

# 一、总体建议（先本地跑通，保留“JP 验证接口契约”）

* **保持接口不变**：现在就按 `jp-verify:8082` 的契约在本地跑一个服务（同名同端口）。未来把 `BASE_URL` 从 `http://127.0.0.1:8082` 改成 `https://<jp-ip>:8082` 即可切换，无需改前后端逻辑。
* **只做 OKX**：把 OKX 路径打磨扎实（订单查询→归一化→证据包），币安以后再加。
* **不长期存密钥**：本地阶段默认**临时输入**（只进内存）；若需持久化，用**AES-256-GCM**+本机 KMS 文件（或 libsodium）加密到 SQLite。
* **证据优先**：每次验证都产出**可审计证据包**（normalized/raw/merkle/perf），落盘 + SQLite 可检索；后续想上链，直接取 root 即可。

---

# 二、目录与端口约定

* `us-backend`（本地）：`http://127.0.0.1:8080`
* `jp-verify`（本地影子版）：`http://127.0.0.1:8082`
* `us-frontend`（本地 dev）：`http://127.0.0.1:5173`

> 将来迁移：`us-backend` ➜ 美国服务器；`jp-verify` ➜ 日本服务器（端口仍 8082）。

---

# 三、接口契约（现在就按“JP 验证接口”实现）

### 1) 验证请求（OKX 专用）

`POST /api/verify`（由 jp-verify 暴露；现在本地，未来 JP）

```json
{
  "exchange": "okx",
  "ordId": "2940071038556348417",
  "instId": "BTC-USDT-SWAP",
  "live": true,
  "fresh": true,
  "noCache": true,

  "keyMode": "inline",        // "inline" | "alias"
  "apiKey": "…",              // keyMode=inline 时必填
  "secretKey": "…",
  "passphrase": "…",
  "uid": "201933253463154688",// OKX子账户/UID，如无可留空

  "clientMeta": {             // 可选：前端/调用方元信息
    "source": "us-backend",
    "requestId": "uuid-…"
  }
}
```

> 未来若使用密钥别名：`"keyMode":"alias","keyAlias":"okx-main-001"`，其余密钥字段不传。

### 2) 验证响应（**全量返回**）

```json
{
  "meta": {
    "exchange": "okx",
    "instId": "BTC-USDT-SWAP",
    "ordId": "2940071038556348417",
    "verifiedAt": "2025-11-04T09:10:11Z",
    "live": true,
    "fresh": true,
    "requestId": "uuid-…",
    "version": "jp-verify@1.0.0"
  },
  "normalized": {
    "order": {
      "side": "buy",
      "px": "65000.5",
      "sz": "1.0",
      "state": "filled",           // created/partially_filled/filled/canceled/failed
      "avgFillPx": "65010.2",
      "accFillSz": "1.0",
      "fee": "-1.23",
      "ts": "2025-11-03T22:31:45Z"
    },
    "position": {
      "lever": "50",
      "mode": "isolated",          // isolated/cross
      "liqPx": "64010.0",
      "adl": false,
      "liquidated": true,          // ← 你关心的核心字段
      "liquidatedAt": "2025-11-03T22:32:10Z",
      "reason": "forced-liquidation" // forced-liquidation / adl / manual-close / unknown
    }
  },
  "raw": {
    "trade/order": { "code": "0", "data": [/* OKX 原始返回 */], "fetchedAt":"…"},
    "account/positions": { "code": "0", "data": [/* … */], "fetchedAt":"…"},
    "public/instruments": { "code": "0", "data": [/* … */], "fetchedAt":"…"}
  },
  "evidence": {
    "leaves": [
      {"path":"raw.trade/order","hash":"0x…"},
      {"path":"raw.account/positions","hash":"0x…"},
      {"path":"normalized.position","hash":"0x…"}
    ],
    "root": "0xMERKLE_ROOT",
    "rootAlgo": "keccak256-merkle-v1",
    "bundleHash": "0xBUNDLE_HASH",          // 对整个响应去除非确定字段后的 hash
    "evidenceId": "evi_20251104_xxx",       // 便于索引
    "parentRoot": null                      // 以后做“父链”审计时用
  },
  "perf": {
    "okxRttMs": 420,
    "totalMs": 650,
    "cache": false,
    "rateLimit": {"remaining": 98, "resetSec": 1}
  },
  "error": null                              // 出错时 {code,msg,hint}
}
```

---

# 四、数据库与落盘（SQLite + 文件）

> **本地阶段**建议**最小表集** + **证据文件落盘**，后续 US/JP 拆分仍可复用。

## 1) SQLite 表（`us-backend/db.sqlite`）

* `users(id, created_at)`
* `api_keys(id, user_id, exchange, key_alias, enc_payload, created_at, last_used_at)`
* `orders(id, user_id, exchange, ord_id, inst_id, verified_at, liquidated, reason, evidence_id)`
* `claims(id, user_id, ord_id, status, payout_amount, created_at, decided_at)`
  `status ∈ {pending, approved, rejected, paid}`
* `audit_logs(id, topic, ref_id, created_at, payload_json)`

> `enc_payload` 存 `{apiKey,secretKey,passphrase,uid}` 的**加密 JSON**；本地不需要就别存。

## 2) 证据文件（`reports/evidence/<yyyy-mm-dd>/evi_*.json`）

* 存**响应原文**（去除敏感字段），文件名含 `evidenceId`。
* 同时存一份 `.root` 纯文本只含 `root`，便于以后对账/上链。

---

# 五、最小闭环流程（今天就能跑）

1. **启动本地 jp-verify**（FastAPI/uvicorn，端口 8082）

   * 路由：`GET /healthz`；`POST /api/verify`（上面契约）。
   * 仅实现 OKX：调用 **订单详情**、**持仓**（或交易/账单）两个端点，得出 `liquidated` 判定。

2. **us-backend 提供薄代理**

   * `POST /verify/okx`：把前端请求转给 `http://127.0.0.1:8082/api/verify`，拿到响应后：

     * 落盘 `reports/evidence/...`
     * 写入 `orders`（提要 + `evidenceId`）
     * 返回前端**同样结构**（或裁剪 `raw`）

3. **us-frontend 做一个“订单验证器”页面**

   * 输入：`apiKey/secret/passphrase/uid`、`instId`、`ordId`
   * 点击【验证】→ 调 `us-backend /verify/okx` → 展示 `normalized.position.liquidated` 等关键字段；提供“查看证据包”按钮。

4. **自测脚本**（本地终端）

```bash
# 1) 健康
curl -s http://127.0.0.1:8082/healthz

# 2) 真实单验证（替换为你的真实 ordId/instId 与密钥）
curl -sS -m 20 -H 'Content-Type: application/json' \
  -d '{
    "exchange":"okx",
    "ordId":"2940071038556348417",
    "instId":"BTC-USDT-SWAP",
    "live":true, "fresh":true, "noCache":true,
    "keyMode":"inline",
    "apiKey":"__OKX_API_KEY__", "secretKey":"__OKX_SECRET__",
    "passphrase":"__OKX_PASS__", "uid":"__OKX_UID__"
  }' http://127.0.0.1:8082/api/verify | jq .
```

---

# 六、字段清单（你之前反复要“细节”——这里给全）

### A. 输入字段（OKX 验证）

* `ordId` *(string, required)*
* `instId` *(string, required)* 例：`BTC-USDT-SWAP`
* `live`/`fresh`/`noCache` *(bool, optional)*：控制直连所取、绕缓存
* 凭证三件套：`apiKey`、`secretKey`、`passphrase` *(inline 模式必填)*
* `uid` *(string, optional)*：OKX 子账户/UID
* `keyMode` *(string, required)*：`inline` | `alias`
* `keyAlias` *(string, optional)*：`alias` 模式下用
* `clientMeta` *(object, optional)*：`{source, requestId}`

### B. 关键输出字段

* `normalized.position.liquidated` *(bool)*
* `normalized.position.liquidatedAt` *(ISO8601)*
* `normalized.position.reason` ∈ `forced-liquidation | adl | manual-close | unknown`
* `evidence.root` *(0x…)*
* `evidence.bundleHash` *(0x…)*
* `evidence.evidenceId` *(string)*
* `perf.totalMs` *(int)*
* `error`：标准化错误 `{code,msg,hint}`

### C. 失败/错误约定

* `error.code`：`AUTH_ERROR` / `NOT_FOUND` / `RATE_LIMIT` / `REMOTE_4XX` / `REMOTE_5XX` / `TIMEOUT`
* `error.hint` 给出直观修复建议（时间不同步、密钥错、ordId/instId 不匹配等）

---

# 七、迁移路径（US + JP）

**目标**：只改配置，不改代码。

1. **将 `jp-verify` 拷到日本服务器**（保持 8082）

   * `systemd` 启动；`/healthz` 必须 200
   * `ufw`：先全开 8082 做联调；上线后**仅放行美国后端 IP**
   * **鉴权**：给 `jp-verify` 增加 `X-Signature: HMAC_SHA256(body, JP_SHARED_SECRET)`；US 后端配置同密钥

2. **US 后端改 `.env`**

```
JP_VERIFY_BASE_URL=https://<jp-ip-or-domain>:8082
JP_VERIFY_HMAC_SECRET=xxxx
```

3. **灰度**

   * `us-backend` 增加 `?target=local|jp` 切换参数；默认 `jp`，出现异常自动回退 `local`

4. **可观测性**

   * `GET /metrics`（prometheus 文本）至少暴露：请求次数、P95 耗时、错误数、上游 4xx/5xx

---

# 八、为什么先本地、后 JP？

* 你当前的痛点是**能跑通且稳定**。先本地把**接口与证据格式定死**，一键切换到 JP 只涉及“网络与进程稳定性”，而不再改业务与前端。
* 之前你遇到的 SSH/端口/防火墙问题都会拖慢开发节奏。把“复杂度”留到迁移那一刻再处理，且**只处理一类复杂度（运维）**。

---

# 九、今天可交付的小清单

* [ ] `jp-verify` 本地影子服务（端口 8082，OKX-only，返回全量）
* [ ] `us-backend` 的 `/verify/okx` 薄代理 + SQLite 落盘（`orders`/`audit_logs`）
* [ ] `reports/evidence/…` 证据落盘（JSON + .root）
* [ ] `us-frontend` “订单验证器”页面（输入密钥/ordId/instId → 显示 liquidated）
* [ ] `curl` 自测脚本 + 一条真实订单验证记录

---

如果你愿意，我可以直接把 **`/api/verify` 的 FastAPI 处理器骨架**、**SQLite schema 初始化脚本** 和 **us-backend 薄代理的路由示例**写出来，贴进你的目录结构里就能运行。接下来继续到“代码级落地”。
