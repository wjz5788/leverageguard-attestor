收到。按你的路径逐页重写，全部双语注释，面向“小白 + 让 AI 直接落地”。不讲废话，信息不少于你之前看到的。

---

# 全局基线（必须先读）

* **身份 / Auth**：用钱包签名换会话。`X-Session-Token` 作为后端鉴权。
  English: Sign-in with wallet, then use `X-Session-Token` for all state-changing API calls.
* **链 / Chain**：Base 主网；开发可用 Base Sepolia。
  `GET /chains/base → { chain_id_hex, chain_name, usdc_address }`
* **金额 / Amount**：USDC 6 位小数。数据库一律存 **microUSDC**（整数）。
  English: Always store `amount_usdc` as integer of micro-USDC; UI divides by 1e6.
* **时间 / Time**：ISO8601 + 一个 `created_at_epoch`（秒）便于排序。
* **幂等 / Idempotency**：所有 `POST/PATCH` 必带 `Idempotency-Key`（建议 `sha256(wallet|route|payload|nonce)`，服务端存 24h）。
* **两服务 / Two services**：US=主后端；JP=验证微服务（只读交易所、拉取证据）。
* **错误返回 / Error**：统一 `{ error_code, error_message, details? }`。
* **状态机**：只允许**单向流转**（下面各页列出）。

---

## 1) Settings · Wallet（连接钱包与会话）

**前端路由 / Route**：`/settings/wallet`

**页面目的 / Goal**：连接钱包 → 切到 Base → 签名登录，拿到 `session_token`。

**用户能做什么 / User actions**

1. Connect Wallet（连接钱包）
2. Switch to Base（切换到 Base）
3. Sign Message（签名登录）

**接口 / APIs**

* `POST /auth/nonce`（US）
  Req: `{ "wallet_address": "0xUser..." }`
  Res: `{ "nonce": "random-string", "expires_in_s": 300 }`
  解释：服务端生成一次性随机串，5 分钟有效。
* `POST /auth/login`（US）
  Req: `{ "wallet_address": "0xUser...", "nonce": "...", "signature": "0x..." }`
  Res: `{ "session_token": "tok_...", "expires_in_s": 86400 }`
  解释：验签成功后，发会话令牌。前端存于内存或安全存储。

**数据库 / DB**

* `wallets`：

  * `id TEXT PK` 唯一 ID
  * `wallet_address TEXT UNIQUE NOT NULL` 钱包地址
  * `created_at TEXT`, `updated_at TEXT`
* `sessions`：

  * `id TEXT PK`
  * `wallet_id TEXT FK wallets(id)`
  * `session_token TEXT UNIQUE NOT NULL`
  * `expires_at TEXT`, `created_at TEXT`

**与其他页关系 / Relations**
成功后跳转 `/settings/exchange-api`。失败保留在本页提示。

**边界 / Edge cases**

* 钱包未安装：给出安装提示链接。
* 链错误：提示“切换到 Base”。
* 签名拒绝：停留并可重试。

**AI 实现要点 / Hints**

* 前端按钮状态：未连接/已连接、链正确/错误、已登录/未登录。
* 把 `session_token` 放到后续请求 `X-Session-Token` 头。

---

## 2) Settings · Exchange API（校验交易所 API）

**前端路由**：`/settings/exchange-api`

**页面目的**：输入并校验交易所 API（只读权限），默认**不保存**密钥。

**表单字段 / Form**

* `exchange`：`"Binance"` 或 `"OKX"`
* `api_key`：字符串
* `api_secret`：字符串
* `passphrase?`：仅 OKX 需要
* `store`：布尔；默认 `false`（不保存）

**接口 / APIs**

* `POST /verify/exchange-api`（JP）
  Req: `{ "exchange": "OKX", "api_key":"...", "api_secret":"...", "passphrase":"...", "store": false }`
  Res OK: `{ "ok": true, "account_uid": "exch_abc123", "permissions": ["read_only"], "note": "Keys valid" }`
  Res Fail: `{ "ok": false, "error": "INVALID_KEYS" }`
  解释：JP 只做在线校验，不落库存敏感。
* 如用户勾选保存：
  `POST /exchange-accounts`（US）
  Req: `{ "exchange":"OKX", "account_uid":"exch_abc123", "encrypted_payload":"base64...", "last4":"****", "permissions":["read_only"], "stored": true }`
  Res: `{ "exchange_account_id":"ea_xxx" }`
  解释：加密可以在前端或 US 后端做，依据你当前安全能力。

**数据库 / DB**

* `exchange_accounts`：

  * `id TEXT PK`
  * `wallet_id TEXT` 归属
  * `exchange TEXT`
  * `account_uid TEXT` 交易所侧标识
  * `encrypted_payload BLOB` 加密后的 key/secret/passphrase
  * `last4 TEXT` 用于“已保存”提示
  * `permissions_json TEXT`
  * `stored INTEGER` 0/1
  * `created_at TEXT`
* `api_verifications_log`：

  * `id TEXT PK`, `wallet_id TEXT`, `exchange TEXT`
  * `result_ok INTEGER` 1/0
  * `error_json TEXT`, `created_at TEXT`

**关系**
校验成功 → `/buy`（或提供按钮跳转）。

**边界**

* 权限不足（未开只读）：返回 `ok=false`，提示去交易所面板开启。
* 频控：JP 对同钱包 + IP 做限流（例如 30 次/小时）。

**AI 要点**

* 绝不把明文密钥写日志。
* 如果不保存，`encrypted_payload` 置空且 `stored=0`。

---

## 3) Buy（购买）

**前端路由**：`/buy`

**页面目的**：选择 SKU，录外部订单号 `order_ref`（交易所订单号），用 USDC 付款，下单入库。

**表单字段**

* `sku_id`：如 `sku_24h_liq`
* `order_ref`：如 `2938801601245126656`（你常用示例）
* `exchange`：`OKX`/`Binance`
* `pair`：`BTC-USDT` …
* `leverage`：整数，如 20
* `price_usdc`：单价（microUSDC，整数）
* `qty`：默认 1
* 付款方式：`USDC on Base`（Permit2 优先；否则 approve+transferFrom）

**接口 / APIs**

* `GET /catalog/skus`（US） → 渲染卡片与定价参数
  Res：`[{ id, code, name, desc, pricing_json, active }]`
* `POST /orders`（US）
  Req:

  ```json
  {
    "sku_id":"sku_24h_liq",
    "order_ref":"2938801601245126656",
    "exchange":"OKX",
    "pair":"BTC-USDT",
    "leverage":20,
    "price_usdc":2000000,
    "qty":1
  }
  ```

  Res：

  ```json
  {
    "order_id":"fdeec813-1d08-48e9-a7ca-dceaea45269e",
    "status":"pending",
    "usdc_amount":2000000,
    "pay_to":"0xTreasury...",
    "usdc_contract":"0xUSDC..."
  }
  ```
* 钱包链上支付完成后的**通知**（两种二选一）

  1. **Permit2**：`POST /payments/usdc/permit2`（US）
     Req：`{ "order_id":"...", "permit_payload":{...}, "signature":"0x..." }` → 服务端校验 & 记账
  2. **回告监听**：`POST /payments/usdc/notify`（US）
     Req：`{ "order_id":"...", "tx_hash":"0x..." }` → 后端再查链并确认
     Res：`{ "status":"paid" }`（确认后）

**订单状态机 / Order states**

* `pending` → `paid` →（后续可理赔）
* 失败：`pending` → `expired | cancelled`（非主路径）

**数据库 / DB**

* `skus(id, code, name, desc, pricing_json, active, created_at)`
* `orders`：

  * 关键字段：`order_ref TEXT` 外部订单号（需要唯一或至少加索引）
  * `status TEXT`：`pending|paid|expired|cancelled`
  * `total_amount_usdc INTEGER`
  * 排序辅助：`created_at_epoch INTEGER`
* `payments(order_id, method, tx_hash, chain_id, amount_usdc, status, created_at)`

**关系**

* `paid` 后，页面提示去 `/claims/payout` 验证并申请赔付。

**边界**

* `order_ref` 重复：直接返回已有订单或报错 `DUPLICATE_ORDER_REF`（建议“同一钱包+同一 order_ref 只允许一个有效订单”）。

**AI 要点**

* 定价前端仅展示；成交价以后端返回为准，避免被篡改。
* 金额一律整数传输；UI 显示时格式化。

---

## 4) Claims · Payout（理赔与赔付）

**前端路由**：`/claims/payout`

**页面目的**：输入 `order_ref` → 系统从 JP 拉证据 → 判断是否可赔 → 可赔则上链赔付。

**表单字段**

* `order_ref`：用户输入或从“最近订单”选择
* `destination_wallet?`：可选，默认使用下单钱包

**操作流程 / Flow**

1. `POST /claims`（US）用 `order_ref` 创建理赔单

   * Req：`{ "order_ref":"2938801601245126656" }`
   * Res：`{ "claim_id":"...", "order_id":"...", "claim_status":"draft" }`
2. `POST /claims/{claim_id}/verify`（US 协调 JP）

   * US 调 JP：

     * `POST /verify/order`（JP）：`{ exchange, order_ref }` → `{"found":true, "order_json":{...}}`
     * `POST /verify/liquidation`（JP）：`{ exchange, order_ref }` → `{"is_liquidated":true, "adl":false, "timestamp":..., "snapshots":[...]}`
   * US 计算赔付：窗口、阈值、上限、比例等（依据 `sku.pricing_json`）
   * 最终返回：

     ```json
     {
       "eligible": true,
       "payout_amount_usdc": 5000000,
       "reasons": ["Liquidation inside 24h window"],
       "evidence_id": "d1782897-a5c9-498d-9f8e-4b9ef2f82ec6",
       "claim_status":"eligible"
     }
     ```
   * 同步落库：`claims.status`、`claims.payout_amount_usdc`、`evidence.*`
3. `POST /claims/{claim_id}/payout`（US）

   * Req：`{ "destination_wallet":"0xUser..." }`（可省略）
   * Res：`{ "payout_id":"...", "onchain_tx_id":"...", "tx_hash":"0x...", "status":"payout_pending" }`
4. 轮询：`GET /claims/{claim_id}` 直到 `payout_confirmed`

**理赔状态机 / Claim states**

* `draft` → `verifying` → `eligible | ineligible` →
  若 `eligible`：`payout_pending` → `payout_sent` → `payout_confirmed`
  失败：`payout_failed`

**数据库 / DB**

* `claims(id, order_id, wallet_id, status, payout_amount_usdc, evidence_id, reasons_json, created_at, updated_at)`
* `evidence(id, claim_id, order_ref, exchange, raw_order_json, liquidation_json, merkle_root, proof_json, source_dir, created_at)`
* `payouts(id, claim_id, amount_usdc, dest_wallet, status, onchain_tx_id, created_at)`
* `onchain_txs(id, chain_id, tx_hash UNIQUE, status, block_number, receipt_json, created_at)`

**关系**

* 点“查看证据”跳转 `/evidence/:claimId`。
* 完成后可返回 `/orders` 或 `/dashboard`。

**边界**

* 找不到对应订单：错误 `ORDER_NOT_FOUND`。
* 未支付订单：错误 `ORDER_NOT_PAID`。
* 无法确认强平：错误 `EVIDENCE_INSUFFICIENT`（可提示稍后重试）。

**AI 要点**

* 计算结果与原始证据都要**落库**，避免重算分歧。
* 赔付上链前再次二次校验状态，防重复赔付（幂等 + 数据库事务）。

---

## 5) Orders（订单列表）

**前端路由**：`/orders`

**页面目的**：按时间倒序列出用户所有订单。操作越少越好。

**列表列**

* 时间、SKU、`order_ref`、金额、状态、动作（去理赔、查看）

**接口 / APIs**

* `GET /orders?cursor=...&page_size=20`（US）
  Res：`{ "items":[...], "next_cursor":"..." }`
* `GET /orders/{order_id}`（US）

**数据库 / DB**

* 复用 `orders`、`payments`；索引：`(wallet_id, created_at_epoch DESC)`、`(order_ref)`。

**关系**

* “去理赔”直达 `/claims/payout` 并预填 `order_ref`。
* “查看”打开订单详情页（可选）。

**边界**

* 空列表：显示引导去 `/buy`。

**AI 要点**

* 游标分页，避免一次性拉太多。

---

## 6) Evidence（证据详情）

**前端路由**：`/evidence/:claimId`

**页面目的**：给人看得懂的证据链：原始订单片段、强平/ADL 记录、计算过程、Merkle、上链交易。

**UI 区块**

* 基本信息：`claim_id, order_ref, exchange, verify_time`
* 交易所时间线：下单 → 平仓/强平/ADL
* 赔付计算：输入参数（SKU 阈值）→ 计算结果（金额）
* Merkle：`merkle_root, leaf, proof`（如有批量上链）
* 上链信息：`tx_hash, status, block_number`
* 导出按钮：JSON/ZIP

**接口 / APIs**

* `GET /claims/{claim_id}/evidence`（US）
* `GET /claims/{claim_id}/evidence/download`（US）
* 管理补录（可选）：`POST /evidence/{evidence_id}/onchain`（US）

**数据库 / DB**

* 复用 `evidence`、`onchain_txs`

**关系**

* 返回 `/claims/payout` 或 `/dashboard`

**边界**

* 证据未生成：提示先去 `/claims/payout` 执行验证。

**AI 要点**

* 大 JSON 用分页或折叠显示，避免卡 UI。

---

## 7) Dashboard（概览）

**前端路由**：`/dashboard`

**页面目的**：一屏看最近订单、理赔、未确认上链。

**接口 / APIs**

* `GET /me/overview`（US）
  Res：

  ```json
  {
    "recent_orders":[{... up to 5}],
    "recent_claims":[{... up to 5}],
    "pending_txs":[{ tx_hash, status, claim_id? }]
  }
  ```

**关系**

* 卡片直达对应页面（`/orders`、`/claims/payout`、`/evidence/:claimId`）。

**AI 要点**

* 空态友好：按钮引导完成最短路径（连接→校验→购买→理赔）。

---

## 8) 其余（必要最小集）

* **/help**：常见问答与风险提示。
* **/transparency**：合约地址，最近 20 条赔付链上记录。

  * `GET /public/contract → { address, network }`
  * `GET /public/payouts?limit=20 → [{ tx_hash, amount_usdc, to, block_number, ts }]`

---

# 后端接口清单（汇总 + 中文注释）

### Auth / Chains

* `POST /auth/nonce` → 发登录随机串（防重放）
* `POST /auth/login` → 验签，发 `session_token`
* `GET /chains/base` → Base 链与 USDC 地址

### Catalog / Orders / Payments

* `GET /catalog/skus` → SKU + 定价参数
* `POST /orders` → 创建订单，返回应付 USDC 数额与收款地址
* `POST /payments/usdc/permit2` → 校验 Permit2 并入账
* `POST /payments/usdc/notify` → 接收 tx_hash，后端查链确认
* `GET /orders`、`GET /orders/{order_id}`

### Claims / Evidence / Payouts

* `POST /claims` → 用 `order_ref` 建理赔单
* `POST /claims/{claim_id}/verify` → 调 JP 拉证据，计算赔付
* `GET /claims/{claim_id}` → 查理赔状态
* `POST /claims/{claim_id}/payout` → 发起赔付（链上）
* `GET /claims/{claim_id}/evidence`、`GET /claims/{claim_id}/evidence/download`
* `POST /evidence/{evidence_id}/onchain`（可选，管理员）

### JP 验证微服务

* `POST /verify/exchange-api` → 校验 API Key 可用性（只读）
* `POST /verify/order` → 拉订单原始信息
* `POST /verify/liquidation` → 判断强平/ADL 与时间点

---

# 数据库字段明细（逐表中文解释）

### wallets

* `wallet_address`：用户主键（链上地址）。
* 其他为审计字段。

### sessions

* `session_token`：鉴权令牌；到期重登。
* `expires_at`：过期时间；绝不长期有效。

### skus

* `code`：短码，如 `24H_LIQ`。
* `pricing_json`：参数化定价（例：窗口=24h、赔付上限、比例、load、运营费）。
* `active`：上下架控制。

### exchange_accounts

* `account_uid`：交易所内唯一 ID，用来定位账号。
* `encrypted_payload`：密钥加密存储体。
* `permissions_json`：记录权限（只读）。

### api_verifications_log

* `result_ok`：1=校验通过，0=失败。
* `error_json`：失败详情，**不含明文密钥**。

### orders

* `order_ref`：外部订单号（用户在交易所的编号）。
* `unit_price_usdc / total_amount_usdc`：microUSDC。
* `status`：`pending|paid|expired|cancelled`。
* `created_at_epoch`：用于倒序分页。

### payments

* `method`：`usdc_permit2` 或 `usdc_approve`。
* `tx_hash`：链上交易哈希。
* `status`：`pending|confirmed|failed`。

### claims

* `status`：

  * `draft`（刚创建）
  * `verifying`（拉证据与计算中）
  * `eligible/ineligible`（可赔/不可赔）
  * `payout_pending/sent/confirmed/failed`（赔付执行与结果）
* `payout_amount_usdc`：核定的赔付额。
* `evidence_id`：对应证据记录。
* `reasons_json`：为何可赔/不可赔的可读列表。

### evidence

* `raw_order_json`：原始订单数据（来自 JP）。
* `liquidation_json`：强平/ADL 证据。
* `merkle_root / proof_json`：如做批量上链。
* `source_dir`：本地/对象存储路径（便于追溯）。

### payouts

* `dest_wallet`：赔付接收地址（默认下单钱包）。
* `onchain_tx_id`：内部跟踪 ID。
* `status`：同上。

### onchain_txs

* `status`：`pending|confirmed|failed`；由监听器更新。
* `receipt_json`：链上回执全文（调试与审计）。

### audit_logs（可选）

* 记录谁在何时对哪个对象做了什么操作，payload 快照留痕。

---

# 状态与页面关系（一句话版）

* `/buy` 支付成功 → `/claims/payout` 创建与校验 → 可赔 → 发起赔付 → `/evidence/:claimId` 查看证据与上链 → `/orders` 看历史 → `/dashboard` 汇总。

---

# 幂等 + 安全要点（落地必看）

* **幂等键**：客户端生成，服务端 `idempotency_keys` 表缓存 24h；重复请求直接返回第一次结果。
* **签名会话**：`session_token` 关联 `wallet_id`；敏感写操作二次校验“调用方钱包 == 订单/理赔归属钱包”。
* **金额**：永远整数（microUSDC）。
* **密钥**：默认不保存；若保存，必须加密，脱敏展示 `last4`。
* **回调**：链上支付与赔付用监听或轮询更新 `onchain_txs`，再反写 `payments/payouts/claims`。
* **权限**：管理员接口（如 `onchain` 补录）加 RBAC/ENV 开关。

---

# 错误码建议（示例）

* `AUTH_REQUIRED` 未登录
* `CHAIN_MISMATCH` 未在 Base
* `INVALID_KEYS` 交易所密钥无效
* `ORDER_NOT_FOUND` 未找到订单
* `ORDER_NOT_PAID` 订单未支付
* `EVIDENCE_INSUFFICIENT` 证据不足
* `CLAIM_ALREADY_PAID` 已赔付
* `IDEMPOTENT_REPLAY` 幂等重复

---

# 环境变量（最小集）

```
ENV=dev|prod
BASE_RPC_URL=...
BASE_CHAIN_ID=8453
USDC_CONTRACT=0x...
TREASURY_WALLET=0x...
TREASURY_PRIVATE_KEY=...
PERMIT2_ADDRESS=0x...        # 如使用
JP_VERIFY_BASE_URL=https://jp-verify.internal
SESSION_TOKEN_SECRET=...
SQLITE_DB_PATH=./data/app.db
```

中文解释：RPC 与链 ID 指向 Base；USDC 合约用于支付与赔付；财库地址与私钥只在 US 后端使用；JP_VERIFY_BASE_URL 指 JP 微服务地址；会话密钥用于签发 `session_token`；SQLite 路径本地可用，线上换 PG 亦可。

---

# 给 AI 的执行提示（直接抄用）

* 先按上面**数据库字段**生成迁移（SQLite/Prisma/Knex 均可）。
* 后端建两个服务：`us-backend` 与 `jp-verify`，按“接口清单”逐个实现。
* 前端建路由：`/settings/wallet → /settings/exchange-api → /buy → /claims/payout → /orders → /evidence/:claimId → /dashboard`。
* 每个写操作都自动注入 `X-Session-Token` 与 `Idempotency-Key`。
* 金额统一 `microUSDC`。
* `order_ref` 做唯一或加联合唯一（wallet_id+order_ref）。
* 验证流程：`/claims` 后立即调用 `/claims/{id}/verify`，UI 显示进度条，完成后给“发起赔付”按钮。
* 赔付落地：调用合约或内部记账模拟，产出 `tx_hash`，进入监听队列，确认后把 `claims` 标为 `payout_confirmed`。

---

需要我把以上**转换成可执行的 OpenAPI 3.1 草案**与**SQL 迁移文件**，我现在就给。
