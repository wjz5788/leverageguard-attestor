import React, { useEffect, useMemo, useState } from "react";

/**
 * LiqPass · 理赔页 MVP（入口仅在订单卡）
 * - 两个路由视图：
 *   1) /profile/claims   → 理赔列表（倒序，含链上Tx图标）
 *   2) /claims/new?orderId=... → 发起理赔（表单+核验结果+赔付按钮）
 * - 用户出 gas，合约把 USDC 打给用户（此处模拟钱包与链上交易，返回 txHash 占位符）。
 * - 仅前端演示，可直接替换后台 API 与合约交互。
 *
 * 接口与合约对接点（可替换）：
 *   - POST /claims/prepare → claimToken
 *   - POST /claims/verify  → { eligible, payout, evidence, claimId, voucher(EIP-712), txCall }
 *   - 钱包调用 claimPayout(Claim c, bytes attestorSig) on Base(8453)
 *   - POST /claims/:id/record-onchain { txHash }
 */

// =========================
// 常量与类型
// =========================
const CONFIG = {
  API_BASE: "", // 真实部署时填入 us-backend 地址
  CHAIN_ID: 8453, // Base Mainnet
  EXPLORER_TX: (tx: string) => `https://basescan.org/tx/${tx}`,
  CONTRACT: "0xLeverageGuard", // 占位符：真实合约地址
};

// 订单摘要（只读带出）
interface OrderSummary {
  orderId: string; // 内部订单ID（UUID/雪花）
  orderRef?: string; // 交易所订单号（可输入）
  principal: number; // 本金
  leverage: number;  // 杠杆
  premiumPaid: number; // 已支付保费
  payoutMax: number;   // 赔付上限
  coverage: { start: string; end: string }; // 覆盖窗口 ISO8601
  exchangeAccountId: string; // 绑定账号ID
}

// 证据与核验
interface EvidenceEcho { orderIdLast4?: string; qty?: number }
interface EvidenceInfo {
  type: "LIQUIDATION" | "ADL" | string;
  time: string; // ISO8601
  pair: string; // 例：BTC-USDT-PERP
  echo?: EvidenceEcho;
  merkleRoot?: string;
}

interface VoucherTypedData {
  domain: any; // EIP-712 domain
  types: any;  // EIP-712 types
  values: any; // Claim struct values
  signature: string; // 后端/多签签发
}

interface TxCallSpec {
  contract: string;
  function: "claimPayout";
  args: any; // 与合约ABI一致的参数列表或对象
  chainId: number; // 8453
}

interface VerifyResponse {
  eligible: boolean;
  payout: number; // USDC 数额
  currency: "USDC";
  evidence: EvidenceInfo;
  claimId: string; // clm_xxx
  voucher: VoucherTypedData; // 用于链上 claimPayout
  txCall: TxCallSpec;
  reasons: string[]; // 不可赔原因
  expiresAt?: string; // 凭证过期时间（可选）
}

type ClaimStatus = "in_review" | "approved" | "paid" | "rejected" | "onchain_failed";

interface ClaimRecord {
  id: string; // claimId
  orderId: string;
  payout: { amount: number; currency: string };
  status: ClaimStatus;
  txHash?: string;
  createdAt: string;
  evidence?: EvidenceInfo;
}

// =========================
// 本地存储（演示）
// =========================
const LS_KEYS = {
  CLAIMS: "liqpass:claims",
};

const loadClaims = (): ClaimRecord[] => {
  try { return JSON.parse(localStorage.getItem(LS_KEYS.CLAIMS) || "[]"); } catch { return []; }
};
const saveClaims = (rows: ClaimRecord[]) => localStorage.setItem(LS_KEYS.CLAIMS, JSON.stringify(rows));

// =========================
// Demo 订单（模拟从订单卡跳入）
// =========================
const DEMO_ORDER: OrderSummary = {
  orderId: "ord_demo_001",
  principal: 250,
  leverage: 40,
  premiumPaid: 3.25,
  payoutMax: 75,
  coverage: { start: "2025-10-26T00:00:00Z", end: "2025-10-27T00:00:00Z" },
  exchangeAccountId: "ex_acc_7af2",
};

// =========================
// API 模拟（替换为真实 fetch）
// =========================
async function apiClaimsPrepare(order: OrderSummary): Promise<{ claimToken: string }> {
  // 实际应：POST /claims/prepare { orderId } → { claimToken }
  await sleep(300);
  return { claimToken: `ct_${Math.random().toString(36).slice(2)}` };
}

async function apiClaimsVerify(input: {
  order: OrderSummary;
  orderRef?: string;
  claimToken: string;
}): Promise<VerifyResponse> {
  // 实际应：POST /claims/verify { orderId, exchangeAccountId, orderRef, claimToken }
  await sleep(600);
  const now = new Date();
  return {
    eligible: true,
    payout: 48.5,
    currency: "USDC",
    evidence: {
      type: "LIQUIDATION",
      time: new Date(now.getTime() - 3 * 60 * 1000).toISOString(),
      pair: "BTC-USDT-PERP",
      echo: { orderIdLast4: (input.orderRef || "8a3f").slice(-4), qty: 581.4 },
      merkleRoot: "0x7e6f...abcd",
    },
    claimId: `clm_${Math.random().toString(36).slice(2, 8)}`,
    voucher: buildDemoVoucher(input.order, 48.5),
    txCall: {
      contract: CONFIG.CONTRACT,
      function: "claimPayout",
      args: { /* Claim struct + sig 见 voucher.values 与 voucher.signature */ },
      chainId: CONFIG.CHAIN_ID,
    },
    reasons: [],
    expiresAt: new Date(now.getTime() + 30 * 60 * 1000).toISOString(),
  };
}

async function apiClaimsRecordOnchain(id: string, txHash: string): Promise<{ ok: boolean }>{
  // 实际应：POST /claims/:id/record-onchain { txHash }
  await sleep(300);
  return { ok: true };
}

function buildDemoVoucher(order: OrderSummary, amount: number): VoucherTypedData {
  const domain = {
    name: "LiqPassClaims",
    version: "1",
    chainId: CONFIG.CHAIN_ID,
    verifyingContract: CONFIG.CONTRACT,
  };
  const types = {
    Claim: [
      { name: "orderDigest", type: "bytes32" },
      { name: "claimId", type: "bytes32" },
      { name: "beneficiary", type: "address" },
      { name: "amount", type: "uint256" },
      { name: "evidenceRoot", type: "bytes32" },
      { name: "expiry", type: "uint64" },
      { name: "nonce", type: "uint256" },
    ],
  };
  const values = {
    orderDigest: "0x1111...",
    claimId: "0x2222...",
    beneficiary: "0xYourWallet", // 前端用户钱包地址（演示占位）
    amount: amount * 1e6, // USDC 6位精度
    evidenceRoot: "0x7e6f...abcd",
    expiry: Math.floor(Date.now() / 1000) + 30 * 60,
    nonce: Date.now(),
  };
  return { domain, types, values, signature: "0xSig_Attestor" };
}

// 模拟钱包发交易（此处仅生成伪 txHash）
async function walletSendClaimPayout(voucher: VoucherTypedData): Promise<string> {
  // 真实实现应：
  // 1) 确认链为 Base(8453)
  // 2) 使用 ethers/viem 调用合约 claimPayout(values, signature)
  // 3) 等待交易上链，返回 tx.hash
  await sleep(1000);
  return randomTxHash();
}

const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));
const randomTxHash = () => "0x" + Array.from({ length: 64 }, () => Math.floor(Math.random()*16).toString(16)).join("");

// =========================
// 纯函数与自测（避免无效字符/转义问题）
// =========================
export function parseRouteHash(rawHash: string): "list" | "new" {
  // 清理可能的不可见字符（零宽空格/方向标记/段分隔符）
  const clean = rawHash.replace(/[\u2028\u2029\u200B\u200E\u200F]/g, "");
  return clean.startsWith("#/claims/new") ? "new" : "list";
}

export function claimStamp(c: Pick<ClaimRecord, "createdAt" | "evidence">): number {
  const t1 = Date.parse((c as any).createdAt || "");
  const t2 = c.evidence?.time ? Date.parse(c.evidence.time) : 0;
  return Number.isFinite(t1) ? t1 : t2;
}

(function runSelfTests() {
  try {
    // 路由解析测试
    const T: Array<[string, "list"|"new"]> = [
      ["#/claims", "list"],
      ["#/claims/new", "new"],
      ["#/claims/new?orderId=abc", "new"],
      ["#/something-else", "list"],
      ["\u200B#/claims/new", "new"], // 含零宽空格
    ];
    for (const [h, exp] of T) {
      const got = parseRouteHash(h);
      if (got !== exp) throw new Error(`parseRouteHash(${h}) => ${got}, expected ${exp}`);
    }

    // 时间戳排序测试
    const rows: any[] = [
      { createdAt: "", evidence: { time: "2025-01-02T00:00:00Z" } },
      { createdAt: "2025-01-03T00:00:00Z" },
      { createdAt: "2025-01-01T00:00:00Z" },
    ];
    const sorted = [...rows].sort((a,b) => claimStamp(b) - claimStamp(a));
    const ok = claimStamp(sorted[0]) >= claimStamp(sorted[1]) && claimStamp(sorted[1]) >= claimStamp(sorted[2]);
    if (!ok) throw new Error("claimStamp sort failed");

    // 控制台提示
    if (typeof console !== "undefined") console.debug("[LiqPass Claims] self-tests passed");
  } catch (err) {
    if (typeof console !== "undefined") console.error("[LiqPass Claims] self-tests FAILED:", err);
  }
})();

// =========================
// UI 组件
// =========================
export default function ClaimsMVP() {
  const route = useRoute();

  return (
    <div className="min-h-screen bg-[#FFF7ED] text-[#3F2E20]">
      <Header />
      <main className="mx-auto max-w-4xl p-4 sm:p-6">
        {route.name === "list" && <ClaimsList />}
        {route.name === "new" && <NewClaimView />}
      </main>
    </div>
  );
}

function Header() {
  const route = useRoute();
  return (
    <div className="border-b border-stone-200/80 bg-white/70 backdrop-blur supports-[backdrop-filter]:bg-white/60 sticky top-0 z-10">
      <div className="mx-auto max-w-4xl p-4 flex items-center justify-between">
        <a href="#/claims" className="font-semibold tracking-tight">LiqPass</a>
        <nav className="flex gap-3 text-sm">
          <a className={navCls(route.name === "list")} href="#/claims">理赔列表</a>
          <a className={navCls(route.name === "new")} href="#/claims/new">发起理赔</a>
        </nav>
      </div>
    </div>
  );
}

function navCls(active: boolean) {
  return `px-3 py-1.5 rounded-xl ${active?"bg-stone-900 text-white":"hover:bg-stone-100"}`;
}

function ClaimsList() {
  const [rows, setRows] = useState<ClaimRecord[]>(loadClaims());
  useEffect(() => { saveClaims(rows); }, [rows]);

  // 倒序显示（按 createdAt 优先，退化到 evidence.time）
  const data = useMemo(() => {
    const stamp = (c: ClaimRecord) => claimStamp(c);
    return [...rows].sort((a,b) => stamp(b) - stamp(a));
  }, [rows]);

  const localTime = (c: ClaimRecord) => {
    const s = (c as any).createdAt || c.evidence?.time || "";
    if (!s) return "-";
    const d = new Date(s);
    return isNaN(d.getTime()) ? s : d.toLocaleString();
  };

  const goNew = () => { window.location.hash = `#/claims/new?orderId=${encodeURIComponent(DEMO_ORDER.orderId)}`; };

  return (
    <section className="space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-xl font-semibold">理赔</h1>
        <button onClick={goNew} className="px-3 py-2 rounded-xl bg-stone-900 text-white">从订单卡发起</button>
      </div>

      {data.length === 0 && (
        <EmptyCard title="暂无理赔">从订单卡点击“发起理赔”开始</EmptyCard>
      )}

      <div className="grid gap-3">
        {data.map((c) => (
          <div key={c.id} className="rounded-2xl border border-stone-200 bg-white p-4">
            <div className="flex items-center justify-between">
              <div className="font-medium">{c.payout.amount} {c.payout.currency}</div>
              <StatusBadge status={c.status} />
            </div>
            <div className="mt-1 text-sm text-stone-600">ClaimID: {c.id} · 订单: {c.orderId} · {localTime(c)}</div>
            {c.txHash && (
              <div className="mt-2 text-sm">
                <a className="underline" href={CONFIG.EXPLORER_TX(c.txHash)} target="_blank" rel="noreferrer">链上交易</a>
              </div>
            )}
          </div>
        ))}
      </div>
    </section>
  );
}

function StatusBadge({ status }: { status: ClaimStatus }) {
  const map: Record<ClaimStatus, string> = {
    in_review: "bg-amber-100 text-amber-900",
    approved: "bg-emerald-100 text-emerald-900",
    paid: "bg-emerald-600 text-white",
    rejected: "bg-rose-100 text-rose-900",
    onchain_failed: "bg-rose-200 text-rose-900",
  };
  const label: Record<ClaimStatus, string> = {
    in_review: "审核中",
    approved: "已批准",
    paid: "已赔付",
    rejected: "已拒绝",
    onchain_failed: "链上失败",
  };
  return <span className={`text-xs px-2 py-1 rounded-lg ${map[status]}`}>{label[status]}</span>;
}

function NewClaimView() {
  const query = new URLSearchParams(window.location.hash.split("?")[1] || "");
  const incomingOrderId = query.get("orderId") || DEMO_ORDER.orderId;
  const [order, setOrder] = useState<OrderSummary>({ ...DEMO_ORDER, orderId: incomingOrderId });
  const [orderRef, setOrderRef] = useState("");
  const [isPrep, setIsPrep] = useState(false);
  const [claimToken, setClaimToken] = useState<string | null>(null);
  const [verifying, setVerifying] = useState(false);
  const [verifyRes, setVerifyRes] = useState<VerifyResponse | null>(null);
  const [confirm, setConfirm] = useState(false);
  const [paying, setPaying] = useState(false);

  // 第一步：prepare
  const ensurePrepare = async () => {
    if (claimToken) return claimToken;
    setIsPrep(true);
    const { claimToken: ct } = await apiClaimsPrepare(order);
    setClaimToken(ct);
    setIsPrep(false);
    return ct;
  };

  const onVerify = async () => {
    const ct = await ensurePrepare();
    setVerifying(true);
    try {
      const res = await apiClaimsVerify({ order, orderRef, claimToken: ct });
      setVerifyRes(res);
    } finally {
      setVerifying(false);
    }
  };

  const onPayout = async () => {
    if (!verifyRes) return;
    setPaying(true);
    try {
      const txHash = await walletSendClaimPayout(verifyRes.voucher);
      await apiClaimsRecordOnchain(verifyRes.claimId, txHash);
      // 写入列表
      const newRow: ClaimRecord = {
        id: verifyRes.claimId,
        orderId: order.orderId,
        payout: { amount: verifyRes.payout, currency: verifyRes.currency },
        status: "paid",
        txHash,
        createdAt: new Date().toISOString(),
        evidence: verifyRes.evidence,
      };
      const rows = loadClaims();
      rows.push(newRow);
      saveClaims(rows);
      // 跳转回列表
      window.location.hash = "#/claims";
    } catch (e) {
      alert("链上赔付失败：" + (e as Error).message);
    } finally {
      setPaying(false);
    }
  };

  return (
    <section className="space-y-4">
      <h1 className="text-xl font-semibold">发起理赔</h1>

      <div className="rounded-2xl border border-stone-200 bg-white p-4">
        <div className="font-medium mb-2">订单摘要（只读）</div>
        <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm">
          <RoField label="Order ID" value={order.orderId} />
          <RoField label="Account" value={order.exchangeAccountId} />
          <RoField label="Principal" value={`${order.principal} USDT`} />
          <RoField label="Leverage" value={`${order.leverage}x`} />
          <RoField label="Premium Paid" value={`${order.premiumPaid} USDC`} />
          <RoField label="Payout Max" value={`${order.payoutMax} USDC`} />
          <RoField label="Coverage Start" value={order.coverage.start} />
          <RoField label="Coverage End" value={order.coverage.end} />
        </div>
      </div>

      <div className="rounded-2xl border border-stone-200 bg-white p-4 space-y-3">
        <label className="block text-sm font-medium">交易所订单号 orderRef</label>
        <input
          className="w-full px-3 py-2 rounded-xl border border-stone-300 focus:outline-none focus:ring-2 focus:ring-stone-400/50"
          placeholder="请输入交易所订单号"
          value={orderRef}
          onChange={(e) => setOrderRef(e.target.value)}
        />
        <div className="flex gap-2">
          <button onClick={onVerify} disabled={verifying || isPrep}
                  className="px-4 py-2 rounded-xl bg-stone-900 text-white disabled:opacity-50">
            {verifying || isPrep ? "验证中..." : "验证"}
          </button>
        </div>
      </div>

      {verifyRes && (
        <div className="rounded-2xl border border-stone-200 bg-white p-4 space-y-4">
          <div className="flex items-center justify-between">
            <div className="font-medium">核验结果</div>
            <span className={`text-xs px-2 py-1 rounded-lg ${verifyRes.eligible?"bg-emerald-100 text-emerald-900":"bg-rose-100 text-rose-900"}`}>
              {verifyRes.eligible?"可赔付":"不可赔"}
            </span>
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-3 gap-3 text-sm">
            <RoField label="Payout" value={`${verifyRes.payout} ${verifyRes.currency}`} />
            <RoField label="Claim ID" value={verifyRes.claimId} />
            <RoField label="Expires At" value={verifyRes.expiresAt || "-"} />
          </div>

          <div className="text-sm">
            <div className="font-medium mb-1">证明片段 Evidence</div>
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
              <RoField label="Type" value={verifyRes.evidence.type} />
              <RoField label="Time" value={verifyRes.evidence.time} />
              <RoField label="Pair" value={verifyRes.evidence.pair} />
              <RoField label="Echo" value={`...${verifyRes.evidence.echo?.orderIdLast4 || "????"}, qty=${verifyRes.evidence.echo?.qty ?? "?"}`} />
              <RoField label="Merkle Root" value={verifyRes.evidence.merkleRoot || "-"} />
            </div>
          </div>

          <details className="rounded-xl border border-stone-200 p-3 bg-stone-50/60">
            <summary className="cursor-pointer text-sm font-medium">EIP-712 凭证 Voucher（调试用）</summary>
            <pre className="text-xs mt-2 whitespace-pre-wrap break-words">{JSON.stringify(verifyRes.voucher, null, 2)}</pre>
          </details>

          <div className="flex items-center gap-2">
            <label className="text-sm flex items-center gap-2">
              <input type="checkbox" checked={confirm} onChange={(e)=>setConfirm(e.target.checked)} />
              我已确认核验结果与赔付金额
            </label>
            <div className="flex-1" />
            <button
              className="px-4 py-2 rounded-xl bg-stone-900 text-white disabled:opacity-50"
              disabled={!verifyRes.eligible || !confirm || paying}
              onClick={onPayout}
            >
              {paying?"链上赔付中...":"赔付（你付gas）"}
            </button>
          </div>

          {verifyRes.txCall && (
            <details className="rounded-xl border border-stone-200 p-3 bg-stone-50/60">
              <summary className="cursor-pointer text-sm font-medium">链上调用参数 txCall（调试用）</summary>
              <pre className="text-xs mt-2 whitespace-pre-wrap break-words">{JSON.stringify(verifyRes.txCall, null, 2)}</pre>
            </details>
          )}
        </div>
      )}

      <HelpCard />
    </section>
  );
}

function RoField({ label, value }: { label: string; value: React.ReactNode }) {
  return (
    <div className="flex items-center justify-between rounded-xl border border-stone-200 px-3 py-2 bg-white">
      <div className="text-stone-500 text-xs">{label}</div>
      <div className="text-sm font-medium ml-3 truncate max-w-[60%] text-right">{value}</div>
    </div>
  );
}

function EmptyCard({ title, children }: { title: string; children?: React.ReactNode }) {
  return (
    <div className="rounded-2xl border border-dashed border-stone-300 p-8 text-center">
      <div className="text-sm text-stone-500">{title}</div>
      {children && <div className="mt-2 text-xs text-stone-400">{children}</div>}
    </div>
  );
}

function HelpCard() {
  return (
    <div className="rounded-2xl border border-stone-200 bg-white p-4">
      <div className="font-medium mb-1">最小落地规范 · 说明</div>
      <ul className="list-disc pl-5 text-sm space-y-1 text-stone-700">
        <li>入口仅在订单卡：从订单卡跳转到 <code>/claims/new?orderId=...</code>，订单与账号均锁定。</li>
        <li>核验返回：<code>eligible, payout, currency, evidence</code> 与 <code>claimId, expiresAt</code>。</li>
        <li>赔付按钮入参：<code>contract, chainId, function="claimPayout", args, signature</code>（EIP-712 凭证）。</li>
        <li>用户出 gas，合约从资金库/授权额度中 <code>transfer USDC</code> 到用户钱包。</li>
        <li>成功后回写 <code>/claims/:id/record-onchain</code> 并在列表显示链上图标链接。</li>
        <li>状态：<code>in_review | approved | paid | rejected | onchain_failed</code>；MVP 默认直接 <code>paid</code>。</li>
        <li>风险与幂等：同一订单仅允许 1 笔活动理赔；<code>claimToken</code> + <code>nonce</code> 防重放；<code>expiry</code> 30 分钟。</li>
      </ul>
    </div>
  );
}

// =========================
// 简易路由（hash）
// =========================
function useRoute(): { name: "list" | "new" } {
  const [hash, setHash] = useState<string>(() => window.location.hash);
  useEffect(() => {
    const on = () => setHash(window.location.hash);
    window.addEventListener("hashchange", on);
    return () => window.removeEventListener("hashchange", on);
  }, []);
  return { name: parseRouteHash(hash) };
}
