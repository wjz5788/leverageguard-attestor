给出“证据链页·详细规范（小白友好版）”。所有英文名词后都带中文解释。零代码。

# 证据链页 · 详细规范（带中英对照）

## 1) 目标

把一次理赔从“交易所原始数据”到“链上证明”串起来。人能看懂，自己能复算，链上可核验。

## 2) 路由与入口

* `/evidence/:claimId`

  * `claimId（理赔单 ID）`：唯一标识一笔理赔。
* 备用：`/evidence?orderRef=...`

  * `orderRef（交易所订单号）`：Binance/OKX 的订单号，服务器会先查到 `claimId` 再跳转。

## 3) 页面结构（6 块）

1. **概要**

   * `claimId（理赔单 ID）`
   * `orderRef（交易所订单号）`
   * `exchange（交易所）`：`Binance（币安）` 或 `OKX（欧易）`
   * `event（事件类型）`：`LIQUIDATION（强平）` 或 `ADL（自动减仓）`
   * `eligible（是否可赔，布尔值）`：`true/false`
   * `payoutUSDC（赔付金额，USDC 计价）`
   * `receiver（收款地址，EVM 链地址）`
   * `attestor（证明合约地址，Base 链）`
   * `payoutTx（赔付交易哈希，tx hash，可选）`
   * `attestTx（上链证明交易哈希）`
   * `blockNumber（区块号）`
   * `decidedAt / attestedAt（判定时间/上链时间，ISO-8601 UTC 时间）`
2. **原始取证（已脱敏）**

   * 展示调用过的 `endpoint（接口地址）`、`method（HTTP 方法，如 GET/POST）`、`query/body（请求参数/请求体）` 摘要。
   * `headers（请求头）`中的签名值全部打 `***`。
   * 可下载 `raw.json（原始响应打包，已脱敏）`。
3. **规范证据 `leaf（叶子）`**

   * 展示 `leaf.json（规范化 JSON 文件）`包含的字段（见第 6 节）。
   * `leafHash（叶子哈希）`：用 `keccak256（以太坊常用哈希算法）` 对 `leaf.json` 计算出的 32 字节哈希（`0x` 开头十六进制）。
   * 可下载 `leaf.json`。
4. **Merkle（默克尔）证明**

   * `merkleRoot（默克尔根）`：整批证据汇总的顶层哈希。
   * `proof[]（证明数组）`：自下而上每一层的“兄弟哈希”。
   * 说明计算规则（见第 5.3 节）。
   * 可下载 `proof.json（包含 leafHash、proof 数组、merkleRoot）`。
5. **链上佐证**

   * `attestor（证明合约）`地址（Base 主网）。
   * 事件 `ClaimAttested（已证明事件）`：参数 `claimId, merkleRoot, payout, receiver`。
   * `basescan（区块浏览器）`链接：`attestTx/payoutTx` 可点开查看。
6. **校验结果**

   * 三个徽标：`LEAF_OK（叶子一致）`、`PROOF_OK（证明通过）`、`ONCHAIN_OK（链上一致）`。
   * 任一失败给出错误码与建议。

## 4) 取证来源（最小端点集）

* `Binance（币安）`：

  * `/api/v3/account（账户只读）`
  * `/fapi/v1/order（合约订单）` 或相关成交/强平端点
* `OKX（欧易）`：

  * `/api/v5/account/balance（余额）`
  * `/api/v5/trade/order（订单）` 或公开强平查询等

> 你无需记细节。页面只展示“从哪些只读端点拿到什么关键信息”。

## 5) 规范化与哈希（核心规则）

### 5.1 `canonical JSON（规范 JSON）` 规则

* 编码 `UTF-8（通用字符编码）`；整份 JSON **单行**输出。
* 键名顺序：**字典序 A→Z**，并且**递归**地对所有对象都这样排序。
* 数字全部转成**字符串**（十进制）。例如数量、价格、`payoutUSDC`。
* 时间 `ts（时间戳）`：用 `Unix 秒（自 1970 起的秒数）`，也以字符串存。
* 布尔 `true/false` 照常。空值不写。
* 目的：不同机器导出的 `leaf.json` 只要内容相同，字节也完全一致，哈希就能一致。

### 5.2 `leafHash（叶子哈希）`

* 计算：`keccak256(bytes(leaf.json))`。
* 展示格式：小写十六进制，`0x` 开头，长度 66（含前缀）。

### 5.3 `Merkle（默克尔）树` 构造

* 叶子排序：按 `(ts, orderRef)` 升序；相同再按 `leafHash` 升序。
* 两两拼接：对一对哈希 `(a,b)`，先取字节序**较小**的做左边 `L=min(a,b)`，较大做右边 `R=max(a,b)`，再算 `keccak256(L||R)`。
* 单数处理：本层若有“落单”的一个叶子，采用“**与自身拼接**”方式提升。
* 重复聚合直至剩一个哈希，即 `merkleRoot`。
* `proof[]`：自下而上记录每一层的“兄弟哈希”。因为每层都做了 `min/max` 排序，所以**不需要**记录“左或右”的方向。

## 6) `leaf（叶子）`字段（最小必要集）

* `claimId（理赔单 ID）`
* `exchange（交易所）`：`Binance` 或 `OKX`
* `event（事件类型）`：`LIQUIDATION` 或 `ADL`
* `orderRef（交易所订单号）`
* `symbol（交易对）`：如 `BTCUSDT`（币安）或 `BTC-USDT`（欧易）
* `leverage（杠杆倍数）`：字符串
* `pnl（本次盈亏）`：字符串，可为负
* `payoutUSDC（赔付金额，USDC）`：字符串，两位小数
* `wallet/receiver（收款地址）`：以太坊地址，建议 `EIP-55（校验和格式）`
* `ts（事件秒级时间戳）`：字符串
* `evidenceId（证据记录 ID，可选）`

> 字段越少越稳。增加字段会改变哈希，从而改变 `merkleRoot`。

## 7) 接口（只读）

* `GET（读取） /claims/{claimId}/evidence` → 页面概要、`leafHash`、`merkleRoot`、`attestTx/payoutTx`、`downloads（下载链接）`、`evidenceSummary（人类可读摘要）`
* `GET /evidence/{id}/raw.json` → 原始响应打包，已脱敏
* `GET /evidence/{id}/leaf.json` → 规范化叶
* `GET /evidence/{id}/proof.json` → `{leafHash, merkleRoot, proof[]}`
* `GET /attestations/{claimId}` → 解析链上事件（含 `blockNumber`）

## 8) 离线校验（自己验证的 4 步）

1. **叶一致**：对 `leaf.json` 做 `keccak256` 得到 `H0`，比对页面 `leafHash`。
2. **还原根**：用 `proof[]` 逐层计算 `Hi+1 = keccak256(min(Hi,Si)||max(Hi,Si))`，得到 `Root'`。
3. **链上一致**：打开 `attestTx`（basescan），事件中的 `merkleRoot` 必须等于 `Root'`，`claimId` 也应匹配。
4. **赔付核对**（如已支付）：打开 `payoutTx`，看 USDC `Transfer（转账事件）`：`to=receiver`，`value = payoutUSDC × 10^6（USDC 精度 6）`。

## 9) 错误码（看不通过的原因）

* `NO_EVIDENCE（无证据）`：没有这笔记录。
* `INTEGRITY_FAIL（叶校验失败）`：`leaf.json` 与 `leafHash` 对不上。
* `PROOF_FAIL（证明失败）`：`proof[]` 无法还原到 `merkleRoot`。
* `ONCHAIN_MISMATCH（链上不一致）`：链上事件的根与页面根不同。
* `REDACTION_BREACH（脱敏违规）`：发现疑似密钥/签名泄露，禁止展示与下载。

## 10) 安全与隐私

* 永不入库：`apiKey/secret/passphrase（交易所密钥/密语）`。
* `raw.json` 仅脱敏后提供下载，设置 `TTL（有效期，例如 7 天）`。
* 所有哈希统一格式：小写、`0x` 前缀、长度 66。
* 下载用**签名 URL（带短期授权的链接）**与限速，防止批量爬取。

## 11) 性能与尺寸

* 单笔 `raw.json` ≤ `1 MiB（约 1 兆字节）`；超过则分片下载（part1/part2/part3）。
* 首屏（概要+叶/根）≤ 1 秒；原始取证块懒加载。
* 服务器计算 `rawDigest（原始包摘要） = sha256（把每个响应 sha256 后按名称排序再拼接）`，用于审计唯一性。

## 12) 审计与留痕

* 只记录：`claimId, orderRef, exchange, evidenceId, leafHash, merkleRoot, attestTx, payoutTx?, decidedAt, attestedAt, rawDigest`。
* 不记录：任何敏感 `header/body`。
* 上链后设为**只读**；若发现错误，用 `supersededBy（被新记录替代）` 标注废止链。

## 13) 与赔付页联动

* 赔付成功页提供“查看证据链”按钮 → `/evidence/:claimId`。
* 若赔付已完成但尚未上链证明：显示 `Attestation pending（等待上链）` 并每 5 秒轮询。

## 14) BDD（行为用例）

1. **全绿通**：三绿标 `LEAF_OK/PROOF_OK/ONCHAIN_OK`，三个文件都能下载。
2. **叶被改动**：用户改动 `leaf.json` 后复算不等 → 标红 `INTEGRITY_FAIL`。
3. **证明缺层**：`proof[]` 少一项 → 计算不到根 → 标红 `PROOF_FAIL`。
4. **链上不一致**：事件根不同 → 标红 `ONCHAIN_MISMATCH` 并给出 tx 链接。
5. **大包分片**：`raw.json` > 1 MiB → 显示 `raw (3 parts)`，可逐个下载。
6. **脱敏检查**：检测到 `apiKey` 模式串 → 拒绝下载，报 `REDACTION_BREACH`。

## 15) 验收标准

* 同一 `claimId`：`leafHash`、`merkleRoot` 与 `attestTx` 事件里的根完全一致。
* 第 8 节 4 步任何人可独立复算通过。
* 三个下载链接有效，在 `TTL` 内可重复获取。
* 敏感信息零泄露（抽查通过）。
* 404/失败码有明确提示与返回入口。

> 记忆法：**看叶子（leaf）、走证明（proof）、对根（root）、查链（attestTx/payoutTx）**。


4) Claims · Payout（理赔与赔付）

前端路由：/claims/payout

页面目的：输入 order_ref → 系统从 JP 拉证据 → 判断是否可赔 → 可赔则上链赔付。

表单字段

order_ref：用户输入或从“最近订单”选择

destination_wallet?：可选，默认使用下单钱包

操作流程 / Flow

POST /claims（US）用 order_ref 创建理赔单

Req：{ "order_ref":"2938801601245126656" }

Res：{ "claim_id":"...", "order_id":"...", "claim_status":"draft" }

POST /claims/{claim_id}/verify（US 协调 JP）

US 调 JP：

POST /verify/order（JP）：{ exchange, order_ref } → {"found":true, "order_json":{...}}

POST /verify/liquidation（JP）：{ exchange, order_ref } → {"is_liquidated":true, "adl":false, "timestamp":..., "snapshots":[...]}

US 计算赔付：窗口、阈值、上限、比例等（依据 sku.pricing_json）

最终返回：

{
  "eligible": true,
  "payout_amount_usdc": 5000000,
  "reasons": ["Liquidation inside 24h window"],
  "evidence_id": "d1782897-a5c9-498d-9f8e-4b9ef2f82ec6",
  "claim_status":"eligible"
}


同步落库：claims.status、claims.payout_amount_usdc、evidence.*

POST /claims/{claim_id}/payout（US）

Req：{ "destination_wallet":"0xUser..." }（可省略）

Res：{ "payout_id":"...", "onchain_tx_id":"...", "tx_hash":"0x...", "status":"payout_pending" }

轮询：GET /claims/{claim_id} 直到 payout_confirmed

理赔状态机 / Claim states

draft → verifying → eligible | ineligible →
若 eligible：payout_pending → payout_sent → payout_confirmed
失败：payout_failed

数据库 / DB

claims(id, order_id, wallet_id, status, payout_amount_usdc, evidence_id, reasons_json, created_at, updated_at)

evidence(id, claim_id, order_ref, exchange, raw_order_json, liquidation_json, merkle_root, proof_json, source_dir, created_at)

payouts(id, claim_id, amount_usdc, dest_wallet, status, onchain_tx_id, created_at)

onchain_txs(id, chain_id, tx_hash UNIQUE, status, block_number, receipt_json, created_at)

关系

点“查看证据”跳转 /evidence/:claimId。

完成后可返回 /orders 或 /dashboard。

边界

找不到对应订单：错误 ORDER_NOT_FOUND。

未支付订单：错误 ORDER_NOT_PAID。

无法确认强平：错误 EVIDENCE_INSUFFICIENT（可提示稍后重试）。

AI 要点

计算结果与原始证据都要落库，避免重算分歧。

赔付上链前再次二次校验状态，防重复赔付（幂等 + 数据库事务）。